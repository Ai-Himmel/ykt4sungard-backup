/* soapC.cpp
   Generated by gSOAP 2.7.8c from CamsWebService.h
   Copyright (C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.8c 2009-03-02 09:49:47 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ns36__BindParam:
		return soap_in_ns36__BindParam(soap, NULL, NULL, "ns36:BindParam");
	case SOAP_TYPE_ns35__AccountListQueryInfo:
		return soap_in_ns35__AccountListQueryInfo(soap, NULL, NULL, "ns35:AccountListQueryInfo");
	case SOAP_TYPE_ns34__LanAccessDetailQueryInfo:
		return soap_in_ns34__LanAccessDetailQueryInfo(soap, NULL, NULL, "ns34:LanAccessDetailQueryInfo");
	case SOAP_TYPE_ns33__LanQryCondition:
		return soap_in_ns33__LanQryCondition(soap, NULL, NULL, "ns33:LanQryCondition");
	case SOAP_TYPE_ns32__BlackListQueryInfo:
		return soap_in_ns32__BlackListQueryInfo(soap, NULL, NULL, "ns32:BlackListQueryInfo");
	case SOAP_TYPE_ns31__DelUserServiceParam:
		return soap_in_ns31__DelUserServiceParam(soap, NULL, NULL, "ns31:DelUserServiceParam");
	case SOAP_TYPE_ns30__ApplyServiceParam:
		return soap_in_ns30__ApplyServiceParam(soap, NULL, NULL, "ns30:ApplyServiceParam");
	case SOAP_TYPE_ns29__ChgAcctPassParam:
		return soap_in_ns29__ChgAcctPassParam(soap, NULL, NULL, "ns29:ChgAcctPassParam");
	case SOAP_TYPE_ns28__DelAcctParam:
		return soap_in_ns28__DelAcctParam(soap, NULL, NULL, "ns28:DelAcctParam");
	case SOAP_TYPE_ns27__ModifyAcctParam:
		return soap_in_ns27__ModifyAcctParam(soap, NULL, NULL, "ns27:ModifyAcctParam");
	case SOAP_TYPE_ns26__AddAcctParam:
		return soap_in_ns26__AddAcctParam(soap, NULL, NULL, "ns26:AddAcctParam");
	case SOAP_TYPE_ns25__ApplyServiceInfo:
		return soap_in_ns25__ApplyServiceInfo(soap, NULL, NULL, "ns25:ApplyServiceInfo");
	case SOAP_TYPE_ns24__QueryActionInfo:
		return soap_in_ns24__QueryActionInfo(soap, NULL, NULL, "ns24:QueryActionInfo");
	case SOAP_TYPE_ns23__OperatorInfo:
		return soap_in_ns23__OperatorInfo(soap, NULL, NULL, "ns23:OperatorInfo");
	case SOAP_TYPE_ns22__ResultBase:
		return soap_in_ns22__ResultBase(soap, NULL, NULL, "ns22:ResultBase");
	case SOAP_TYPE_ns21__UserBalance:
		return soap_in_ns21__UserBalance(soap, NULL, NULL, "ns21:UserBalance");
	case SOAP_TYPE_ns20__SingleResult:
		return soap_in_ns20__SingleResult(soap, NULL, NULL, "ns20:SingleResult");
	case SOAP_TYPE_ns19__LanServiceList:
		return soap_in_ns19__LanServiceList(soap, NULL, NULL, "ns19:LanServiceList");
	case SOAP_TYPE_ns18__LanServiceInfo:
		return soap_in_ns18__LanServiceInfo(soap, NULL, NULL, "ns18:LanServiceInfo");
	case SOAP_TYPE_ns17__BlackList:
		return soap_in_ns17__BlackList(soap, NULL, NULL, "ns17:BlackList");
	case SOAP_TYPE_ns16__BlackListInfo:
		return soap_in_ns16__BlackListInfo(soap, NULL, NULL, "ns16:BlackListInfo");
	case SOAP_TYPE_ns15__RetUserAppendInfo:
		return soap_in_ns15__RetUserAppendInfo(soap, NULL, NULL, "ns15:RetUserAppendInfo");
	case SOAP_TYPE_ns14__UserAppendInfo:
		return soap_in_ns14__UserAppendInfo(soap, NULL, NULL, "ns14:UserAppendInfo");
	case SOAP_TYPE_ns13__RetAcctServiceInfo:
		return soap_in_ns13__RetAcctServiceInfo(soap, NULL, NULL, "ns13:RetAcctServiceInfo");
	case SOAP_TYPE_ns12__AcctServiceInfo:
		return soap_in_ns12__AcctServiceInfo(soap, NULL, NULL, "ns12:AcctServiceInfo");
	case SOAP_TYPE_ns11__RetPassword:
		return soap_in_ns11__RetPassword(soap, NULL, NULL, "ns11:RetPassword");
	case SOAP_TYPE_ns10__RetAccountList:
		return soap_in_ns10__RetAccountList(soap, NULL, NULL, "ns10:RetAccountList");
	case SOAP_TYPE_ns9__AcctBasicInfo:
		return soap_in_ns9__AcctBasicInfo(soap, NULL, NULL, "ns9:AcctBasicInfo");
	case SOAP_TYPE_ns8__RetUserInfo:
		return soap_in_ns8__RetUserInfo(soap, NULL, NULL, "ns8:RetUserInfo");
	case SOAP_TYPE_ns7__MultiResult:
		return soap_in_ns7__MultiResult(soap, NULL, NULL, "ns7:MultiResult");
	case SOAP_TYPE_ns6__RandomInfo:
		return soap_in_ns6__RandomInfo(soap, NULL, NULL, "ns6:RandomInfo");
	case SOAP_TYPE_ns5__LanAccessDetailList:
		return soap_in_ns5__LanAccessDetailList(soap, NULL, NULL, "ns5:LanAccessDetailList");
	case SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo:
		return soap_in_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, NULL, NULL, "ns25:ApplyServiceInfo");
	case SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo:
		return soap_in_ArrayOf_USCOREtns19_USCORELanServiceInfo(soap, NULL, NULL, "ns18:LanServiceInfo");
	case SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo:
		return soap_in_ArrayOf_USCOREtns17_USCOREBlackListInfo(soap, NULL, NULL, "ns16:BlackListInfo");
	case SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo:
		return soap_in_ArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, NULL, NULL, "ns14:UserAppendInfo");
	case SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo:
		return soap_in_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, NULL, NULL, "ns12:AcctServiceInfo");
	case SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo:
		return soap_in_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, NULL, NULL, "ns9:AcctBasicInfo");
	case SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring:
		return soap_in_ArrayOfArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, "xsd:string[]");
	case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
		return soap_in_ArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo:
		return soap_in_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, NULL, NULL, "ns4:LanAccessDetailInfo");
	case SOAP_TYPE_ns4__LanAccessDetailInfo:
		return soap_in_ns4__LanAccessDetailInfo(soap, NULL, NULL, "ns4:LanAccessDetailInfo");
	case SOAP_TYPE_ns3__RetDelUserInfo:
		return soap_in_ns3__RetDelUserInfo(soap, NULL, NULL, "ns3:RetDelUserInfo");
	case SOAP_TYPE_ns2__PayParam:
		return soap_in_ns2__PayParam(soap, NULL, NULL, "ns2:PayParam");
	case SOAP_TYPE_ns37__bindAccount:
		return soap_in_ns37__bindAccount(soap, NULL, NULL, "ns37:bindAccount");
	case SOAP_TYPE_ns37__bindAccountResponse:
		return soap_in_ns37__bindAccountResponse(soap, NULL, NULL, "ns37:bindAccountResponse");
	case SOAP_TYPE_ns37__queryAcctList:
		return soap_in_ns37__queryAcctList(soap, NULL, NULL, "ns37:queryAcctList");
	case SOAP_TYPE_ns37__queryAcctListResponse:
		return soap_in_ns37__queryAcctListResponse(soap, NULL, NULL, "ns37:queryAcctListResponse");
	case SOAP_TYPE_ns37__queryLanAccessDetail:
		return soap_in_ns37__queryLanAccessDetail(soap, NULL, NULL, "ns37:queryLanAccessDetail");
	case SOAP_TYPE_ns37__queryLanAccessDetailResponse:
		return soap_in_ns37__queryLanAccessDetailResponse(soap, NULL, NULL, "ns37:queryLanAccessDetailResponse");
	case SOAP_TYPE_ns37__queryLanService:
		return soap_in_ns37__queryLanService(soap, NULL, NULL, "ns37:queryLanService");
	case SOAP_TYPE_ns37__queryLanServiceResponse:
		return soap_in_ns37__queryLanServiceResponse(soap, NULL, NULL, "ns37:queryLanServiceResponse");
	case SOAP_TYPE_ns37__queryUserBalance:
		return soap_in_ns37__queryUserBalance(soap, NULL, NULL, "ns37:queryUserBalance");
	case SOAP_TYPE_ns37__queryUserBalanceResponse:
		return soap_in_ns37__queryUserBalanceResponse(soap, NULL, NULL, "ns37:queryUserBalanceResponse");
	case SOAP_TYPE_ns37__queryBlackList:
		return soap_in_ns37__queryBlackList(soap, NULL, NULL, "ns37:queryBlackList");
	case SOAP_TYPE_ns37__queryBlackListResponse:
		return soap_in_ns37__queryBlackListResponse(soap, NULL, NULL, "ns37:queryBlackListResponse");
	case SOAP_TYPE_ns37__deleteBlackList:
		return soap_in_ns37__deleteBlackList(soap, NULL, NULL, "ns37:deleteBlackList");
	case SOAP_TYPE_ns37__deleteBlackListResponse:
		return soap_in_ns37__deleteBlackListResponse(soap, NULL, NULL, "ns37:deleteBlackListResponse");
	case SOAP_TYPE_ns37__addBlackList:
		return soap_in_ns37__addBlackList(soap, NULL, NULL, "ns37:addBlackList");
	case SOAP_TYPE_ns37__addBlackListResponse:
		return soap_in_ns37__addBlackListResponse(soap, NULL, NULL, "ns37:addBlackListResponse");
	case SOAP_TYPE_ns37__queryAppendDefInfo:
		return soap_in_ns37__queryAppendDefInfo(soap, NULL, NULL, "ns37:queryAppendDefInfo");
	case SOAP_TYPE_ns37__queryAppendDefInfoResponse:
		return soap_in_ns37__queryAppendDefInfoResponse(soap, NULL, NULL, "ns37:queryAppendDefInfoResponse");
	case SOAP_TYPE_ns37__queryAcctServiceInfo:
		return soap_in_ns37__queryAcctServiceInfo(soap, NULL, NULL, "ns37:queryAcctServiceInfo");
	case SOAP_TYPE_ns37__queryAcctServiceInfoResponse:
		return soap_in_ns37__queryAcctServiceInfoResponse(soap, NULL, NULL, "ns37:queryAcctServiceInfoResponse");
	case SOAP_TYPE_ns37__cancelService:
		return soap_in_ns37__cancelService(soap, NULL, NULL, "ns37:cancelService");
	case SOAP_TYPE_ns37__cancelServiceResponse:
		return soap_in_ns37__cancelServiceResponse(soap, NULL, NULL, "ns37:cancelServiceResponse");
	case SOAP_TYPE_ns37__applyService:
		return soap_in_ns37__applyService(soap, NULL, NULL, "ns37:applyService");
	case SOAP_TYPE_ns37__applyServiceResponse:
		return soap_in_ns37__applyServiceResponse(soap, NULL, NULL, "ns37:applyServiceResponse");
	case SOAP_TYPE_ns37__changeAcctPassword:
		return soap_in_ns37__changeAcctPassword(soap, NULL, NULL, "ns37:changeAcctPassword");
	case SOAP_TYPE_ns37__changeAcctPasswordResponse:
		return soap_in_ns37__changeAcctPasswordResponse(soap, NULL, NULL, "ns37:changeAcctPasswordResponse");
	case SOAP_TYPE_ns37__queryAcctPassword:
		return soap_in_ns37__queryAcctPassword(soap, NULL, NULL, "ns37:queryAcctPassword");
	case SOAP_TYPE_ns37__queryAcctPasswordResponse:
		return soap_in_ns37__queryAcctPasswordResponse(soap, NULL, NULL, "ns37:queryAcctPasswordResponse");
	case SOAP_TYPE_ns37__queryAcctByName:
		return soap_in_ns37__queryAcctByName(soap, NULL, NULL, "ns37:queryAcctByName");
	case SOAP_TYPE_ns37__queryAcctByNameResponse:
		return soap_in_ns37__queryAcctByNameResponse(soap, NULL, NULL, "ns37:queryAcctByNameResponse");
	case SOAP_TYPE_ns37__deleteAcctUser:
		return soap_in_ns37__deleteAcctUser(soap, NULL, NULL, "ns37:deleteAcctUser");
	case SOAP_TYPE_ns37__deleteAcctUserResponse:
		return soap_in_ns37__deleteAcctUserResponse(soap, NULL, NULL, "ns37:deleteAcctUserResponse");
	case SOAP_TYPE_ns37__modifyAcctUser:
		return soap_in_ns37__modifyAcctUser(soap, NULL, NULL, "ns37:modifyAcctUser");
	case SOAP_TYPE_ns37__modifyAcctUserResponse:
		return soap_in_ns37__modifyAcctUserResponse(soap, NULL, NULL, "ns37:modifyAcctUserResponse");
	case SOAP_TYPE_ns37__addAcctUser:
		return soap_in_ns37__addAcctUser(soap, NULL, NULL, "ns37:addAcctUser");
	case SOAP_TYPE_ns37__addAcctUserResponse:
		return soap_in_ns37__addAcctUserResponse(soap, NULL, NULL, "ns37:addAcctUserResponse");
	case SOAP_TYPE_ns37__multiQuery:
		return soap_in_ns37__multiQuery(soap, NULL, NULL, "ns37:multiQuery");
	case SOAP_TYPE_ns37__multiQueryResponse:
		return soap_in_ns37__multiQueryResponse(soap, NULL, NULL, "ns37:multiQueryResponse");
	case SOAP_TYPE_ns37__singleQuery:
		return soap_in_ns37__singleQuery(soap, NULL, NULL, "ns37:singleQuery");
	case SOAP_TYPE_ns37__singleQueryResponse:
		return soap_in_ns37__singleQueryResponse(soap, NULL, NULL, "ns37:singleQueryResponse");
	case SOAP_TYPE_ns37__logout:
		return soap_in_ns37__logout(soap, NULL, NULL, "ns37:logout");
	case SOAP_TYPE_ns37__logoutResponse:
		return soap_in_ns37__logoutResponse(soap, NULL, NULL, "ns37:logoutResponse");
	case SOAP_TYPE_ns37__login:
		return soap_in_ns37__login(soap, NULL, NULL, "ns37:login");
	case SOAP_TYPE_ns37__loginResponse:
		return soap_in_ns37__loginResponse(soap, NULL, NULL, "ns37:loginResponse");
	case SOAP_TYPE_ns37__randomReq:
		return soap_in_ns37__randomReq(soap, NULL, NULL, "ns37:randomReq");
	case SOAP_TYPE_ns37__randomReqResponse:
		return soap_in_ns37__randomReqResponse(soap, NULL, NULL, "ns37:randomReqResponse");
	case SOAP_TYPE_ns37__pay:
		return soap_in_ns37__pay(soap, NULL, NULL, "ns37:pay");
	case SOAP_TYPE_ns37__payResponse:
		return soap_in_ns37__payResponse(soap, NULL, NULL, "ns37:payResponse");
	case SOAP_TYPE_PointerTons36__BindParam:
		return soap_in_PointerTons36__BindParam(soap, NULL, NULL, "ns36:BindParam");
	case SOAP_TYPE_PointerTons35__AccountListQueryInfo:
		return soap_in_PointerTons35__AccountListQueryInfo(soap, NULL, NULL, "ns35:AccountListQueryInfo");
	case SOAP_TYPE_PointerTons10__RetAccountList:
		return soap_in_PointerTons10__RetAccountList(soap, NULL, NULL, "ns10:RetAccountList");
	case SOAP_TYPE_PointerTons34__LanAccessDetailQueryInfo:
		return soap_in_PointerTons34__LanAccessDetailQueryInfo(soap, NULL, NULL, "ns34:LanAccessDetailQueryInfo");
	case SOAP_TYPE_PointerTons5__LanAccessDetailList:
		return soap_in_PointerTons5__LanAccessDetailList(soap, NULL, NULL, "ns5:LanAccessDetailList");
	case SOAP_TYPE_PointerTons33__LanQryCondition:
		return soap_in_PointerTons33__LanQryCondition(soap, NULL, NULL, "ns33:LanQryCondition");
	case SOAP_TYPE_PointerTons19__LanServiceList:
		return soap_in_PointerTons19__LanServiceList(soap, NULL, NULL, "ns19:LanServiceList");
	case SOAP_TYPE_PointerTons21__UserBalance:
		return soap_in_PointerTons21__UserBalance(soap, NULL, NULL, "ns21:UserBalance");
	case SOAP_TYPE_PointerTons32__BlackListQueryInfo:
		return soap_in_PointerTons32__BlackListQueryInfo(soap, NULL, NULL, "ns32:BlackListQueryInfo");
	case SOAP_TYPE_PointerTons17__BlackList:
		return soap_in_PointerTons17__BlackList(soap, NULL, NULL, "ns17:BlackList");
	case SOAP_TYPE_PointerTons15__RetUserAppendInfo:
		return soap_in_PointerTons15__RetUserAppendInfo(soap, NULL, NULL, "ns15:RetUserAppendInfo");
	case SOAP_TYPE_PointerTons13__RetAcctServiceInfo:
		return soap_in_PointerTons13__RetAcctServiceInfo(soap, NULL, NULL, "ns13:RetAcctServiceInfo");
	case SOAP_TYPE_PointerTons31__DelUserServiceParam:
		return soap_in_PointerTons31__DelUserServiceParam(soap, NULL, NULL, "ns31:DelUserServiceParam");
	case SOAP_TYPE_PointerTons30__ApplyServiceParam:
		return soap_in_PointerTons30__ApplyServiceParam(soap, NULL, NULL, "ns30:ApplyServiceParam");
	case SOAP_TYPE_PointerTons29__ChgAcctPassParam:
		return soap_in_PointerTons29__ChgAcctPassParam(soap, NULL, NULL, "ns29:ChgAcctPassParam");
	case SOAP_TYPE_PointerTons11__RetPassword:
		return soap_in_PointerTons11__RetPassword(soap, NULL, NULL, "ns11:RetPassword");
	case SOAP_TYPE_PointerTons8__RetUserInfo:
		return soap_in_PointerTons8__RetUserInfo(soap, NULL, NULL, "ns8:RetUserInfo");
	case SOAP_TYPE_PointerTons28__DelAcctParam:
		return soap_in_PointerTons28__DelAcctParam(soap, NULL, NULL, "ns28:DelAcctParam");
	case SOAP_TYPE_PointerTons3__RetDelUserInfo:
		return soap_in_PointerTons3__RetDelUserInfo(soap, NULL, NULL, "ns3:RetDelUserInfo");
	case SOAP_TYPE_PointerTons27__ModifyAcctParam:
		return soap_in_PointerTons27__ModifyAcctParam(soap, NULL, NULL, "ns27:ModifyAcctParam");
	case SOAP_TYPE_PointerTons26__AddAcctParam:
		return soap_in_PointerTons26__AddAcctParam(soap, NULL, NULL, "ns26:AddAcctParam");
	case SOAP_TYPE_PointerTons7__MultiResult:
		return soap_in_PointerTons7__MultiResult(soap, NULL, NULL, "ns7:MultiResult");
	case SOAP_TYPE_PointerTons24__QueryActionInfo:
		return soap_in_PointerTons24__QueryActionInfo(soap, NULL, NULL, "ns24:QueryActionInfo");
	case SOAP_TYPE_PointerTons20__SingleResult:
		return soap_in_PointerTons20__SingleResult(soap, NULL, NULL, "ns20:SingleResult");
	case SOAP_TYPE_PointerTons23__OperatorInfo:
		return soap_in_PointerTons23__OperatorInfo(soap, NULL, NULL, "ns23:OperatorInfo");
	case SOAP_TYPE_PointerTons6__RandomInfo:
		return soap_in_PointerTons6__RandomInfo(soap, NULL, NULL, "ns6:RandomInfo");
	case SOAP_TYPE_PointerTons2__PayParam:
		return soap_in_PointerTons2__PayParam(soap, NULL, NULL, "ns2:PayParam");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo:
		return soap_in_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(soap, NULL, NULL, "ns18:LanServiceInfo");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo:
		return soap_in_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(soap, NULL, NULL, "ns16:BlackListInfo");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo:
		return soap_in_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, NULL, NULL, "ns14:UserAppendInfo");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo:
		return soap_in_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, NULL, NULL, "ns12:AcctServiceInfo");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo:
		return soap_in_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, NULL, NULL, "ns9:AcctBasicInfo");
	case SOAP_TYPE_PointerToArrayOfArrayOf_USCORExsd_USCOREstring:
		return soap_in_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, "xsd:string[]");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo:
		return soap_in_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, NULL, NULL, "ns4:LanAccessDetailInfo");
	case SOAP_TYPE_PointerToPointerTons25__ApplyServiceInfo:
		return soap_in_PointerToPointerTons25__ApplyServiceInfo(soap, NULL, NULL, "ns25:ApplyServiceInfo");
	case SOAP_TYPE_PointerTons25__ApplyServiceInfo:
		return soap_in_PointerTons25__ApplyServiceInfo(soap, NULL, NULL, "ns25:ApplyServiceInfo");
	case SOAP_TYPE_PointerToPointerTons18__LanServiceInfo:
		return soap_in_PointerToPointerTons18__LanServiceInfo(soap, NULL, NULL, "ns18:LanServiceInfo");
	case SOAP_TYPE_PointerTons18__LanServiceInfo:
		return soap_in_PointerTons18__LanServiceInfo(soap, NULL, NULL, "ns18:LanServiceInfo");
	case SOAP_TYPE_PointerToPointerTons16__BlackListInfo:
		return soap_in_PointerToPointerTons16__BlackListInfo(soap, NULL, NULL, "ns16:BlackListInfo");
	case SOAP_TYPE_PointerTons16__BlackListInfo:
		return soap_in_PointerTons16__BlackListInfo(soap, NULL, NULL, "ns16:BlackListInfo");
	case SOAP_TYPE_PointerToPointerTons14__UserAppendInfo:
		return soap_in_PointerToPointerTons14__UserAppendInfo(soap, NULL, NULL, "ns14:UserAppendInfo");
	case SOAP_TYPE_PointerTons14__UserAppendInfo:
		return soap_in_PointerTons14__UserAppendInfo(soap, NULL, NULL, "ns14:UserAppendInfo");
	case SOAP_TYPE_PointerToPointerTons12__AcctServiceInfo:
		return soap_in_PointerToPointerTons12__AcctServiceInfo(soap, NULL, NULL, "ns12:AcctServiceInfo");
	case SOAP_TYPE_PointerTons12__AcctServiceInfo:
		return soap_in_PointerTons12__AcctServiceInfo(soap, NULL, NULL, "ns12:AcctServiceInfo");
	case SOAP_TYPE_PointerToPointerTons9__AcctBasicInfo:
		return soap_in_PointerToPointerTons9__AcctBasicInfo(soap, NULL, NULL, "ns9:AcctBasicInfo");
	case SOAP_TYPE_PointerTons9__AcctBasicInfo:
		return soap_in_PointerTons9__AcctBasicInfo(soap, NULL, NULL, "ns9:AcctBasicInfo");
	case SOAP_TYPE_PointerTo_Struct_1:
		return soap_in_PointerTo_Struct_1(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons4__LanAccessDetailInfo:
		return soap_in_PointerToPointerTons4__LanAccessDetailInfo(soap, NULL, NULL, "ns4:LanAccessDetailInfo");
	case SOAP_TYPE_PointerTons4__LanAccessDetailInfo:
		return soap_in_PointerTons4__LanAccessDetailInfo(soap, NULL, NULL, "ns4:LanAccessDetailInfo");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo:
		return soap_in_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, NULL, NULL, "ns25:ApplyServiceInfo");
	case SOAP_TYPE_PointerTons22__ResultBase:
		return soap_in_PointerTons22__ResultBase(soap, NULL, NULL, "ns22:ResultBase");
	case SOAP_TYPE_PointerToArrayOf_USCORExsd_USCOREstring:
		return soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns36:BindParam"))
		{	*type = SOAP_TYPE_ns36__BindParam;
			return soap_in_ns36__BindParam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns35:AccountListQueryInfo"))
		{	*type = SOAP_TYPE_ns35__AccountListQueryInfo;
			return soap_in_ns35__AccountListQueryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns34:LanAccessDetailQueryInfo"))
		{	*type = SOAP_TYPE_ns34__LanAccessDetailQueryInfo;
			return soap_in_ns34__LanAccessDetailQueryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns33:LanQryCondition"))
		{	*type = SOAP_TYPE_ns33__LanQryCondition;
			return soap_in_ns33__LanQryCondition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns32:BlackListQueryInfo"))
		{	*type = SOAP_TYPE_ns32__BlackListQueryInfo;
			return soap_in_ns32__BlackListQueryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns31:DelUserServiceParam"))
		{	*type = SOAP_TYPE_ns31__DelUserServiceParam;
			return soap_in_ns31__DelUserServiceParam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns30:ApplyServiceParam"))
		{	*type = SOAP_TYPE_ns30__ApplyServiceParam;
			return soap_in_ns30__ApplyServiceParam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns29:ChgAcctPassParam"))
		{	*type = SOAP_TYPE_ns29__ChgAcctPassParam;
			return soap_in_ns29__ChgAcctPassParam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns28:DelAcctParam"))
		{	*type = SOAP_TYPE_ns28__DelAcctParam;
			return soap_in_ns28__DelAcctParam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns27:ModifyAcctParam"))
		{	*type = SOAP_TYPE_ns27__ModifyAcctParam;
			return soap_in_ns27__ModifyAcctParam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns26:AddAcctParam"))
		{	*type = SOAP_TYPE_ns26__AddAcctParam;
			return soap_in_ns26__AddAcctParam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns25:ApplyServiceInfo"))
		{	*type = SOAP_TYPE_ns25__ApplyServiceInfo;
			return soap_in_ns25__ApplyServiceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns24:QueryActionInfo"))
		{	*type = SOAP_TYPE_ns24__QueryActionInfo;
			return soap_in_ns24__QueryActionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns23:OperatorInfo"))
		{	*type = SOAP_TYPE_ns23__OperatorInfo;
			return soap_in_ns23__OperatorInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns22:ResultBase"))
		{	*type = SOAP_TYPE_ns22__ResultBase;
			return soap_in_ns22__ResultBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns21:UserBalance"))
		{	*type = SOAP_TYPE_ns21__UserBalance;
			return soap_in_ns21__UserBalance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns20:SingleResult"))
		{	*type = SOAP_TYPE_ns20__SingleResult;
			return soap_in_ns20__SingleResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns19:LanServiceList"))
		{	*type = SOAP_TYPE_ns19__LanServiceList;
			return soap_in_ns19__LanServiceList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns18:LanServiceInfo"))
		{	*type = SOAP_TYPE_ns18__LanServiceInfo;
			return soap_in_ns18__LanServiceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns17:BlackList"))
		{	*type = SOAP_TYPE_ns17__BlackList;
			return soap_in_ns17__BlackList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns16:BlackListInfo"))
		{	*type = SOAP_TYPE_ns16__BlackListInfo;
			return soap_in_ns16__BlackListInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns15:RetUserAppendInfo"))
		{	*type = SOAP_TYPE_ns15__RetUserAppendInfo;
			return soap_in_ns15__RetUserAppendInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns14:UserAppendInfo"))
		{	*type = SOAP_TYPE_ns14__UserAppendInfo;
			return soap_in_ns14__UserAppendInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns13:RetAcctServiceInfo"))
		{	*type = SOAP_TYPE_ns13__RetAcctServiceInfo;
			return soap_in_ns13__RetAcctServiceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns12:AcctServiceInfo"))
		{	*type = SOAP_TYPE_ns12__AcctServiceInfo;
			return soap_in_ns12__AcctServiceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns11:RetPassword"))
		{	*type = SOAP_TYPE_ns11__RetPassword;
			return soap_in_ns11__RetPassword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns10:RetAccountList"))
		{	*type = SOAP_TYPE_ns10__RetAccountList;
			return soap_in_ns10__RetAccountList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns9:AcctBasicInfo"))
		{	*type = SOAP_TYPE_ns9__AcctBasicInfo;
			return soap_in_ns9__AcctBasicInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns8:RetUserInfo"))
		{	*type = SOAP_TYPE_ns8__RetUserInfo;
			return soap_in_ns8__RetUserInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:MultiResult"))
		{	*type = SOAP_TYPE_ns7__MultiResult;
			return soap_in_ns7__MultiResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:RandomInfo"))
		{	*type = SOAP_TYPE_ns6__RandomInfo;
			return soap_in_ns6__RandomInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:LanAccessDetailList"))
		{	*type = SOAP_TYPE_ns5__LanAccessDetailList;
			return soap_in_ns5__LanAccessDetailList(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns25:ApplyServiceInfo"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo;
			return soap_in_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns18:LanServiceInfo"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo;
			return soap_in_ArrayOf_USCOREtns19_USCORELanServiceInfo(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns16:BlackListInfo"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo;
			return soap_in_ArrayOf_USCOREtns17_USCOREBlackListInfo(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns14:UserAppendInfo"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo;
			return soap_in_ArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns12:AcctServiceInfo"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo;
			return soap_in_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns9:AcctBasicInfo"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo;
			return soap_in_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string[]"))
		{	*type = SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring;
			return soap_in_ArrayOfArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring;
			return soap_in_ArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns4:LanAccessDetailInfo"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo;
			return soap_in_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:LanAccessDetailInfo"))
		{	*type = SOAP_TYPE_ns4__LanAccessDetailInfo;
			return soap_in_ns4__LanAccessDetailInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:RetDelUserInfo"))
		{	*type = SOAP_TYPE_ns3__RetDelUserInfo;
			return soap_in_ns3__RetDelUserInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PayParam"))
		{	*type = SOAP_TYPE_ns2__PayParam;
			return soap_in_ns2__PayParam(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:bindAccount"))
		{	*type = SOAP_TYPE_ns37__bindAccount;
			return soap_in_ns37__bindAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:bindAccountResponse"))
		{	*type = SOAP_TYPE_ns37__bindAccountResponse;
			return soap_in_ns37__bindAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryAcctList"))
		{	*type = SOAP_TYPE_ns37__queryAcctList;
			return soap_in_ns37__queryAcctList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryAcctListResponse"))
		{	*type = SOAP_TYPE_ns37__queryAcctListResponse;
			return soap_in_ns37__queryAcctListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryLanAccessDetail"))
		{	*type = SOAP_TYPE_ns37__queryLanAccessDetail;
			return soap_in_ns37__queryLanAccessDetail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryLanAccessDetailResponse"))
		{	*type = SOAP_TYPE_ns37__queryLanAccessDetailResponse;
			return soap_in_ns37__queryLanAccessDetailResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryLanService"))
		{	*type = SOAP_TYPE_ns37__queryLanService;
			return soap_in_ns37__queryLanService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryLanServiceResponse"))
		{	*type = SOAP_TYPE_ns37__queryLanServiceResponse;
			return soap_in_ns37__queryLanServiceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryUserBalance"))
		{	*type = SOAP_TYPE_ns37__queryUserBalance;
			return soap_in_ns37__queryUserBalance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryUserBalanceResponse"))
		{	*type = SOAP_TYPE_ns37__queryUserBalanceResponse;
			return soap_in_ns37__queryUserBalanceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryBlackList"))
		{	*type = SOAP_TYPE_ns37__queryBlackList;
			return soap_in_ns37__queryBlackList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryBlackListResponse"))
		{	*type = SOAP_TYPE_ns37__queryBlackListResponse;
			return soap_in_ns37__queryBlackListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:deleteBlackList"))
		{	*type = SOAP_TYPE_ns37__deleteBlackList;
			return soap_in_ns37__deleteBlackList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:deleteBlackListResponse"))
		{	*type = SOAP_TYPE_ns37__deleteBlackListResponse;
			return soap_in_ns37__deleteBlackListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:addBlackList"))
		{	*type = SOAP_TYPE_ns37__addBlackList;
			return soap_in_ns37__addBlackList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:addBlackListResponse"))
		{	*type = SOAP_TYPE_ns37__addBlackListResponse;
			return soap_in_ns37__addBlackListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryAppendDefInfo"))
		{	*type = SOAP_TYPE_ns37__queryAppendDefInfo;
			return soap_in_ns37__queryAppendDefInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryAppendDefInfoResponse"))
		{	*type = SOAP_TYPE_ns37__queryAppendDefInfoResponse;
			return soap_in_ns37__queryAppendDefInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryAcctServiceInfo"))
		{	*type = SOAP_TYPE_ns37__queryAcctServiceInfo;
			return soap_in_ns37__queryAcctServiceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryAcctServiceInfoResponse"))
		{	*type = SOAP_TYPE_ns37__queryAcctServiceInfoResponse;
			return soap_in_ns37__queryAcctServiceInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:cancelService"))
		{	*type = SOAP_TYPE_ns37__cancelService;
			return soap_in_ns37__cancelService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:cancelServiceResponse"))
		{	*type = SOAP_TYPE_ns37__cancelServiceResponse;
			return soap_in_ns37__cancelServiceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:applyService"))
		{	*type = SOAP_TYPE_ns37__applyService;
			return soap_in_ns37__applyService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:applyServiceResponse"))
		{	*type = SOAP_TYPE_ns37__applyServiceResponse;
			return soap_in_ns37__applyServiceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:changeAcctPassword"))
		{	*type = SOAP_TYPE_ns37__changeAcctPassword;
			return soap_in_ns37__changeAcctPassword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:changeAcctPasswordResponse"))
		{	*type = SOAP_TYPE_ns37__changeAcctPasswordResponse;
			return soap_in_ns37__changeAcctPasswordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryAcctPassword"))
		{	*type = SOAP_TYPE_ns37__queryAcctPassword;
			return soap_in_ns37__queryAcctPassword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryAcctPasswordResponse"))
		{	*type = SOAP_TYPE_ns37__queryAcctPasswordResponse;
			return soap_in_ns37__queryAcctPasswordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryAcctByName"))
		{	*type = SOAP_TYPE_ns37__queryAcctByName;
			return soap_in_ns37__queryAcctByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:queryAcctByNameResponse"))
		{	*type = SOAP_TYPE_ns37__queryAcctByNameResponse;
			return soap_in_ns37__queryAcctByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:deleteAcctUser"))
		{	*type = SOAP_TYPE_ns37__deleteAcctUser;
			return soap_in_ns37__deleteAcctUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:deleteAcctUserResponse"))
		{	*type = SOAP_TYPE_ns37__deleteAcctUserResponse;
			return soap_in_ns37__deleteAcctUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:modifyAcctUser"))
		{	*type = SOAP_TYPE_ns37__modifyAcctUser;
			return soap_in_ns37__modifyAcctUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:modifyAcctUserResponse"))
		{	*type = SOAP_TYPE_ns37__modifyAcctUserResponse;
			return soap_in_ns37__modifyAcctUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:addAcctUser"))
		{	*type = SOAP_TYPE_ns37__addAcctUser;
			return soap_in_ns37__addAcctUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:addAcctUserResponse"))
		{	*type = SOAP_TYPE_ns37__addAcctUserResponse;
			return soap_in_ns37__addAcctUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:multiQuery"))
		{	*type = SOAP_TYPE_ns37__multiQuery;
			return soap_in_ns37__multiQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:multiQueryResponse"))
		{	*type = SOAP_TYPE_ns37__multiQueryResponse;
			return soap_in_ns37__multiQueryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:singleQuery"))
		{	*type = SOAP_TYPE_ns37__singleQuery;
			return soap_in_ns37__singleQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:singleQueryResponse"))
		{	*type = SOAP_TYPE_ns37__singleQueryResponse;
			return soap_in_ns37__singleQueryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:logout"))
		{	*type = SOAP_TYPE_ns37__logout;
			return soap_in_ns37__logout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:logoutResponse"))
		{	*type = SOAP_TYPE_ns37__logoutResponse;
			return soap_in_ns37__logoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:login"))
		{	*type = SOAP_TYPE_ns37__login;
			return soap_in_ns37__login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:loginResponse"))
		{	*type = SOAP_TYPE_ns37__loginResponse;
			return soap_in_ns37__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:randomReq"))
		{	*type = SOAP_TYPE_ns37__randomReq;
			return soap_in_ns37__randomReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:randomReqResponse"))
		{	*type = SOAP_TYPE_ns37__randomReqResponse;
			return soap_in_ns37__randomReqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:pay"))
		{	*type = SOAP_TYPE_ns37__pay;
			return soap_in_ns37__pay(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns37:payResponse"))
		{	*type = SOAP_TYPE_ns37__payResponse;
			return soap_in_ns37__payResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE__Struct_1;
			return soap_in__Struct_1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENC:arrayType"))
		{	char **s;
			*type = SOAP_TYPE__SOAP_ENC__arrayType;
			s = soap_in__SOAP_ENC__arrayType(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE__Struct_1:
		return ((_Struct_1 *)ptr)->soap_out(soap, "ArrayOfstring", id, NULL);
	case SOAP_TYPE_ns36__BindParam:
		return ((ns36__BindParam *)ptr)->soap_out(soap, tag, id, "ns36:BindParam");
	case SOAP_TYPE_ns35__AccountListQueryInfo:
		return ((ns35__AccountListQueryInfo *)ptr)->soap_out(soap, tag, id, "ns35:AccountListQueryInfo");
	case SOAP_TYPE_ns34__LanAccessDetailQueryInfo:
		return ((ns34__LanAccessDetailQueryInfo *)ptr)->soap_out(soap, tag, id, "ns34:LanAccessDetailQueryInfo");
	case SOAP_TYPE_ns33__LanQryCondition:
		return ((ns33__LanQryCondition *)ptr)->soap_out(soap, tag, id, "ns33:LanQryCondition");
	case SOAP_TYPE_ns32__BlackListQueryInfo:
		return ((ns32__BlackListQueryInfo *)ptr)->soap_out(soap, tag, id, "ns32:BlackListQueryInfo");
	case SOAP_TYPE_ns31__DelUserServiceParam:
		return ((ns31__DelUserServiceParam *)ptr)->soap_out(soap, tag, id, "ns31:DelUserServiceParam");
	case SOAP_TYPE_ns30__ApplyServiceParam:
		return ((ns30__ApplyServiceParam *)ptr)->soap_out(soap, tag, id, "ns30:ApplyServiceParam");
	case SOAP_TYPE_ns29__ChgAcctPassParam:
		return ((ns29__ChgAcctPassParam *)ptr)->soap_out(soap, tag, id, "ns29:ChgAcctPassParam");
	case SOAP_TYPE_ns28__DelAcctParam:
		return ((ns28__DelAcctParam *)ptr)->soap_out(soap, tag, id, "ns28:DelAcctParam");
	case SOAP_TYPE_ns27__ModifyAcctParam:
		return ((ns27__ModifyAcctParam *)ptr)->soap_out(soap, tag, id, "ns27:ModifyAcctParam");
	case SOAP_TYPE_ns26__AddAcctParam:
		return ((ns26__AddAcctParam *)ptr)->soap_out(soap, tag, id, "ns26:AddAcctParam");
	case SOAP_TYPE_ns25__ApplyServiceInfo:
		return ((ns25__ApplyServiceInfo *)ptr)->soap_out(soap, tag, id, "ns25:ApplyServiceInfo");
	case SOAP_TYPE_ns24__QueryActionInfo:
		return ((ns24__QueryActionInfo *)ptr)->soap_out(soap, tag, id, "ns24:QueryActionInfo");
	case SOAP_TYPE_ns23__OperatorInfo:
		return ((ns23__OperatorInfo *)ptr)->soap_out(soap, tag, id, "ns23:OperatorInfo");
	case SOAP_TYPE_ns22__ResultBase:
		return ((ns22__ResultBase *)ptr)->soap_out(soap, tag, id, "ns22:ResultBase");
	case SOAP_TYPE_ns21__UserBalance:
		return ((ns21__UserBalance *)ptr)->soap_out(soap, tag, id, "ns21:UserBalance");
	case SOAP_TYPE_ns20__SingleResult:
		return ((ns20__SingleResult *)ptr)->soap_out(soap, tag, id, "ns20:SingleResult");
	case SOAP_TYPE_ns19__LanServiceList:
		return ((ns19__LanServiceList *)ptr)->soap_out(soap, tag, id, "ns19:LanServiceList");
	case SOAP_TYPE_ns18__LanServiceInfo:
		return ((ns18__LanServiceInfo *)ptr)->soap_out(soap, tag, id, "ns18:LanServiceInfo");
	case SOAP_TYPE_ns17__BlackList:
		return ((ns17__BlackList *)ptr)->soap_out(soap, tag, id, "ns17:BlackList");
	case SOAP_TYPE_ns16__BlackListInfo:
		return ((ns16__BlackListInfo *)ptr)->soap_out(soap, tag, id, "ns16:BlackListInfo");
	case SOAP_TYPE_ns15__RetUserAppendInfo:
		return ((ns15__RetUserAppendInfo *)ptr)->soap_out(soap, tag, id, "ns15:RetUserAppendInfo");
	case SOAP_TYPE_ns14__UserAppendInfo:
		return ((ns14__UserAppendInfo *)ptr)->soap_out(soap, tag, id, "ns14:UserAppendInfo");
	case SOAP_TYPE_ns13__RetAcctServiceInfo:
		return ((ns13__RetAcctServiceInfo *)ptr)->soap_out(soap, tag, id, "ns13:RetAcctServiceInfo");
	case SOAP_TYPE_ns12__AcctServiceInfo:
		return ((ns12__AcctServiceInfo *)ptr)->soap_out(soap, tag, id, "ns12:AcctServiceInfo");
	case SOAP_TYPE_ns11__RetPassword:
		return ((ns11__RetPassword *)ptr)->soap_out(soap, tag, id, "ns11:RetPassword");
	case SOAP_TYPE_ns10__RetAccountList:
		return ((ns10__RetAccountList *)ptr)->soap_out(soap, tag, id, "ns10:RetAccountList");
	case SOAP_TYPE_ns9__AcctBasicInfo:
		return ((ns9__AcctBasicInfo *)ptr)->soap_out(soap, tag, id, "ns9:AcctBasicInfo");
	case SOAP_TYPE_ns8__RetUserInfo:
		return ((ns8__RetUserInfo *)ptr)->soap_out(soap, tag, id, "ns8:RetUserInfo");
	case SOAP_TYPE_ns7__MultiResult:
		return ((ns7__MultiResult *)ptr)->soap_out(soap, tag, id, "ns7:MultiResult");
	case SOAP_TYPE_ns6__RandomInfo:
		return ((ns6__RandomInfo *)ptr)->soap_out(soap, tag, id, "ns6:RandomInfo");
	case SOAP_TYPE_ns5__LanAccessDetailList:
		return ((ns5__LanAccessDetailList *)ptr)->soap_out(soap, tag, id, "ns5:LanAccessDetailList");
	case SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo:
		return ((ArrayOf_USCOREtns25_USCOREApplyServiceInfo *)ptr)->soap_out(soap, tag, id, "ns25:ApplyServiceInfo");
	case SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo:
		return ((ArrayOf_USCOREtns19_USCORELanServiceInfo *)ptr)->soap_out(soap, tag, id, "ns18:LanServiceInfo");
	case SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo:
		return ((ArrayOf_USCOREtns17_USCOREBlackListInfo *)ptr)->soap_out(soap, tag, id, "ns16:BlackListInfo");
	case SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo:
		return ((ArrayOf_USCOREtns15_USCOREUserAppendInfo *)ptr)->soap_out(soap, tag, id, "ns14:UserAppendInfo");
	case SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo:
		return ((ArrayOf_USCOREtns13_USCOREAcctServiceInfo *)ptr)->soap_out(soap, tag, id, "ns12:AcctServiceInfo");
	case SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo:
		return ((ArrayOf_USCOREtns10_USCOREAcctBasicInfo *)ptr)->soap_out(soap, tag, id, "ns9:AcctBasicInfo");
	case SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring:
		return ((ArrayOfArrayOf_USCORExsd_USCOREstring *)ptr)->soap_out(soap, tag, id, "xsd:string[]");
	case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
		return ((ArrayOf_USCORExsd_USCOREstring *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo:
		return ((ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *)ptr)->soap_out(soap, tag, id, "ns4:LanAccessDetailInfo");
	case SOAP_TYPE_ns4__LanAccessDetailInfo:
		return ((ns4__LanAccessDetailInfo *)ptr)->soap_out(soap, tag, id, "ns4:LanAccessDetailInfo");
	case SOAP_TYPE_ns3__RetDelUserInfo:
		return ((ns3__RetDelUserInfo *)ptr)->soap_out(soap, tag, id, "ns3:RetDelUserInfo");
	case SOAP_TYPE_ns2__PayParam:
		return ((ns2__PayParam *)ptr)->soap_out(soap, tag, id, "ns2:PayParam");
	case SOAP_TYPE_ns37__bindAccount:
		return soap_out_ns37__bindAccount(soap, tag, id, (const struct ns37__bindAccount *)ptr, "ns37:bindAccount");
	case SOAP_TYPE_ns37__bindAccountResponse:
		return soap_out_ns37__bindAccountResponse(soap, tag, id, (const struct ns37__bindAccountResponse *)ptr, "ns37:bindAccountResponse");
	case SOAP_TYPE_ns37__queryAcctList:
		return soap_out_ns37__queryAcctList(soap, tag, id, (const struct ns37__queryAcctList *)ptr, "ns37:queryAcctList");
	case SOAP_TYPE_ns37__queryAcctListResponse:
		return soap_out_ns37__queryAcctListResponse(soap, tag, id, (const struct ns37__queryAcctListResponse *)ptr, "ns37:queryAcctListResponse");
	case SOAP_TYPE_ns37__queryLanAccessDetail:
		return soap_out_ns37__queryLanAccessDetail(soap, tag, id, (const struct ns37__queryLanAccessDetail *)ptr, "ns37:queryLanAccessDetail");
	case SOAP_TYPE_ns37__queryLanAccessDetailResponse:
		return soap_out_ns37__queryLanAccessDetailResponse(soap, tag, id, (const struct ns37__queryLanAccessDetailResponse *)ptr, "ns37:queryLanAccessDetailResponse");
	case SOAP_TYPE_ns37__queryLanService:
		return soap_out_ns37__queryLanService(soap, tag, id, (const struct ns37__queryLanService *)ptr, "ns37:queryLanService");
	case SOAP_TYPE_ns37__queryLanServiceResponse:
		return soap_out_ns37__queryLanServiceResponse(soap, tag, id, (const struct ns37__queryLanServiceResponse *)ptr, "ns37:queryLanServiceResponse");
	case SOAP_TYPE_ns37__queryUserBalance:
		return soap_out_ns37__queryUserBalance(soap, tag, id, (const struct ns37__queryUserBalance *)ptr, "ns37:queryUserBalance");
	case SOAP_TYPE_ns37__queryUserBalanceResponse:
		return soap_out_ns37__queryUserBalanceResponse(soap, tag, id, (const struct ns37__queryUserBalanceResponse *)ptr, "ns37:queryUserBalanceResponse");
	case SOAP_TYPE_ns37__queryBlackList:
		return soap_out_ns37__queryBlackList(soap, tag, id, (const struct ns37__queryBlackList *)ptr, "ns37:queryBlackList");
	case SOAP_TYPE_ns37__queryBlackListResponse:
		return soap_out_ns37__queryBlackListResponse(soap, tag, id, (const struct ns37__queryBlackListResponse *)ptr, "ns37:queryBlackListResponse");
	case SOAP_TYPE_ns37__deleteBlackList:
		return soap_out_ns37__deleteBlackList(soap, tag, id, (const struct ns37__deleteBlackList *)ptr, "ns37:deleteBlackList");
	case SOAP_TYPE_ns37__deleteBlackListResponse:
		return soap_out_ns37__deleteBlackListResponse(soap, tag, id, (const struct ns37__deleteBlackListResponse *)ptr, "ns37:deleteBlackListResponse");
	case SOAP_TYPE_ns37__addBlackList:
		return soap_out_ns37__addBlackList(soap, tag, id, (const struct ns37__addBlackList *)ptr, "ns37:addBlackList");
	case SOAP_TYPE_ns37__addBlackListResponse:
		return soap_out_ns37__addBlackListResponse(soap, tag, id, (const struct ns37__addBlackListResponse *)ptr, "ns37:addBlackListResponse");
	case SOAP_TYPE_ns37__queryAppendDefInfo:
		return soap_out_ns37__queryAppendDefInfo(soap, tag, id, (const struct ns37__queryAppendDefInfo *)ptr, "ns37:queryAppendDefInfo");
	case SOAP_TYPE_ns37__queryAppendDefInfoResponse:
		return soap_out_ns37__queryAppendDefInfoResponse(soap, tag, id, (const struct ns37__queryAppendDefInfoResponse *)ptr, "ns37:queryAppendDefInfoResponse");
	case SOAP_TYPE_ns37__queryAcctServiceInfo:
		return soap_out_ns37__queryAcctServiceInfo(soap, tag, id, (const struct ns37__queryAcctServiceInfo *)ptr, "ns37:queryAcctServiceInfo");
	case SOAP_TYPE_ns37__queryAcctServiceInfoResponse:
		return soap_out_ns37__queryAcctServiceInfoResponse(soap, tag, id, (const struct ns37__queryAcctServiceInfoResponse *)ptr, "ns37:queryAcctServiceInfoResponse");
	case SOAP_TYPE_ns37__cancelService:
		return soap_out_ns37__cancelService(soap, tag, id, (const struct ns37__cancelService *)ptr, "ns37:cancelService");
	case SOAP_TYPE_ns37__cancelServiceResponse:
		return soap_out_ns37__cancelServiceResponse(soap, tag, id, (const struct ns37__cancelServiceResponse *)ptr, "ns37:cancelServiceResponse");
	case SOAP_TYPE_ns37__applyService:
		return soap_out_ns37__applyService(soap, tag, id, (const struct ns37__applyService *)ptr, "ns37:applyService");
	case SOAP_TYPE_ns37__applyServiceResponse:
		return soap_out_ns37__applyServiceResponse(soap, tag, id, (const struct ns37__applyServiceResponse *)ptr, "ns37:applyServiceResponse");
	case SOAP_TYPE_ns37__changeAcctPassword:
		return soap_out_ns37__changeAcctPassword(soap, tag, id, (const struct ns37__changeAcctPassword *)ptr, "ns37:changeAcctPassword");
	case SOAP_TYPE_ns37__changeAcctPasswordResponse:
		return soap_out_ns37__changeAcctPasswordResponse(soap, tag, id, (const struct ns37__changeAcctPasswordResponse *)ptr, "ns37:changeAcctPasswordResponse");
	case SOAP_TYPE_ns37__queryAcctPassword:
		return soap_out_ns37__queryAcctPassword(soap, tag, id, (const struct ns37__queryAcctPassword *)ptr, "ns37:queryAcctPassword");
	case SOAP_TYPE_ns37__queryAcctPasswordResponse:
		return soap_out_ns37__queryAcctPasswordResponse(soap, tag, id, (const struct ns37__queryAcctPasswordResponse *)ptr, "ns37:queryAcctPasswordResponse");
	case SOAP_TYPE_ns37__queryAcctByName:
		return soap_out_ns37__queryAcctByName(soap, tag, id, (const struct ns37__queryAcctByName *)ptr, "ns37:queryAcctByName");
	case SOAP_TYPE_ns37__queryAcctByNameResponse:
		return soap_out_ns37__queryAcctByNameResponse(soap, tag, id, (const struct ns37__queryAcctByNameResponse *)ptr, "ns37:queryAcctByNameResponse");
	case SOAP_TYPE_ns37__deleteAcctUser:
		return soap_out_ns37__deleteAcctUser(soap, tag, id, (const struct ns37__deleteAcctUser *)ptr, "ns37:deleteAcctUser");
	case SOAP_TYPE_ns37__deleteAcctUserResponse:
		return soap_out_ns37__deleteAcctUserResponse(soap, tag, id, (const struct ns37__deleteAcctUserResponse *)ptr, "ns37:deleteAcctUserResponse");
	case SOAP_TYPE_ns37__modifyAcctUser:
		return soap_out_ns37__modifyAcctUser(soap, tag, id, (const struct ns37__modifyAcctUser *)ptr, "ns37:modifyAcctUser");
	case SOAP_TYPE_ns37__modifyAcctUserResponse:
		return soap_out_ns37__modifyAcctUserResponse(soap, tag, id, (const struct ns37__modifyAcctUserResponse *)ptr, "ns37:modifyAcctUserResponse");
	case SOAP_TYPE_ns37__addAcctUser:
		return soap_out_ns37__addAcctUser(soap, tag, id, (const struct ns37__addAcctUser *)ptr, "ns37:addAcctUser");
	case SOAP_TYPE_ns37__addAcctUserResponse:
		return soap_out_ns37__addAcctUserResponse(soap, tag, id, (const struct ns37__addAcctUserResponse *)ptr, "ns37:addAcctUserResponse");
	case SOAP_TYPE_ns37__multiQuery:
		return soap_out_ns37__multiQuery(soap, tag, id, (const struct ns37__multiQuery *)ptr, "ns37:multiQuery");
	case SOAP_TYPE_ns37__multiQueryResponse:
		return soap_out_ns37__multiQueryResponse(soap, tag, id, (const struct ns37__multiQueryResponse *)ptr, "ns37:multiQueryResponse");
	case SOAP_TYPE_ns37__singleQuery:
		return soap_out_ns37__singleQuery(soap, tag, id, (const struct ns37__singleQuery *)ptr, "ns37:singleQuery");
	case SOAP_TYPE_ns37__singleQueryResponse:
		return soap_out_ns37__singleQueryResponse(soap, tag, id, (const struct ns37__singleQueryResponse *)ptr, "ns37:singleQueryResponse");
	case SOAP_TYPE_ns37__logout:
		return soap_out_ns37__logout(soap, tag, id, (const struct ns37__logout *)ptr, "ns37:logout");
	case SOAP_TYPE_ns37__logoutResponse:
		return soap_out_ns37__logoutResponse(soap, tag, id, (const struct ns37__logoutResponse *)ptr, "ns37:logoutResponse");
	case SOAP_TYPE_ns37__login:
		return soap_out_ns37__login(soap, tag, id, (const struct ns37__login *)ptr, "ns37:login");
	case SOAP_TYPE_ns37__loginResponse:
		return soap_out_ns37__loginResponse(soap, tag, id, (const struct ns37__loginResponse *)ptr, "ns37:loginResponse");
	case SOAP_TYPE_ns37__randomReq:
		return soap_out_ns37__randomReq(soap, tag, id, (const struct ns37__randomReq *)ptr, "ns37:randomReq");
	case SOAP_TYPE_ns37__randomReqResponse:
		return soap_out_ns37__randomReqResponse(soap, tag, id, (const struct ns37__randomReqResponse *)ptr, "ns37:randomReqResponse");
	case SOAP_TYPE_ns37__pay:
		return soap_out_ns37__pay(soap, tag, id, (const struct ns37__pay *)ptr, "ns37:pay");
	case SOAP_TYPE_ns37__payResponse:
		return soap_out_ns37__payResponse(soap, tag, id, (const struct ns37__payResponse *)ptr, "ns37:payResponse");
	case SOAP_TYPE_PointerTons36__BindParam:
		return soap_out_PointerTons36__BindParam(soap, tag, id, (ns36__BindParam *const*)ptr, "ns36:BindParam");
	case SOAP_TYPE_PointerTons35__AccountListQueryInfo:
		return soap_out_PointerTons35__AccountListQueryInfo(soap, tag, id, (ns35__AccountListQueryInfo *const*)ptr, "ns35:AccountListQueryInfo");
	case SOAP_TYPE_PointerTons10__RetAccountList:
		return soap_out_PointerTons10__RetAccountList(soap, tag, id, (ns10__RetAccountList *const*)ptr, "ns10:RetAccountList");
	case SOAP_TYPE_PointerTons34__LanAccessDetailQueryInfo:
		return soap_out_PointerTons34__LanAccessDetailQueryInfo(soap, tag, id, (ns34__LanAccessDetailQueryInfo *const*)ptr, "ns34:LanAccessDetailQueryInfo");
	case SOAP_TYPE_PointerTons5__LanAccessDetailList:
		return soap_out_PointerTons5__LanAccessDetailList(soap, tag, id, (ns5__LanAccessDetailList *const*)ptr, "ns5:LanAccessDetailList");
	case SOAP_TYPE_PointerTons33__LanQryCondition:
		return soap_out_PointerTons33__LanQryCondition(soap, tag, id, (ns33__LanQryCondition *const*)ptr, "ns33:LanQryCondition");
	case SOAP_TYPE_PointerTons19__LanServiceList:
		return soap_out_PointerTons19__LanServiceList(soap, tag, id, (ns19__LanServiceList *const*)ptr, "ns19:LanServiceList");
	case SOAP_TYPE_PointerTons21__UserBalance:
		return soap_out_PointerTons21__UserBalance(soap, tag, id, (ns21__UserBalance *const*)ptr, "ns21:UserBalance");
	case SOAP_TYPE_PointerTons32__BlackListQueryInfo:
		return soap_out_PointerTons32__BlackListQueryInfo(soap, tag, id, (ns32__BlackListQueryInfo *const*)ptr, "ns32:BlackListQueryInfo");
	case SOAP_TYPE_PointerTons17__BlackList:
		return soap_out_PointerTons17__BlackList(soap, tag, id, (ns17__BlackList *const*)ptr, "ns17:BlackList");
	case SOAP_TYPE_PointerTons15__RetUserAppendInfo:
		return soap_out_PointerTons15__RetUserAppendInfo(soap, tag, id, (ns15__RetUserAppendInfo *const*)ptr, "ns15:RetUserAppendInfo");
	case SOAP_TYPE_PointerTons13__RetAcctServiceInfo:
		return soap_out_PointerTons13__RetAcctServiceInfo(soap, tag, id, (ns13__RetAcctServiceInfo *const*)ptr, "ns13:RetAcctServiceInfo");
	case SOAP_TYPE_PointerTons31__DelUserServiceParam:
		return soap_out_PointerTons31__DelUserServiceParam(soap, tag, id, (ns31__DelUserServiceParam *const*)ptr, "ns31:DelUserServiceParam");
	case SOAP_TYPE_PointerTons30__ApplyServiceParam:
		return soap_out_PointerTons30__ApplyServiceParam(soap, tag, id, (ns30__ApplyServiceParam *const*)ptr, "ns30:ApplyServiceParam");
	case SOAP_TYPE_PointerTons29__ChgAcctPassParam:
		return soap_out_PointerTons29__ChgAcctPassParam(soap, tag, id, (ns29__ChgAcctPassParam *const*)ptr, "ns29:ChgAcctPassParam");
	case SOAP_TYPE_PointerTons11__RetPassword:
		return soap_out_PointerTons11__RetPassword(soap, tag, id, (ns11__RetPassword *const*)ptr, "ns11:RetPassword");
	case SOAP_TYPE_PointerTons8__RetUserInfo:
		return soap_out_PointerTons8__RetUserInfo(soap, tag, id, (ns8__RetUserInfo *const*)ptr, "ns8:RetUserInfo");
	case SOAP_TYPE_PointerTons28__DelAcctParam:
		return soap_out_PointerTons28__DelAcctParam(soap, tag, id, (ns28__DelAcctParam *const*)ptr, "ns28:DelAcctParam");
	case SOAP_TYPE_PointerTons3__RetDelUserInfo:
		return soap_out_PointerTons3__RetDelUserInfo(soap, tag, id, (ns3__RetDelUserInfo *const*)ptr, "ns3:RetDelUserInfo");
	case SOAP_TYPE_PointerTons27__ModifyAcctParam:
		return soap_out_PointerTons27__ModifyAcctParam(soap, tag, id, (ns27__ModifyAcctParam *const*)ptr, "ns27:ModifyAcctParam");
	case SOAP_TYPE_PointerTons26__AddAcctParam:
		return soap_out_PointerTons26__AddAcctParam(soap, tag, id, (ns26__AddAcctParam *const*)ptr, "ns26:AddAcctParam");
	case SOAP_TYPE_PointerTons7__MultiResult:
		return soap_out_PointerTons7__MultiResult(soap, tag, id, (ns7__MultiResult *const*)ptr, "ns7:MultiResult");
	case SOAP_TYPE_PointerTons24__QueryActionInfo:
		return soap_out_PointerTons24__QueryActionInfo(soap, tag, id, (ns24__QueryActionInfo *const*)ptr, "ns24:QueryActionInfo");
	case SOAP_TYPE_PointerTons20__SingleResult:
		return soap_out_PointerTons20__SingleResult(soap, tag, id, (ns20__SingleResult *const*)ptr, "ns20:SingleResult");
	case SOAP_TYPE_PointerTons23__OperatorInfo:
		return soap_out_PointerTons23__OperatorInfo(soap, tag, id, (ns23__OperatorInfo *const*)ptr, "ns23:OperatorInfo");
	case SOAP_TYPE_PointerTons6__RandomInfo:
		return soap_out_PointerTons6__RandomInfo(soap, tag, id, (ns6__RandomInfo *const*)ptr, "ns6:RandomInfo");
	case SOAP_TYPE_PointerTons2__PayParam:
		return soap_out_PointerTons2__PayParam(soap, tag, id, (ns2__PayParam *const*)ptr, "ns2:PayParam");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo:
		return soap_out_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(soap, tag, id, (ArrayOf_USCOREtns19_USCORELanServiceInfo *const*)ptr, "ns18:LanServiceInfo");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo:
		return soap_out_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(soap, tag, id, (ArrayOf_USCOREtns17_USCOREBlackListInfo *const*)ptr, "ns16:BlackListInfo");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo:
		return soap_out_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, tag, id, (ArrayOf_USCOREtns15_USCOREUserAppendInfo *const*)ptr, "ns14:UserAppendInfo");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo:
		return soap_out_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, tag, id, (ArrayOf_USCOREtns13_USCOREAcctServiceInfo *const*)ptr, "ns12:AcctServiceInfo");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo:
		return soap_out_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, tag, id, (ArrayOf_USCOREtns10_USCOREAcctBasicInfo *const*)ptr, "ns9:AcctBasicInfo");
	case SOAP_TYPE_PointerToArrayOfArrayOf_USCORExsd_USCOREstring:
		return soap_out_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(soap, tag, id, (ArrayOfArrayOf_USCORExsd_USCOREstring *const*)ptr, "xsd:string[]");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo:
		return soap_out_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, tag, id, (ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *const*)ptr, "ns4:LanAccessDetailInfo");
	case SOAP_TYPE_PointerToPointerTons25__ApplyServiceInfo:
		return soap_out_PointerToPointerTons25__ApplyServiceInfo(soap, tag, id, (ns25__ApplyServiceInfo **const*)ptr, "ns25:ApplyServiceInfo");
	case SOAP_TYPE_PointerTons25__ApplyServiceInfo:
		return soap_out_PointerTons25__ApplyServiceInfo(soap, tag, id, (ns25__ApplyServiceInfo *const*)ptr, "ns25:ApplyServiceInfo");
	case SOAP_TYPE_PointerToPointerTons18__LanServiceInfo:
		return soap_out_PointerToPointerTons18__LanServiceInfo(soap, tag, id, (ns18__LanServiceInfo **const*)ptr, "ns18:LanServiceInfo");
	case SOAP_TYPE_PointerTons18__LanServiceInfo:
		return soap_out_PointerTons18__LanServiceInfo(soap, tag, id, (ns18__LanServiceInfo *const*)ptr, "ns18:LanServiceInfo");
	case SOAP_TYPE_PointerToPointerTons16__BlackListInfo:
		return soap_out_PointerToPointerTons16__BlackListInfo(soap, tag, id, (ns16__BlackListInfo **const*)ptr, "ns16:BlackListInfo");
	case SOAP_TYPE_PointerTons16__BlackListInfo:
		return soap_out_PointerTons16__BlackListInfo(soap, tag, id, (ns16__BlackListInfo *const*)ptr, "ns16:BlackListInfo");
	case SOAP_TYPE_PointerToPointerTons14__UserAppendInfo:
		return soap_out_PointerToPointerTons14__UserAppendInfo(soap, tag, id, (ns14__UserAppendInfo **const*)ptr, "ns14:UserAppendInfo");
	case SOAP_TYPE_PointerTons14__UserAppendInfo:
		return soap_out_PointerTons14__UserAppendInfo(soap, tag, id, (ns14__UserAppendInfo *const*)ptr, "ns14:UserAppendInfo");
	case SOAP_TYPE_PointerToPointerTons12__AcctServiceInfo:
		return soap_out_PointerToPointerTons12__AcctServiceInfo(soap, tag, id, (ns12__AcctServiceInfo **const*)ptr, "ns12:AcctServiceInfo");
	case SOAP_TYPE_PointerTons12__AcctServiceInfo:
		return soap_out_PointerTons12__AcctServiceInfo(soap, tag, id, (ns12__AcctServiceInfo *const*)ptr, "ns12:AcctServiceInfo");
	case SOAP_TYPE_PointerToPointerTons9__AcctBasicInfo:
		return soap_out_PointerToPointerTons9__AcctBasicInfo(soap, tag, id, (ns9__AcctBasicInfo **const*)ptr, "ns9:AcctBasicInfo");
	case SOAP_TYPE_PointerTons9__AcctBasicInfo:
		return soap_out_PointerTons9__AcctBasicInfo(soap, tag, id, (ns9__AcctBasicInfo *const*)ptr, "ns9:AcctBasicInfo");
	case SOAP_TYPE_PointerTo_Struct_1:
		return soap_out_PointerTo_Struct_1(soap, tag, id, (_Struct_1 *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons4__LanAccessDetailInfo:
		return soap_out_PointerToPointerTons4__LanAccessDetailInfo(soap, tag, id, (ns4__LanAccessDetailInfo **const*)ptr, "ns4:LanAccessDetailInfo");
	case SOAP_TYPE_PointerTons4__LanAccessDetailInfo:
		return soap_out_PointerTons4__LanAccessDetailInfo(soap, tag, id, (ns4__LanAccessDetailInfo *const*)ptr, "ns4:LanAccessDetailInfo");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo:
		return soap_out_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, tag, id, (ArrayOf_USCOREtns25_USCOREApplyServiceInfo *const*)ptr, "ns25:ApplyServiceInfo");
	case SOAP_TYPE_PointerTons22__ResultBase:
		return soap_out_PointerTons22__ResultBase(soap, tag, id, (ns22__ResultBase *const*)ptr, "ns22:ResultBase");
	case SOAP_TYPE_PointerToArrayOf_USCORExsd_USCOREstring:
		return soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, tag, id, (ArrayOf_USCORExsd_USCOREstring *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE__SOAP_ENC__arrayType:
		return soap_out_string(soap, "SOAP-ENC:arrayType", id, (char**)&ptr, NULL);
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__Struct_1:
		((_Struct_1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns36__BindParam:
		((ns36__BindParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns35__AccountListQueryInfo:
		((ns35__AccountListQueryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns34__LanAccessDetailQueryInfo:
		((ns34__LanAccessDetailQueryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns33__LanQryCondition:
		((ns33__LanQryCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns32__BlackListQueryInfo:
		((ns32__BlackListQueryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns31__DelUserServiceParam:
		((ns31__DelUserServiceParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns30__ApplyServiceParam:
		((ns30__ApplyServiceParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns29__ChgAcctPassParam:
		((ns29__ChgAcctPassParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns28__DelAcctParam:
		((ns28__DelAcctParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns27__ModifyAcctParam:
		((ns27__ModifyAcctParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns26__AddAcctParam:
		((ns26__AddAcctParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns25__ApplyServiceInfo:
		((ns25__ApplyServiceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns24__QueryActionInfo:
		((ns24__QueryActionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns23__OperatorInfo:
		((ns23__OperatorInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns22__ResultBase:
		((ns22__ResultBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns21__UserBalance:
		((ns21__UserBalance *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns20__SingleResult:
		((ns20__SingleResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns19__LanServiceList:
		((ns19__LanServiceList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns18__LanServiceInfo:
		((ns18__LanServiceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns17__BlackList:
		((ns17__BlackList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns16__BlackListInfo:
		((ns16__BlackListInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns15__RetUserAppendInfo:
		((ns15__RetUserAppendInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns14__UserAppendInfo:
		((ns14__UserAppendInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns13__RetAcctServiceInfo:
		((ns13__RetAcctServiceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns12__AcctServiceInfo:
		((ns12__AcctServiceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns11__RetPassword:
		((ns11__RetPassword *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns10__RetAccountList:
		((ns10__RetAccountList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns9__AcctBasicInfo:
		((ns9__AcctBasicInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns8__RetUserInfo:
		((ns8__RetUserInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns7__MultiResult:
		((ns7__MultiResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__RandomInfo:
		((ns6__RandomInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__LanAccessDetailList:
		((ns5__LanAccessDetailList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo:
		((ArrayOf_USCOREtns25_USCOREApplyServiceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo:
		((ArrayOf_USCOREtns19_USCORELanServiceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo:
		((ArrayOf_USCOREtns17_USCOREBlackListInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo:
		((ArrayOf_USCOREtns15_USCOREUserAppendInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo:
		((ArrayOf_USCOREtns13_USCOREAcctServiceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo:
		((ArrayOf_USCOREtns10_USCOREAcctBasicInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring:
		((ArrayOfArrayOf_USCORExsd_USCOREstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
		((ArrayOf_USCORExsd_USCOREstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo:
		((ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__LanAccessDetailInfo:
		((ns4__LanAccessDetailInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__RetDelUserInfo:
		((ns3__RetDelUserInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PayParam:
		((ns2__PayParam *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns37__bindAccount:
		soap_serialize_ns37__bindAccount(soap, (const struct ns37__bindAccount *)ptr);
		break;
	case SOAP_TYPE_ns37__bindAccountResponse:
		soap_serialize_ns37__bindAccountResponse(soap, (const struct ns37__bindAccountResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__queryAcctList:
		soap_serialize_ns37__queryAcctList(soap, (const struct ns37__queryAcctList *)ptr);
		break;
	case SOAP_TYPE_ns37__queryAcctListResponse:
		soap_serialize_ns37__queryAcctListResponse(soap, (const struct ns37__queryAcctListResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__queryLanAccessDetail:
		soap_serialize_ns37__queryLanAccessDetail(soap, (const struct ns37__queryLanAccessDetail *)ptr);
		break;
	case SOAP_TYPE_ns37__queryLanAccessDetailResponse:
		soap_serialize_ns37__queryLanAccessDetailResponse(soap, (const struct ns37__queryLanAccessDetailResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__queryLanService:
		soap_serialize_ns37__queryLanService(soap, (const struct ns37__queryLanService *)ptr);
		break;
	case SOAP_TYPE_ns37__queryLanServiceResponse:
		soap_serialize_ns37__queryLanServiceResponse(soap, (const struct ns37__queryLanServiceResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__queryUserBalance:
		soap_serialize_ns37__queryUserBalance(soap, (const struct ns37__queryUserBalance *)ptr);
		break;
	case SOAP_TYPE_ns37__queryUserBalanceResponse:
		soap_serialize_ns37__queryUserBalanceResponse(soap, (const struct ns37__queryUserBalanceResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__queryBlackList:
		soap_serialize_ns37__queryBlackList(soap, (const struct ns37__queryBlackList *)ptr);
		break;
	case SOAP_TYPE_ns37__queryBlackListResponse:
		soap_serialize_ns37__queryBlackListResponse(soap, (const struct ns37__queryBlackListResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__deleteBlackList:
		soap_serialize_ns37__deleteBlackList(soap, (const struct ns37__deleteBlackList *)ptr);
		break;
	case SOAP_TYPE_ns37__deleteBlackListResponse:
		soap_serialize_ns37__deleteBlackListResponse(soap, (const struct ns37__deleteBlackListResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__addBlackList:
		soap_serialize_ns37__addBlackList(soap, (const struct ns37__addBlackList *)ptr);
		break;
	case SOAP_TYPE_ns37__addBlackListResponse:
		soap_serialize_ns37__addBlackListResponse(soap, (const struct ns37__addBlackListResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__queryAppendDefInfo:
		soap_serialize_ns37__queryAppendDefInfo(soap, (const struct ns37__queryAppendDefInfo *)ptr);
		break;
	case SOAP_TYPE_ns37__queryAppendDefInfoResponse:
		soap_serialize_ns37__queryAppendDefInfoResponse(soap, (const struct ns37__queryAppendDefInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__queryAcctServiceInfo:
		soap_serialize_ns37__queryAcctServiceInfo(soap, (const struct ns37__queryAcctServiceInfo *)ptr);
		break;
	case SOAP_TYPE_ns37__queryAcctServiceInfoResponse:
		soap_serialize_ns37__queryAcctServiceInfoResponse(soap, (const struct ns37__queryAcctServiceInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__cancelService:
		soap_serialize_ns37__cancelService(soap, (const struct ns37__cancelService *)ptr);
		break;
	case SOAP_TYPE_ns37__cancelServiceResponse:
		soap_serialize_ns37__cancelServiceResponse(soap, (const struct ns37__cancelServiceResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__applyService:
		soap_serialize_ns37__applyService(soap, (const struct ns37__applyService *)ptr);
		break;
	case SOAP_TYPE_ns37__applyServiceResponse:
		soap_serialize_ns37__applyServiceResponse(soap, (const struct ns37__applyServiceResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__changeAcctPassword:
		soap_serialize_ns37__changeAcctPassword(soap, (const struct ns37__changeAcctPassword *)ptr);
		break;
	case SOAP_TYPE_ns37__changeAcctPasswordResponse:
		soap_serialize_ns37__changeAcctPasswordResponse(soap, (const struct ns37__changeAcctPasswordResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__queryAcctPassword:
		soap_serialize_ns37__queryAcctPassword(soap, (const struct ns37__queryAcctPassword *)ptr);
		break;
	case SOAP_TYPE_ns37__queryAcctPasswordResponse:
		soap_serialize_ns37__queryAcctPasswordResponse(soap, (const struct ns37__queryAcctPasswordResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__queryAcctByName:
		soap_serialize_ns37__queryAcctByName(soap, (const struct ns37__queryAcctByName *)ptr);
		break;
	case SOAP_TYPE_ns37__queryAcctByNameResponse:
		soap_serialize_ns37__queryAcctByNameResponse(soap, (const struct ns37__queryAcctByNameResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__deleteAcctUser:
		soap_serialize_ns37__deleteAcctUser(soap, (const struct ns37__deleteAcctUser *)ptr);
		break;
	case SOAP_TYPE_ns37__deleteAcctUserResponse:
		soap_serialize_ns37__deleteAcctUserResponse(soap, (const struct ns37__deleteAcctUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__modifyAcctUser:
		soap_serialize_ns37__modifyAcctUser(soap, (const struct ns37__modifyAcctUser *)ptr);
		break;
	case SOAP_TYPE_ns37__modifyAcctUserResponse:
		soap_serialize_ns37__modifyAcctUserResponse(soap, (const struct ns37__modifyAcctUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__addAcctUser:
		soap_serialize_ns37__addAcctUser(soap, (const struct ns37__addAcctUser *)ptr);
		break;
	case SOAP_TYPE_ns37__addAcctUserResponse:
		soap_serialize_ns37__addAcctUserResponse(soap, (const struct ns37__addAcctUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__multiQuery:
		soap_serialize_ns37__multiQuery(soap, (const struct ns37__multiQuery *)ptr);
		break;
	case SOAP_TYPE_ns37__multiQueryResponse:
		soap_serialize_ns37__multiQueryResponse(soap, (const struct ns37__multiQueryResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__singleQuery:
		soap_serialize_ns37__singleQuery(soap, (const struct ns37__singleQuery *)ptr);
		break;
	case SOAP_TYPE_ns37__singleQueryResponse:
		soap_serialize_ns37__singleQueryResponse(soap, (const struct ns37__singleQueryResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__logout:
		soap_serialize_ns37__logout(soap, (const struct ns37__logout *)ptr);
		break;
	case SOAP_TYPE_ns37__logoutResponse:
		soap_serialize_ns37__logoutResponse(soap, (const struct ns37__logoutResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__login:
		soap_serialize_ns37__login(soap, (const struct ns37__login *)ptr);
		break;
	case SOAP_TYPE_ns37__loginResponse:
		soap_serialize_ns37__loginResponse(soap, (const struct ns37__loginResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__randomReq:
		soap_serialize_ns37__randomReq(soap, (const struct ns37__randomReq *)ptr);
		break;
	case SOAP_TYPE_ns37__randomReqResponse:
		soap_serialize_ns37__randomReqResponse(soap, (const struct ns37__randomReqResponse *)ptr);
		break;
	case SOAP_TYPE_ns37__pay:
		soap_serialize_ns37__pay(soap, (const struct ns37__pay *)ptr);
		break;
	case SOAP_TYPE_ns37__payResponse:
		soap_serialize_ns37__payResponse(soap, (const struct ns37__payResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTons36__BindParam:
		soap_serialize_PointerTons36__BindParam(soap, (ns36__BindParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons35__AccountListQueryInfo:
		soap_serialize_PointerTons35__AccountListQueryInfo(soap, (ns35__AccountListQueryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons10__RetAccountList:
		soap_serialize_PointerTons10__RetAccountList(soap, (ns10__RetAccountList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons34__LanAccessDetailQueryInfo:
		soap_serialize_PointerTons34__LanAccessDetailQueryInfo(soap, (ns34__LanAccessDetailQueryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__LanAccessDetailList:
		soap_serialize_PointerTons5__LanAccessDetailList(soap, (ns5__LanAccessDetailList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons33__LanQryCondition:
		soap_serialize_PointerTons33__LanQryCondition(soap, (ns33__LanQryCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons19__LanServiceList:
		soap_serialize_PointerTons19__LanServiceList(soap, (ns19__LanServiceList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons21__UserBalance:
		soap_serialize_PointerTons21__UserBalance(soap, (ns21__UserBalance *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons32__BlackListQueryInfo:
		soap_serialize_PointerTons32__BlackListQueryInfo(soap, (ns32__BlackListQueryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons17__BlackList:
		soap_serialize_PointerTons17__BlackList(soap, (ns17__BlackList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons15__RetUserAppendInfo:
		soap_serialize_PointerTons15__RetUserAppendInfo(soap, (ns15__RetUserAppendInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons13__RetAcctServiceInfo:
		soap_serialize_PointerTons13__RetAcctServiceInfo(soap, (ns13__RetAcctServiceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons31__DelUserServiceParam:
		soap_serialize_PointerTons31__DelUserServiceParam(soap, (ns31__DelUserServiceParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons30__ApplyServiceParam:
		soap_serialize_PointerTons30__ApplyServiceParam(soap, (ns30__ApplyServiceParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons29__ChgAcctPassParam:
		soap_serialize_PointerTons29__ChgAcctPassParam(soap, (ns29__ChgAcctPassParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons11__RetPassword:
		soap_serialize_PointerTons11__RetPassword(soap, (ns11__RetPassword *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons8__RetUserInfo:
		soap_serialize_PointerTons8__RetUserInfo(soap, (ns8__RetUserInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons28__DelAcctParam:
		soap_serialize_PointerTons28__DelAcctParam(soap, (ns28__DelAcctParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__RetDelUserInfo:
		soap_serialize_PointerTons3__RetDelUserInfo(soap, (ns3__RetDelUserInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons27__ModifyAcctParam:
		soap_serialize_PointerTons27__ModifyAcctParam(soap, (ns27__ModifyAcctParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons26__AddAcctParam:
		soap_serialize_PointerTons26__AddAcctParam(soap, (ns26__AddAcctParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons7__MultiResult:
		soap_serialize_PointerTons7__MultiResult(soap, (ns7__MultiResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons24__QueryActionInfo:
		soap_serialize_PointerTons24__QueryActionInfo(soap, (ns24__QueryActionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons20__SingleResult:
		soap_serialize_PointerTons20__SingleResult(soap, (ns20__SingleResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons23__OperatorInfo:
		soap_serialize_PointerTons23__OperatorInfo(soap, (ns23__OperatorInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__RandomInfo:
		soap_serialize_PointerTons6__RandomInfo(soap, (ns6__RandomInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PayParam:
		soap_serialize_PointerTons2__PayParam(soap, (ns2__PayParam *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo:
		soap_serialize_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(soap, (ArrayOf_USCOREtns19_USCORELanServiceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo:
		soap_serialize_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(soap, (ArrayOf_USCOREtns17_USCOREBlackListInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo:
		soap_serialize_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, (ArrayOf_USCOREtns15_USCOREUserAppendInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo:
		soap_serialize_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, (ArrayOf_USCOREtns13_USCOREAcctServiceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo:
		soap_serialize_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, (ArrayOf_USCOREtns10_USCOREAcctBasicInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfArrayOf_USCORExsd_USCOREstring:
		soap_serialize_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(soap, (ArrayOfArrayOf_USCORExsd_USCOREstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo:
		soap_serialize_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, (ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons25__ApplyServiceInfo:
		soap_serialize_PointerToPointerTons25__ApplyServiceInfo(soap, (ns25__ApplyServiceInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons25__ApplyServiceInfo:
		soap_serialize_PointerTons25__ApplyServiceInfo(soap, (ns25__ApplyServiceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons18__LanServiceInfo:
		soap_serialize_PointerToPointerTons18__LanServiceInfo(soap, (ns18__LanServiceInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons18__LanServiceInfo:
		soap_serialize_PointerTons18__LanServiceInfo(soap, (ns18__LanServiceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons16__BlackListInfo:
		soap_serialize_PointerToPointerTons16__BlackListInfo(soap, (ns16__BlackListInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons16__BlackListInfo:
		soap_serialize_PointerTons16__BlackListInfo(soap, (ns16__BlackListInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons14__UserAppendInfo:
		soap_serialize_PointerToPointerTons14__UserAppendInfo(soap, (ns14__UserAppendInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons14__UserAppendInfo:
		soap_serialize_PointerTons14__UserAppendInfo(soap, (ns14__UserAppendInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons12__AcctServiceInfo:
		soap_serialize_PointerToPointerTons12__AcctServiceInfo(soap, (ns12__AcctServiceInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons12__AcctServiceInfo:
		soap_serialize_PointerTons12__AcctServiceInfo(soap, (ns12__AcctServiceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons9__AcctBasicInfo:
		soap_serialize_PointerToPointerTons9__AcctBasicInfo(soap, (ns9__AcctBasicInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons9__AcctBasicInfo:
		soap_serialize_PointerTons9__AcctBasicInfo(soap, (ns9__AcctBasicInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_Struct_1:
		soap_serialize_PointerTo_Struct_1(soap, (_Struct_1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__LanAccessDetailInfo:
		soap_serialize_PointerToPointerTons4__LanAccessDetailInfo(soap, (ns4__LanAccessDetailInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__LanAccessDetailInfo:
		soap_serialize_PointerTons4__LanAccessDetailInfo(soap, (ns4__LanAccessDetailInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo:
		soap_serialize_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, (ArrayOf_USCOREtns25_USCOREApplyServiceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons22__ResultBase:
		soap_serialize_PointerTons22__ResultBase(soap, (ns22__ResultBase *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCORExsd_USCOREstring:
		soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, (ArrayOf_USCORExsd_USCOREstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE__SOAP_ENC__arrayType:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_ns2__PayParam:
		return (void*)soap_instantiate_ns2__PayParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__LanAccessDetailInfo:
		return (void*)soap_instantiate_ns4__LanAccessDetailInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns9__AcctBasicInfo:
		return (void*)soap_instantiate_ns9__AcctBasicInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns12__AcctServiceInfo:
		return (void*)soap_instantiate_ns12__AcctServiceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns14__UserAppendInfo:
		return (void*)soap_instantiate_ns14__UserAppendInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns16__BlackListInfo:
		return (void*)soap_instantiate_ns16__BlackListInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns18__LanServiceInfo:
		return (void*)soap_instantiate_ns18__LanServiceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns22__ResultBase:
		return (void*)soap_instantiate_ns22__ResultBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns23__OperatorInfo:
		return (void*)soap_instantiate_ns23__OperatorInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns24__QueryActionInfo:
		return (void*)soap_instantiate_ns24__QueryActionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns25__ApplyServiceInfo:
		return (void*)soap_instantiate_ns25__ApplyServiceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns26__AddAcctParam:
		return (void*)soap_instantiate_ns26__AddAcctParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns27__ModifyAcctParam:
		return (void*)soap_instantiate_ns27__ModifyAcctParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns28__DelAcctParam:
		return (void*)soap_instantiate_ns28__DelAcctParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns29__ChgAcctPassParam:
		return (void*)soap_instantiate_ns29__ChgAcctPassParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns30__ApplyServiceParam:
		return (void*)soap_instantiate_ns30__ApplyServiceParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns31__DelUserServiceParam:
		return (void*)soap_instantiate_ns31__DelUserServiceParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns32__BlackListQueryInfo:
		return (void*)soap_instantiate_ns32__BlackListQueryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns33__LanQryCondition:
		return (void*)soap_instantiate_ns33__LanQryCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns34__LanAccessDetailQueryInfo:
		return (void*)soap_instantiate_ns34__LanAccessDetailQueryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns35__AccountListQueryInfo:
		return (void*)soap_instantiate_ns35__AccountListQueryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns36__BindParam:
		return (void*)soap_instantiate_ns36__BindParam(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__RetDelUserInfo:
		return (void*)soap_instantiate_ns3__RetDelUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo:
		return (void*)soap_instantiate_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
		return (void*)soap_instantiate_ArrayOf_USCORExsd_USCOREstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE__Struct_1:
		return (void*)soap_instantiate__Struct_1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring:
		return (void*)soap_instantiate_ArrayOfArrayOf_USCORExsd_USCOREstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo:
		return (void*)soap_instantiate_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo:
		return (void*)soap_instantiate_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo:
		return (void*)soap_instantiate_ArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo:
		return (void*)soap_instantiate_ArrayOf_USCOREtns17_USCOREBlackListInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo:
		return (void*)soap_instantiate_ArrayOf_USCOREtns19_USCORELanServiceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo:
		return (void*)soap_instantiate_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__LanAccessDetailList:
		return (void*)soap_instantiate_ns5__LanAccessDetailList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__RandomInfo:
		return (void*)soap_instantiate_ns6__RandomInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns7__MultiResult:
		return (void*)soap_instantiate_ns7__MultiResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns8__RetUserInfo:
		return (void*)soap_instantiate_ns8__RetUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns10__RetAccountList:
		return (void*)soap_instantiate_ns10__RetAccountList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns11__RetPassword:
		return (void*)soap_instantiate_ns11__RetPassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns13__RetAcctServiceInfo:
		return (void*)soap_instantiate_ns13__RetAcctServiceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns15__RetUserAppendInfo:
		return (void*)soap_instantiate_ns15__RetUserAppendInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns17__BlackList:
		return (void*)soap_instantiate_ns17__BlackList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns19__LanServiceList:
		return (void*)soap_instantiate_ns19__LanServiceList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns20__SingleResult:
		return (void*)soap_instantiate_ns20__SingleResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns21__UserBalance:
		return (void*)soap_instantiate_ns21__UserBalance(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__payResponse:
		return (void*)soap_instantiate_ns37__payResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__pay:
		return (void*)soap_instantiate_ns37__pay(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__randomReqResponse:
		return (void*)soap_instantiate_ns37__randomReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__randomReq:
		return (void*)soap_instantiate_ns37__randomReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__loginResponse:
		return (void*)soap_instantiate_ns37__loginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__login:
		return (void*)soap_instantiate_ns37__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__logoutResponse:
		return (void*)soap_instantiate_ns37__logoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__logout:
		return (void*)soap_instantiate_ns37__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__singleQueryResponse:
		return (void*)soap_instantiate_ns37__singleQueryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__singleQuery:
		return (void*)soap_instantiate_ns37__singleQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__multiQueryResponse:
		return (void*)soap_instantiate_ns37__multiQueryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__multiQuery:
		return (void*)soap_instantiate_ns37__multiQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__addAcctUserResponse:
		return (void*)soap_instantiate_ns37__addAcctUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__addAcctUser:
		return (void*)soap_instantiate_ns37__addAcctUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__modifyAcctUserResponse:
		return (void*)soap_instantiate_ns37__modifyAcctUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__modifyAcctUser:
		return (void*)soap_instantiate_ns37__modifyAcctUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__deleteAcctUserResponse:
		return (void*)soap_instantiate_ns37__deleteAcctUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__deleteAcctUser:
		return (void*)soap_instantiate_ns37__deleteAcctUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryAcctByNameResponse:
		return (void*)soap_instantiate_ns37__queryAcctByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryAcctByName:
		return (void*)soap_instantiate_ns37__queryAcctByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryAcctPasswordResponse:
		return (void*)soap_instantiate_ns37__queryAcctPasswordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryAcctPassword:
		return (void*)soap_instantiate_ns37__queryAcctPassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__changeAcctPasswordResponse:
		return (void*)soap_instantiate_ns37__changeAcctPasswordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__changeAcctPassword:
		return (void*)soap_instantiate_ns37__changeAcctPassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__applyServiceResponse:
		return (void*)soap_instantiate_ns37__applyServiceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__applyService:
		return (void*)soap_instantiate_ns37__applyService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__cancelServiceResponse:
		return (void*)soap_instantiate_ns37__cancelServiceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__cancelService:
		return (void*)soap_instantiate_ns37__cancelService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryAcctServiceInfoResponse:
		return (void*)soap_instantiate_ns37__queryAcctServiceInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryAcctServiceInfo:
		return (void*)soap_instantiate_ns37__queryAcctServiceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryAppendDefInfoResponse:
		return (void*)soap_instantiate_ns37__queryAppendDefInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryAppendDefInfo:
		return (void*)soap_instantiate_ns37__queryAppendDefInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__addBlackListResponse:
		return (void*)soap_instantiate_ns37__addBlackListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__addBlackList:
		return (void*)soap_instantiate_ns37__addBlackList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__deleteBlackListResponse:
		return (void*)soap_instantiate_ns37__deleteBlackListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__deleteBlackList:
		return (void*)soap_instantiate_ns37__deleteBlackList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryBlackListResponse:
		return (void*)soap_instantiate_ns37__queryBlackListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryBlackList:
		return (void*)soap_instantiate_ns37__queryBlackList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryUserBalanceResponse:
		return (void*)soap_instantiate_ns37__queryUserBalanceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryUserBalance:
		return (void*)soap_instantiate_ns37__queryUserBalance(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryLanServiceResponse:
		return (void*)soap_instantiate_ns37__queryLanServiceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryLanService:
		return (void*)soap_instantiate_ns37__queryLanService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryLanAccessDetailResponse:
		return (void*)soap_instantiate_ns37__queryLanAccessDetailResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryLanAccessDetail:
		return (void*)soap_instantiate_ns37__queryLanAccessDetail(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryAcctListResponse:
		return (void*)soap_instantiate_ns37__queryAcctListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__queryAcctList:
		return (void*)soap_instantiate_ns37__queryAcctList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__bindAccountResponse:
		return (void*)soap_instantiate_ns37__bindAccountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns37__bindAccount:
		return (void*)soap_instantiate_ns37__bindAccount(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns2__PayParam:
		if (p->size < 0)
			delete (ns2__PayParam*)p->ptr;
		else
			delete[] (ns2__PayParam*)p->ptr;
		break;
	case SOAP_TYPE_ns4__LanAccessDetailInfo:
		if (p->size < 0)
			delete (ns4__LanAccessDetailInfo*)p->ptr;
		else
			delete[] (ns4__LanAccessDetailInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns9__AcctBasicInfo:
		if (p->size < 0)
			delete (ns9__AcctBasicInfo*)p->ptr;
		else
			delete[] (ns9__AcctBasicInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns12__AcctServiceInfo:
		if (p->size < 0)
			delete (ns12__AcctServiceInfo*)p->ptr;
		else
			delete[] (ns12__AcctServiceInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns14__UserAppendInfo:
		if (p->size < 0)
			delete (ns14__UserAppendInfo*)p->ptr;
		else
			delete[] (ns14__UserAppendInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns16__BlackListInfo:
		if (p->size < 0)
			delete (ns16__BlackListInfo*)p->ptr;
		else
			delete[] (ns16__BlackListInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns18__LanServiceInfo:
		if (p->size < 0)
			delete (ns18__LanServiceInfo*)p->ptr;
		else
			delete[] (ns18__LanServiceInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns22__ResultBase:
		if (p->size < 0)
			delete (ns22__ResultBase*)p->ptr;
		else
			delete[] (ns22__ResultBase*)p->ptr;
		break;
	case SOAP_TYPE_ns23__OperatorInfo:
		if (p->size < 0)
			delete (ns23__OperatorInfo*)p->ptr;
		else
			delete[] (ns23__OperatorInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns24__QueryActionInfo:
		if (p->size < 0)
			delete (ns24__QueryActionInfo*)p->ptr;
		else
			delete[] (ns24__QueryActionInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns25__ApplyServiceInfo:
		if (p->size < 0)
			delete (ns25__ApplyServiceInfo*)p->ptr;
		else
			delete[] (ns25__ApplyServiceInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns26__AddAcctParam:
		if (p->size < 0)
			delete (ns26__AddAcctParam*)p->ptr;
		else
			delete[] (ns26__AddAcctParam*)p->ptr;
		break;
	case SOAP_TYPE_ns27__ModifyAcctParam:
		if (p->size < 0)
			delete (ns27__ModifyAcctParam*)p->ptr;
		else
			delete[] (ns27__ModifyAcctParam*)p->ptr;
		break;
	case SOAP_TYPE_ns28__DelAcctParam:
		if (p->size < 0)
			delete (ns28__DelAcctParam*)p->ptr;
		else
			delete[] (ns28__DelAcctParam*)p->ptr;
		break;
	case SOAP_TYPE_ns29__ChgAcctPassParam:
		if (p->size < 0)
			delete (ns29__ChgAcctPassParam*)p->ptr;
		else
			delete[] (ns29__ChgAcctPassParam*)p->ptr;
		break;
	case SOAP_TYPE_ns30__ApplyServiceParam:
		if (p->size < 0)
			delete (ns30__ApplyServiceParam*)p->ptr;
		else
			delete[] (ns30__ApplyServiceParam*)p->ptr;
		break;
	case SOAP_TYPE_ns31__DelUserServiceParam:
		if (p->size < 0)
			delete (ns31__DelUserServiceParam*)p->ptr;
		else
			delete[] (ns31__DelUserServiceParam*)p->ptr;
		break;
	case SOAP_TYPE_ns32__BlackListQueryInfo:
		if (p->size < 0)
			delete (ns32__BlackListQueryInfo*)p->ptr;
		else
			delete[] (ns32__BlackListQueryInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns33__LanQryCondition:
		if (p->size < 0)
			delete (ns33__LanQryCondition*)p->ptr;
		else
			delete[] (ns33__LanQryCondition*)p->ptr;
		break;
	case SOAP_TYPE_ns34__LanAccessDetailQueryInfo:
		if (p->size < 0)
			delete (ns34__LanAccessDetailQueryInfo*)p->ptr;
		else
			delete[] (ns34__LanAccessDetailQueryInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns35__AccountListQueryInfo:
		if (p->size < 0)
			delete (ns35__AccountListQueryInfo*)p->ptr;
		else
			delete[] (ns35__AccountListQueryInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns36__BindParam:
		if (p->size < 0)
			delete (ns36__BindParam*)p->ptr;
		else
			delete[] (ns36__BindParam*)p->ptr;
		break;
	case SOAP_TYPE_ns3__RetDelUserInfo:
		if (p->size < 0)
			delete (ns3__RetDelUserInfo*)p->ptr;
		else
			delete[] (ns3__RetDelUserInfo*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns5_USCORELanAccessDetailInfo*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns5_USCORELanAccessDetailInfo*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
		if (p->size < 0)
			delete (ArrayOf_USCORExsd_USCOREstring*)p->ptr;
		else
			delete[] (ArrayOf_USCORExsd_USCOREstring*)p->ptr;
		break;
	case SOAP_TYPE__Struct_1:
		if (p->size < 0)
			delete (_Struct_1*)p->ptr;
		else
			delete[] (_Struct_1*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring:
		if (p->size < 0)
			delete (ArrayOfArrayOf_USCORExsd_USCOREstring*)p->ptr;
		else
			delete[] (ArrayOfArrayOf_USCORExsd_USCOREstring*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns10_USCOREAcctBasicInfo*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns10_USCOREAcctBasicInfo*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns13_USCOREAcctServiceInfo*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns13_USCOREAcctServiceInfo*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns15_USCOREUserAppendInfo*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns15_USCOREUserAppendInfo*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns17_USCOREBlackListInfo*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns17_USCOREBlackListInfo*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns19_USCORELanServiceInfo*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns19_USCORELanServiceInfo*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns25_USCOREApplyServiceInfo*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns25_USCOREApplyServiceInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns5__LanAccessDetailList:
		if (p->size < 0)
			delete (ns5__LanAccessDetailList*)p->ptr;
		else
			delete[] (ns5__LanAccessDetailList*)p->ptr;
		break;
	case SOAP_TYPE_ns6__RandomInfo:
		if (p->size < 0)
			delete (ns6__RandomInfo*)p->ptr;
		else
			delete[] (ns6__RandomInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns7__MultiResult:
		if (p->size < 0)
			delete (ns7__MultiResult*)p->ptr;
		else
			delete[] (ns7__MultiResult*)p->ptr;
		break;
	case SOAP_TYPE_ns8__RetUserInfo:
		if (p->size < 0)
			delete (ns8__RetUserInfo*)p->ptr;
		else
			delete[] (ns8__RetUserInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns10__RetAccountList:
		if (p->size < 0)
			delete (ns10__RetAccountList*)p->ptr;
		else
			delete[] (ns10__RetAccountList*)p->ptr;
		break;
	case SOAP_TYPE_ns11__RetPassword:
		if (p->size < 0)
			delete (ns11__RetPassword*)p->ptr;
		else
			delete[] (ns11__RetPassword*)p->ptr;
		break;
	case SOAP_TYPE_ns13__RetAcctServiceInfo:
		if (p->size < 0)
			delete (ns13__RetAcctServiceInfo*)p->ptr;
		else
			delete[] (ns13__RetAcctServiceInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns15__RetUserAppendInfo:
		if (p->size < 0)
			delete (ns15__RetUserAppendInfo*)p->ptr;
		else
			delete[] (ns15__RetUserAppendInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns17__BlackList:
		if (p->size < 0)
			delete (ns17__BlackList*)p->ptr;
		else
			delete[] (ns17__BlackList*)p->ptr;
		break;
	case SOAP_TYPE_ns19__LanServiceList:
		if (p->size < 0)
			delete (ns19__LanServiceList*)p->ptr;
		else
			delete[] (ns19__LanServiceList*)p->ptr;
		break;
	case SOAP_TYPE_ns20__SingleResult:
		if (p->size < 0)
			delete (ns20__SingleResult*)p->ptr;
		else
			delete[] (ns20__SingleResult*)p->ptr;
		break;
	case SOAP_TYPE_ns21__UserBalance:
		if (p->size < 0)
			delete (ns21__UserBalance*)p->ptr;
		else
			delete[] (ns21__UserBalance*)p->ptr;
		break;
	case SOAP_TYPE_ns37__payResponse:
		if (p->size < 0)
			delete (struct ns37__payResponse*)p->ptr;
		else
			delete[] (struct ns37__payResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__pay:
		if (p->size < 0)
			delete (struct ns37__pay*)p->ptr;
		else
			delete[] (struct ns37__pay*)p->ptr;
		break;
	case SOAP_TYPE_ns37__randomReqResponse:
		if (p->size < 0)
			delete (struct ns37__randomReqResponse*)p->ptr;
		else
			delete[] (struct ns37__randomReqResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__randomReq:
		if (p->size < 0)
			delete (struct ns37__randomReq*)p->ptr;
		else
			delete[] (struct ns37__randomReq*)p->ptr;
		break;
	case SOAP_TYPE_ns37__loginResponse:
		if (p->size < 0)
			delete (struct ns37__loginResponse*)p->ptr;
		else
			delete[] (struct ns37__loginResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__login:
		if (p->size < 0)
			delete (struct ns37__login*)p->ptr;
		else
			delete[] (struct ns37__login*)p->ptr;
		break;
	case SOAP_TYPE_ns37__logoutResponse:
		if (p->size < 0)
			delete (struct ns37__logoutResponse*)p->ptr;
		else
			delete[] (struct ns37__logoutResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__logout:
		if (p->size < 0)
			delete (struct ns37__logout*)p->ptr;
		else
			delete[] (struct ns37__logout*)p->ptr;
		break;
	case SOAP_TYPE_ns37__singleQueryResponse:
		if (p->size < 0)
			delete (struct ns37__singleQueryResponse*)p->ptr;
		else
			delete[] (struct ns37__singleQueryResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__singleQuery:
		if (p->size < 0)
			delete (struct ns37__singleQuery*)p->ptr;
		else
			delete[] (struct ns37__singleQuery*)p->ptr;
		break;
	case SOAP_TYPE_ns37__multiQueryResponse:
		if (p->size < 0)
			delete (struct ns37__multiQueryResponse*)p->ptr;
		else
			delete[] (struct ns37__multiQueryResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__multiQuery:
		if (p->size < 0)
			delete (struct ns37__multiQuery*)p->ptr;
		else
			delete[] (struct ns37__multiQuery*)p->ptr;
		break;
	case SOAP_TYPE_ns37__addAcctUserResponse:
		if (p->size < 0)
			delete (struct ns37__addAcctUserResponse*)p->ptr;
		else
			delete[] (struct ns37__addAcctUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__addAcctUser:
		if (p->size < 0)
			delete (struct ns37__addAcctUser*)p->ptr;
		else
			delete[] (struct ns37__addAcctUser*)p->ptr;
		break;
	case SOAP_TYPE_ns37__modifyAcctUserResponse:
		if (p->size < 0)
			delete (struct ns37__modifyAcctUserResponse*)p->ptr;
		else
			delete[] (struct ns37__modifyAcctUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__modifyAcctUser:
		if (p->size < 0)
			delete (struct ns37__modifyAcctUser*)p->ptr;
		else
			delete[] (struct ns37__modifyAcctUser*)p->ptr;
		break;
	case SOAP_TYPE_ns37__deleteAcctUserResponse:
		if (p->size < 0)
			delete (struct ns37__deleteAcctUserResponse*)p->ptr;
		else
			delete[] (struct ns37__deleteAcctUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__deleteAcctUser:
		if (p->size < 0)
			delete (struct ns37__deleteAcctUser*)p->ptr;
		else
			delete[] (struct ns37__deleteAcctUser*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryAcctByNameResponse:
		if (p->size < 0)
			delete (struct ns37__queryAcctByNameResponse*)p->ptr;
		else
			delete[] (struct ns37__queryAcctByNameResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryAcctByName:
		if (p->size < 0)
			delete (struct ns37__queryAcctByName*)p->ptr;
		else
			delete[] (struct ns37__queryAcctByName*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryAcctPasswordResponse:
		if (p->size < 0)
			delete (struct ns37__queryAcctPasswordResponse*)p->ptr;
		else
			delete[] (struct ns37__queryAcctPasswordResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryAcctPassword:
		if (p->size < 0)
			delete (struct ns37__queryAcctPassword*)p->ptr;
		else
			delete[] (struct ns37__queryAcctPassword*)p->ptr;
		break;
	case SOAP_TYPE_ns37__changeAcctPasswordResponse:
		if (p->size < 0)
			delete (struct ns37__changeAcctPasswordResponse*)p->ptr;
		else
			delete[] (struct ns37__changeAcctPasswordResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__changeAcctPassword:
		if (p->size < 0)
			delete (struct ns37__changeAcctPassword*)p->ptr;
		else
			delete[] (struct ns37__changeAcctPassword*)p->ptr;
		break;
	case SOAP_TYPE_ns37__applyServiceResponse:
		if (p->size < 0)
			delete (struct ns37__applyServiceResponse*)p->ptr;
		else
			delete[] (struct ns37__applyServiceResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__applyService:
		if (p->size < 0)
			delete (struct ns37__applyService*)p->ptr;
		else
			delete[] (struct ns37__applyService*)p->ptr;
		break;
	case SOAP_TYPE_ns37__cancelServiceResponse:
		if (p->size < 0)
			delete (struct ns37__cancelServiceResponse*)p->ptr;
		else
			delete[] (struct ns37__cancelServiceResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__cancelService:
		if (p->size < 0)
			delete (struct ns37__cancelService*)p->ptr;
		else
			delete[] (struct ns37__cancelService*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryAcctServiceInfoResponse:
		if (p->size < 0)
			delete (struct ns37__queryAcctServiceInfoResponse*)p->ptr;
		else
			delete[] (struct ns37__queryAcctServiceInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryAcctServiceInfo:
		if (p->size < 0)
			delete (struct ns37__queryAcctServiceInfo*)p->ptr;
		else
			delete[] (struct ns37__queryAcctServiceInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryAppendDefInfoResponse:
		if (p->size < 0)
			delete (struct ns37__queryAppendDefInfoResponse*)p->ptr;
		else
			delete[] (struct ns37__queryAppendDefInfoResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryAppendDefInfo:
		if (p->size < 0)
			delete (struct ns37__queryAppendDefInfo*)p->ptr;
		else
			delete[] (struct ns37__queryAppendDefInfo*)p->ptr;
		break;
	case SOAP_TYPE_ns37__addBlackListResponse:
		if (p->size < 0)
			delete (struct ns37__addBlackListResponse*)p->ptr;
		else
			delete[] (struct ns37__addBlackListResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__addBlackList:
		if (p->size < 0)
			delete (struct ns37__addBlackList*)p->ptr;
		else
			delete[] (struct ns37__addBlackList*)p->ptr;
		break;
	case SOAP_TYPE_ns37__deleteBlackListResponse:
		if (p->size < 0)
			delete (struct ns37__deleteBlackListResponse*)p->ptr;
		else
			delete[] (struct ns37__deleteBlackListResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__deleteBlackList:
		if (p->size < 0)
			delete (struct ns37__deleteBlackList*)p->ptr;
		else
			delete[] (struct ns37__deleteBlackList*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryBlackListResponse:
		if (p->size < 0)
			delete (struct ns37__queryBlackListResponse*)p->ptr;
		else
			delete[] (struct ns37__queryBlackListResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryBlackList:
		if (p->size < 0)
			delete (struct ns37__queryBlackList*)p->ptr;
		else
			delete[] (struct ns37__queryBlackList*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryUserBalanceResponse:
		if (p->size < 0)
			delete (struct ns37__queryUserBalanceResponse*)p->ptr;
		else
			delete[] (struct ns37__queryUserBalanceResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryUserBalance:
		if (p->size < 0)
			delete (struct ns37__queryUserBalance*)p->ptr;
		else
			delete[] (struct ns37__queryUserBalance*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryLanServiceResponse:
		if (p->size < 0)
			delete (struct ns37__queryLanServiceResponse*)p->ptr;
		else
			delete[] (struct ns37__queryLanServiceResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryLanService:
		if (p->size < 0)
			delete (struct ns37__queryLanService*)p->ptr;
		else
			delete[] (struct ns37__queryLanService*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryLanAccessDetailResponse:
		if (p->size < 0)
			delete (struct ns37__queryLanAccessDetailResponse*)p->ptr;
		else
			delete[] (struct ns37__queryLanAccessDetailResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryLanAccessDetail:
		if (p->size < 0)
			delete (struct ns37__queryLanAccessDetail*)p->ptr;
		else
			delete[] (struct ns37__queryLanAccessDetail*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryAcctListResponse:
		if (p->size < 0)
			delete (struct ns37__queryAcctListResponse*)p->ptr;
		else
			delete[] (struct ns37__queryAcctListResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__queryAcctList:
		if (p->size < 0)
			delete (struct ns37__queryAcctList*)p->ptr;
		else
			delete[] (struct ns37__queryAcctList*)p->ptr;
		break;
	case SOAP_TYPE_ns37__bindAccountResponse:
		if (p->size < 0)
			delete (struct ns37__bindAccountResponse*)p->ptr;
		else
			delete[] (struct ns37__bindAccountResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns37__bindAccount:
		if (p->size < 0)
			delete (struct ns37__bindAccount*)p->ptr;
		else
			delete[] (struct ns37__bindAccount*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	const char *s = soap_code_str(soap_codes_bool, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
	soap_send(soap, soap_bool2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	return soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
}

void _Struct_1::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE__Struct_1))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_string(soap, this->__ptr + i);
		}
}

void _Struct_1::soap_default(struct soap *soap)
{
	this->__size = 0;
	this->__ptr = NULL;
}

int _Struct_1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE__Struct_1);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _Struct_1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out__Struct_1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Struct_1(struct soap *soap, const char *tag, int id, const _Struct_1 *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE__Struct_1);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_Struct_1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Struct_1(soap, this, tag, type);
}

SOAP_FMAC3 _Struct_1 * SOAP_FMAC4 soap_get__Struct_1(struct soap *soap, _Struct_1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__Struct_1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_Struct_1::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Struct_1(soap, tag, this, type);
}

SOAP_FMAC3 _Struct_1 * SOAP_FMAC4 soap_in__Struct_1(struct soap *soap, const char *tag, _Struct_1 *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (_Struct_1 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__Struct_1, sizeof(_Struct_1), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Struct_1 *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE__Struct_1, 0, sizeof(_Struct_1), 0, soap_copy__Struct_1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _Struct_1 * SOAP_FMAC6 soap_new__Struct_1(struct soap *soap, int n)
{	return soap_instantiate__Struct_1(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__Struct_1(struct soap *soap, _Struct_1 *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _Struct_1 * SOAP_FMAC4 soap_instantiate__Struct_1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Struct_1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__Struct_1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _Struct_1;
		if (size)
			*size = sizeof(_Struct_1);
	}
	else
	{	cp->ptr = (void*)new _Struct_1[n];
		if (size)
			*size = n * sizeof(_Struct_1);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Struct_1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Struct_1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Struct_1 %p -> %p\n", q, p));
	*(_Struct_1*)p = *(_Struct_1*)q;
}

void ns36__BindParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns36__BindParam*)this)->accountList);
	soap_serialize_string(soap, &((ns36__BindParam*)this)->ldapServerName);
	/* transient soap skipped */
}

void ns36__BindParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns36__BindParam*)this)->accountList = NULL;
	soap_default_string(soap, &((ns36__BindParam*)this)->ldapServerName);
	/* transient soap skipped */
}

int ns36__BindParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns36__BindParam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns36__BindParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns36__BindParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns36__BindParam(struct soap *soap, const char *tag, int id, const ns36__BindParam *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns36__BindParam), type);
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "accountList", -1, &(((ns36__BindParam*)a)->accountList), "");
	soap_out_string(soap, "ldapServerName", -1, &(((ns36__BindParam*)a)->ldapServerName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns36__BindParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns36__BindParam(soap, this, tag, type);
}

SOAP_FMAC3 ns36__BindParam * SOAP_FMAC4 soap_get_ns36__BindParam(struct soap *soap, ns36__BindParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns36__BindParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns36__BindParam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns36__BindParam(soap, tag, this, type);
}

SOAP_FMAC3 ns36__BindParam * SOAP_FMAC4 soap_in_ns36__BindParam(struct soap *soap, const char *tag, ns36__BindParam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns36__BindParam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns36__BindParam, sizeof(ns36__BindParam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns36__BindParam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns36__BindParam *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_accountList1 = 1, soap_flag_ldapServerName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "accountList", &(((ns36__BindParam*)a)->accountList), "xsd:string"))
				{	soap_flag_accountList1--;
					continue;
				}
			if (soap_flag_ldapServerName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ldapServerName", &(((ns36__BindParam*)a)->ldapServerName), "xsd:string"))
				{	soap_flag_ldapServerName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns36__BindParam *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns36__BindParam, 0, sizeof(ns36__BindParam), 0, soap_copy_ns36__BindParam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns36__BindParam * SOAP_FMAC6 soap_new_ns36__BindParam(struct soap *soap, int n)
{	return soap_instantiate_ns36__BindParam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns36__BindParam(struct soap *soap, ns36__BindParam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns36__BindParam * SOAP_FMAC4 soap_instantiate_ns36__BindParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns36__BindParam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns36__BindParam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns36__BindParam;
		if (size)
			*size = sizeof(ns36__BindParam);
		((ns36__BindParam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns36__BindParam[n];
		if (size)
			*size = n * sizeof(ns36__BindParam);
		for (int i = 0; i < n; i++)
			((ns36__BindParam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns36__BindParam*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns36__BindParam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns36__BindParam %p -> %p\n", q, p));
	*(ns36__BindParam*)p = *(ns36__BindParam*)q;
}

void ns35__AccountListQueryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns35__AccountListQueryInfo*)this)->feeType, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns35__AccountListQueryInfo*)this)->fullName);
	soap_embedded(soap, &((ns35__AccountListQueryInfo*)this)->maxItems, SOAP_TYPE_int);
	soap_embedded(soap, &((ns35__AccountListQueryInfo*)this)->orderType, SOAP_TYPE_int);
	soap_embedded(soap, &((ns35__AccountListQueryInfo*)this)->serTmpId, SOAP_TYPE_LONG64);
	soap_embedded(soap, &((ns35__AccountListQueryInfo*)this)->sortType, SOAP_TYPE_int);
	soap_embedded(soap, &((ns35__AccountListQueryInfo*)this)->startPos, SOAP_TYPE_int);
	soap_embedded(soap, &((ns35__AccountListQueryInfo*)this)->state, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns35__AccountListQueryInfo*)this)->userName);
	/* transient soap skipped */
}

void ns35__AccountListQueryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ns35__AccountListQueryInfo*)this)->feeType);
	soap_default_string(soap, &((ns35__AccountListQueryInfo*)this)->fullName);
	soap_default_int(soap, &((ns35__AccountListQueryInfo*)this)->maxItems);
	soap_default_int(soap, &((ns35__AccountListQueryInfo*)this)->orderType);
	soap_default_LONG64(soap, &((ns35__AccountListQueryInfo*)this)->serTmpId);
	soap_default_int(soap, &((ns35__AccountListQueryInfo*)this)->sortType);
	soap_default_int(soap, &((ns35__AccountListQueryInfo*)this)->startPos);
	soap_default_int(soap, &((ns35__AccountListQueryInfo*)this)->state);
	soap_default_string(soap, &((ns35__AccountListQueryInfo*)this)->userName);
	/* transient soap skipped */
}

int ns35__AccountListQueryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns35__AccountListQueryInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns35__AccountListQueryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns35__AccountListQueryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns35__AccountListQueryInfo(struct soap *soap, const char *tag, int id, const ns35__AccountListQueryInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns35__AccountListQueryInfo), type);
	soap_out_int(soap, "feeType", -1, &(((ns35__AccountListQueryInfo*)a)->feeType), "");
	soap_out_string(soap, "fullName", -1, &(((ns35__AccountListQueryInfo*)a)->fullName), "");
	soap_out_int(soap, "maxItems", -1, &(((ns35__AccountListQueryInfo*)a)->maxItems), "");
	soap_out_int(soap, "orderType", -1, &(((ns35__AccountListQueryInfo*)a)->orderType), "");
	soap_out_LONG64(soap, "serTmpId", -1, &(((ns35__AccountListQueryInfo*)a)->serTmpId), "");
	soap_out_int(soap, "sortType", -1, &(((ns35__AccountListQueryInfo*)a)->sortType), "");
	soap_out_int(soap, "startPos", -1, &(((ns35__AccountListQueryInfo*)a)->startPos), "");
	soap_out_int(soap, "state", -1, &(((ns35__AccountListQueryInfo*)a)->state), "");
	soap_out_string(soap, "userName", -1, &(((ns35__AccountListQueryInfo*)a)->userName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns35__AccountListQueryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns35__AccountListQueryInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns35__AccountListQueryInfo * SOAP_FMAC4 soap_get_ns35__AccountListQueryInfo(struct soap *soap, ns35__AccountListQueryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns35__AccountListQueryInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns35__AccountListQueryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns35__AccountListQueryInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns35__AccountListQueryInfo * SOAP_FMAC4 soap_in_ns35__AccountListQueryInfo(struct soap *soap, const char *tag, ns35__AccountListQueryInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns35__AccountListQueryInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns35__AccountListQueryInfo, sizeof(ns35__AccountListQueryInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns35__AccountListQueryInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns35__AccountListQueryInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_feeType1 = 1, soap_flag_fullName1 = 1, soap_flag_maxItems1 = 1, soap_flag_orderType1 = 1, soap_flag_serTmpId1 = 1, soap_flag_sortType1 = 1, soap_flag_startPos1 = 1, soap_flag_state1 = 1, soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_feeType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "feeType", &(((ns35__AccountListQueryInfo*)a)->feeType), "xsd:int"))
				{	soap_flag_feeType1--;
					continue;
				}
			if (soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fullName", &(((ns35__AccountListQueryInfo*)a)->fullName), "xsd:string"))
				{	soap_flag_fullName1--;
					continue;
				}
			if (soap_flag_maxItems1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxItems", &(((ns35__AccountListQueryInfo*)a)->maxItems), "xsd:int"))
				{	soap_flag_maxItems1--;
					continue;
				}
			if (soap_flag_orderType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "orderType", &(((ns35__AccountListQueryInfo*)a)->orderType), "xsd:int"))
				{	soap_flag_orderType1--;
					continue;
				}
			if (soap_flag_serTmpId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "serTmpId", &(((ns35__AccountListQueryInfo*)a)->serTmpId), "xsd:long"))
				{	soap_flag_serTmpId1--;
					continue;
				}
			if (soap_flag_sortType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sortType", &(((ns35__AccountListQueryInfo*)a)->sortType), "xsd:int"))
				{	soap_flag_sortType1--;
					continue;
				}
			if (soap_flag_startPos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startPos", &(((ns35__AccountListQueryInfo*)a)->startPos), "xsd:int"))
				{	soap_flag_startPos1--;
					continue;
				}
			if (soap_flag_state1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "state", &(((ns35__AccountListQueryInfo*)a)->state), "xsd:int"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns35__AccountListQueryInfo*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_feeType1 > 0 || soap_flag_maxItems1 > 0 || soap_flag_orderType1 > 0 || soap_flag_serTmpId1 > 0 || soap_flag_sortType1 > 0 || soap_flag_startPos1 > 0 || soap_flag_state1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns35__AccountListQueryInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns35__AccountListQueryInfo, 0, sizeof(ns35__AccountListQueryInfo), 0, soap_copy_ns35__AccountListQueryInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns35__AccountListQueryInfo * SOAP_FMAC6 soap_new_ns35__AccountListQueryInfo(struct soap *soap, int n)
{	return soap_instantiate_ns35__AccountListQueryInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns35__AccountListQueryInfo(struct soap *soap, ns35__AccountListQueryInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns35__AccountListQueryInfo * SOAP_FMAC4 soap_instantiate_ns35__AccountListQueryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns35__AccountListQueryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns35__AccountListQueryInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns35__AccountListQueryInfo;
		if (size)
			*size = sizeof(ns35__AccountListQueryInfo);
		((ns35__AccountListQueryInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns35__AccountListQueryInfo[n];
		if (size)
			*size = n * sizeof(ns35__AccountListQueryInfo);
		for (int i = 0; i < n; i++)
			((ns35__AccountListQueryInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns35__AccountListQueryInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns35__AccountListQueryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns35__AccountListQueryInfo %p -> %p\n", q, p));
	*(ns35__AccountListQueryInfo*)p = *(ns35__AccountListQueryInfo*)q;
}

void ns34__LanAccessDetailQueryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &((ns34__LanAccessDetailQueryInfo*)this)->endTime);
	soap_serialize_string(soap, &((ns34__LanAccessDetailQueryInfo*)this)->macAddr);
	soap_embedded(soap, &((ns34__LanAccessDetailQueryInfo*)this)->maxItems, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns34__LanAccessDetailQueryInfo*)this)->nasIP);
	soap_embedded(soap, &((ns34__LanAccessDetailQueryInfo*)this)->offLinePattern, SOAP_TYPE_int);
	soap_embedded(soap, &((ns34__LanAccessDetailQueryInfo*)this)->orderType, SOAP_TYPE_int);
	soap_embedded(soap, &((ns34__LanAccessDetailQueryInfo*)this)->serTmpId, SOAP_TYPE_LONG64);
	soap_embedded(soap, &((ns34__LanAccessDetailQueryInfo*)this)->sortType, SOAP_TYPE_int);
	soap_embedded(soap, &((ns34__LanAccessDetailQueryInfo*)this)->startPos, SOAP_TYPE_int);
	soap_serialize_PointerTotime(soap, &((ns34__LanAccessDetailQueryInfo*)this)->startTime);
	soap_serialize_string(soap, &((ns34__LanAccessDetailQueryInfo*)this)->userIP);
	soap_serialize_string(soap, &((ns34__LanAccessDetailQueryInfo*)this)->userName);
	/* transient soap skipped */
}

void ns34__LanAccessDetailQueryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns34__LanAccessDetailQueryInfo*)this)->endTime = NULL;
	soap_default_bool(soap, &((ns34__LanAccessDetailQueryInfo*)this)->includeCanceled);
	soap_default_string(soap, &((ns34__LanAccessDetailQueryInfo*)this)->macAddr);
	soap_default_int(soap, &((ns34__LanAccessDetailQueryInfo*)this)->maxItems);
	soap_default_string(soap, &((ns34__LanAccessDetailQueryInfo*)this)->nasIP);
	soap_default_int(soap, &((ns34__LanAccessDetailQueryInfo*)this)->offLinePattern);
	soap_default_int(soap, &((ns34__LanAccessDetailQueryInfo*)this)->orderType);
	soap_default_LONG64(soap, &((ns34__LanAccessDetailQueryInfo*)this)->serTmpId);
	soap_default_int(soap, &((ns34__LanAccessDetailQueryInfo*)this)->sortType);
	soap_default_int(soap, &((ns34__LanAccessDetailQueryInfo*)this)->startPos);
	((ns34__LanAccessDetailQueryInfo*)this)->startTime = NULL;
	soap_default_string(soap, &((ns34__LanAccessDetailQueryInfo*)this)->userIP);
	soap_default_string(soap, &((ns34__LanAccessDetailQueryInfo*)this)->userName);
	/* transient soap skipped */
}

int ns34__LanAccessDetailQueryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns34__LanAccessDetailQueryInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns34__LanAccessDetailQueryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns34__LanAccessDetailQueryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns34__LanAccessDetailQueryInfo(struct soap *soap, const char *tag, int id, const ns34__LanAccessDetailQueryInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns34__LanAccessDetailQueryInfo), type);
	soap_out_PointerTotime(soap, "endTime", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->endTime), "");
	soap_out_bool(soap, "includeCanceled", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->includeCanceled), "");
	soap_out_string(soap, "macAddr", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->macAddr), "");
	soap_out_int(soap, "maxItems", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->maxItems), "");
	soap_out_string(soap, "nasIP", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->nasIP), "");
	soap_out_int(soap, "offLinePattern", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->offLinePattern), "");
	soap_out_int(soap, "orderType", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->orderType), "");
	soap_out_LONG64(soap, "serTmpId", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->serTmpId), "");
	soap_out_int(soap, "sortType", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->sortType), "");
	soap_out_int(soap, "startPos", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->startPos), "");
	soap_out_PointerTotime(soap, "startTime", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->startTime), "");
	soap_out_string(soap, "userIP", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->userIP), "");
	soap_out_string(soap, "userName", -1, &(((ns34__LanAccessDetailQueryInfo*)a)->userName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns34__LanAccessDetailQueryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns34__LanAccessDetailQueryInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns34__LanAccessDetailQueryInfo * SOAP_FMAC4 soap_get_ns34__LanAccessDetailQueryInfo(struct soap *soap, ns34__LanAccessDetailQueryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns34__LanAccessDetailQueryInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns34__LanAccessDetailQueryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns34__LanAccessDetailQueryInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns34__LanAccessDetailQueryInfo * SOAP_FMAC4 soap_in_ns34__LanAccessDetailQueryInfo(struct soap *soap, const char *tag, ns34__LanAccessDetailQueryInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns34__LanAccessDetailQueryInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns34__LanAccessDetailQueryInfo, sizeof(ns34__LanAccessDetailQueryInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns34__LanAccessDetailQueryInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns34__LanAccessDetailQueryInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_endTime1 = 1, soap_flag_includeCanceled1 = 1, soap_flag_macAddr1 = 1, soap_flag_maxItems1 = 1, soap_flag_nasIP1 = 1, soap_flag_offLinePattern1 = 1, soap_flag_orderType1 = 1, soap_flag_serTmpId1 = 1, soap_flag_sortType1 = 1, soap_flag_startPos1 = 1, soap_flag_startTime1 = 1, soap_flag_userIP1 = 1, soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_endTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &(((ns34__LanAccessDetailQueryInfo*)a)->endTime), "xsd:dateTime"))
				{	soap_flag_endTime1--;
					continue;
				}
			if (soap_flag_includeCanceled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "includeCanceled", &(((ns34__LanAccessDetailQueryInfo*)a)->includeCanceled), "xsd:boolean"))
				{	soap_flag_includeCanceled1--;
					continue;
				}
			if (soap_flag_macAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "macAddr", &(((ns34__LanAccessDetailQueryInfo*)a)->macAddr), "xsd:string"))
				{	soap_flag_macAddr1--;
					continue;
				}
			if (soap_flag_maxItems1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxItems", &(((ns34__LanAccessDetailQueryInfo*)a)->maxItems), "xsd:int"))
				{	soap_flag_maxItems1--;
					continue;
				}
			if (soap_flag_nasIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "nasIP", &(((ns34__LanAccessDetailQueryInfo*)a)->nasIP), "xsd:string"))
				{	soap_flag_nasIP1--;
					continue;
				}
			if (soap_flag_offLinePattern1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offLinePattern", &(((ns34__LanAccessDetailQueryInfo*)a)->offLinePattern), "xsd:int"))
				{	soap_flag_offLinePattern1--;
					continue;
				}
			if (soap_flag_orderType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "orderType", &(((ns34__LanAccessDetailQueryInfo*)a)->orderType), "xsd:int"))
				{	soap_flag_orderType1--;
					continue;
				}
			if (soap_flag_serTmpId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "serTmpId", &(((ns34__LanAccessDetailQueryInfo*)a)->serTmpId), "xsd:long"))
				{	soap_flag_serTmpId1--;
					continue;
				}
			if (soap_flag_sortType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sortType", &(((ns34__LanAccessDetailQueryInfo*)a)->sortType), "xsd:int"))
				{	soap_flag_sortType1--;
					continue;
				}
			if (soap_flag_startPos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startPos", &(((ns34__LanAccessDetailQueryInfo*)a)->startPos), "xsd:int"))
				{	soap_flag_startPos1--;
					continue;
				}
			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTime", &(((ns34__LanAccessDetailQueryInfo*)a)->startTime), "xsd:dateTime"))
				{	soap_flag_startTime1--;
					continue;
				}
			if (soap_flag_userIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIP", &(((ns34__LanAccessDetailQueryInfo*)a)->userIP), "xsd:string"))
				{	soap_flag_userIP1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns34__LanAccessDetailQueryInfo*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_includeCanceled1 > 0 || soap_flag_maxItems1 > 0 || soap_flag_offLinePattern1 > 0 || soap_flag_orderType1 > 0 || soap_flag_serTmpId1 > 0 || soap_flag_sortType1 > 0 || soap_flag_startPos1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns34__LanAccessDetailQueryInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns34__LanAccessDetailQueryInfo, 0, sizeof(ns34__LanAccessDetailQueryInfo), 0, soap_copy_ns34__LanAccessDetailQueryInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns34__LanAccessDetailQueryInfo * SOAP_FMAC6 soap_new_ns34__LanAccessDetailQueryInfo(struct soap *soap, int n)
{	return soap_instantiate_ns34__LanAccessDetailQueryInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns34__LanAccessDetailQueryInfo(struct soap *soap, ns34__LanAccessDetailQueryInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns34__LanAccessDetailQueryInfo * SOAP_FMAC4 soap_instantiate_ns34__LanAccessDetailQueryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns34__LanAccessDetailQueryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns34__LanAccessDetailQueryInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns34__LanAccessDetailQueryInfo;
		if (size)
			*size = sizeof(ns34__LanAccessDetailQueryInfo);
		((ns34__LanAccessDetailQueryInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns34__LanAccessDetailQueryInfo[n];
		if (size)
			*size = n * sizeof(ns34__LanAccessDetailQueryInfo);
		for (int i = 0; i < n; i++)
			((ns34__LanAccessDetailQueryInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns34__LanAccessDetailQueryInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns34__LanAccessDetailQueryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns34__LanAccessDetailQueryInfo %p -> %p\n", q, p));
	*(ns34__LanAccessDetailQueryInfo*)p = *(ns34__LanAccessDetailQueryInfo*)q;
}

void ns33__LanQryCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns33__LanQryCondition*)this)->acctStrategyID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &((ns33__LanQryCondition*)this)->safePolicyID, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &((ns33__LanQryCondition*)this)->serviceName);
	soap_serialize_string(soap, &((ns33__LanQryCondition*)this)->serviceSuffix);
	soap_embedded(soap, &((ns33__LanQryCondition*)this)->validType, SOAP_TYPE_int);
	/* transient soap skipped */
}

void ns33__LanQryCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &((ns33__LanQryCondition*)this)->acctStrategyID);
	soap_default_LONG64(soap, &((ns33__LanQryCondition*)this)->safePolicyID);
	soap_default_string(soap, &((ns33__LanQryCondition*)this)->serviceName);
	soap_default_string(soap, &((ns33__LanQryCondition*)this)->serviceSuffix);
	soap_default_int(soap, &((ns33__LanQryCondition*)this)->validType);
	/* transient soap skipped */
}

int ns33__LanQryCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns33__LanQryCondition);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns33__LanQryCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns33__LanQryCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns33__LanQryCondition(struct soap *soap, const char *tag, int id, const ns33__LanQryCondition *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns33__LanQryCondition), type);
	soap_out_LONG64(soap, "acctStrategyID", -1, &(((ns33__LanQryCondition*)a)->acctStrategyID), "");
	soap_out_LONG64(soap, "safePolicyID", -1, &(((ns33__LanQryCondition*)a)->safePolicyID), "");
	soap_out_string(soap, "serviceName", -1, &(((ns33__LanQryCondition*)a)->serviceName), "");
	soap_out_string(soap, "serviceSuffix", -1, &(((ns33__LanQryCondition*)a)->serviceSuffix), "");
	soap_out_int(soap, "validType", -1, &(((ns33__LanQryCondition*)a)->validType), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns33__LanQryCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns33__LanQryCondition(soap, this, tag, type);
}

SOAP_FMAC3 ns33__LanQryCondition * SOAP_FMAC4 soap_get_ns33__LanQryCondition(struct soap *soap, ns33__LanQryCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns33__LanQryCondition(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns33__LanQryCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns33__LanQryCondition(soap, tag, this, type);
}

SOAP_FMAC3 ns33__LanQryCondition * SOAP_FMAC4 soap_in_ns33__LanQryCondition(struct soap *soap, const char *tag, ns33__LanQryCondition *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns33__LanQryCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns33__LanQryCondition, sizeof(ns33__LanQryCondition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns33__LanQryCondition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns33__LanQryCondition *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_acctStrategyID1 = 1, soap_flag_safePolicyID1 = 1, soap_flag_serviceName1 = 1, soap_flag_serviceSuffix1 = 1, soap_flag_validType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_acctStrategyID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "acctStrategyID", &(((ns33__LanQryCondition*)a)->acctStrategyID), "xsd:long"))
				{	soap_flag_acctStrategyID1--;
					continue;
				}
			if (soap_flag_safePolicyID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "safePolicyID", &(((ns33__LanQryCondition*)a)->safePolicyID), "xsd:long"))
				{	soap_flag_safePolicyID1--;
					continue;
				}
			if (soap_flag_serviceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "serviceName", &(((ns33__LanQryCondition*)a)->serviceName), "xsd:string"))
				{	soap_flag_serviceName1--;
					continue;
				}
			if (soap_flag_serviceSuffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "serviceSuffix", &(((ns33__LanQryCondition*)a)->serviceSuffix), "xsd:string"))
				{	soap_flag_serviceSuffix1--;
					continue;
				}
			if (soap_flag_validType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "validType", &(((ns33__LanQryCondition*)a)->validType), "xsd:int"))
				{	soap_flag_validType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_acctStrategyID1 > 0 || soap_flag_safePolicyID1 > 0 || soap_flag_validType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns33__LanQryCondition *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns33__LanQryCondition, 0, sizeof(ns33__LanQryCondition), 0, soap_copy_ns33__LanQryCondition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns33__LanQryCondition * SOAP_FMAC6 soap_new_ns33__LanQryCondition(struct soap *soap, int n)
{	return soap_instantiate_ns33__LanQryCondition(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns33__LanQryCondition(struct soap *soap, ns33__LanQryCondition *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns33__LanQryCondition * SOAP_FMAC4 soap_instantiate_ns33__LanQryCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns33__LanQryCondition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns33__LanQryCondition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns33__LanQryCondition;
		if (size)
			*size = sizeof(ns33__LanQryCondition);
		((ns33__LanQryCondition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns33__LanQryCondition[n];
		if (size)
			*size = n * sizeof(ns33__LanQryCondition);
		for (int i = 0; i < n; i++)
			((ns33__LanQryCondition*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns33__LanQryCondition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns33__LanQryCondition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns33__LanQryCondition %p -> %p\n", q, p));
	*(ns33__LanQryCondition*)p = *(ns33__LanQryCondition*)q;
}

void ns32__BlackListQueryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &((ns32__BlackListQueryInfo*)this)->fromDate);
	soap_serialize_string(soap, &((ns32__BlackListQueryInfo*)this)->logonIP);
	soap_serialize_string(soap, &((ns32__BlackListQueryInfo*)this)->logonMac);
	soap_embedded(soap, &((ns32__BlackListQueryInfo*)this)->maxItems, SOAP_TYPE_int);
	soap_embedded(soap, &((ns32__BlackListQueryInfo*)this)->orderType, SOAP_TYPE_int);
	soap_embedded(soap, &((ns32__BlackListQueryInfo*)this)->reasonType, SOAP_TYPE_int);
	soap_embedded(soap, &((ns32__BlackListQueryInfo*)this)->sortType, SOAP_TYPE_int);
	soap_embedded(soap, &((ns32__BlackListQueryInfo*)this)->startPosition, SOAP_TYPE_int);
	soap_serialize_PointerTotime(soap, &((ns32__BlackListQueryInfo*)this)->toDate);
	soap_serialize_string(soap, &((ns32__BlackListQueryInfo*)this)->userName);
	/* transient soap skipped */
}

void ns32__BlackListQueryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns32__BlackListQueryInfo*)this)->fromDate = NULL;
	soap_default_string(soap, &((ns32__BlackListQueryInfo*)this)->logonIP);
	soap_default_string(soap, &((ns32__BlackListQueryInfo*)this)->logonMac);
	soap_default_int(soap, &((ns32__BlackListQueryInfo*)this)->maxItems);
	soap_default_int(soap, &((ns32__BlackListQueryInfo*)this)->orderType);
	soap_default_int(soap, &((ns32__BlackListQueryInfo*)this)->reasonType);
	soap_default_int(soap, &((ns32__BlackListQueryInfo*)this)->sortType);
	soap_default_int(soap, &((ns32__BlackListQueryInfo*)this)->startPosition);
	((ns32__BlackListQueryInfo*)this)->toDate = NULL;
	soap_default_string(soap, &((ns32__BlackListQueryInfo*)this)->userName);
	/* transient soap skipped */
}

int ns32__BlackListQueryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns32__BlackListQueryInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns32__BlackListQueryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns32__BlackListQueryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns32__BlackListQueryInfo(struct soap *soap, const char *tag, int id, const ns32__BlackListQueryInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns32__BlackListQueryInfo), type);
	soap_out_PointerTotime(soap, "fromDate", -1, &(((ns32__BlackListQueryInfo*)a)->fromDate), "");
	soap_out_string(soap, "logonIP", -1, &(((ns32__BlackListQueryInfo*)a)->logonIP), "");
	soap_out_string(soap, "logonMac", -1, &(((ns32__BlackListQueryInfo*)a)->logonMac), "");
	soap_out_int(soap, "maxItems", -1, &(((ns32__BlackListQueryInfo*)a)->maxItems), "");
	soap_out_int(soap, "orderType", -1, &(((ns32__BlackListQueryInfo*)a)->orderType), "");
	soap_out_int(soap, "reasonType", -1, &(((ns32__BlackListQueryInfo*)a)->reasonType), "");
	soap_out_int(soap, "sortType", -1, &(((ns32__BlackListQueryInfo*)a)->sortType), "");
	soap_out_int(soap, "startPosition", -1, &(((ns32__BlackListQueryInfo*)a)->startPosition), "");
	soap_out_PointerTotime(soap, "toDate", -1, &(((ns32__BlackListQueryInfo*)a)->toDate), "");
	soap_out_string(soap, "userName", -1, &(((ns32__BlackListQueryInfo*)a)->userName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns32__BlackListQueryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns32__BlackListQueryInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns32__BlackListQueryInfo * SOAP_FMAC4 soap_get_ns32__BlackListQueryInfo(struct soap *soap, ns32__BlackListQueryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns32__BlackListQueryInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns32__BlackListQueryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns32__BlackListQueryInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns32__BlackListQueryInfo * SOAP_FMAC4 soap_in_ns32__BlackListQueryInfo(struct soap *soap, const char *tag, ns32__BlackListQueryInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns32__BlackListQueryInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns32__BlackListQueryInfo, sizeof(ns32__BlackListQueryInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns32__BlackListQueryInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns32__BlackListQueryInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_fromDate1 = 1, soap_flag_logonIP1 = 1, soap_flag_logonMac1 = 1, soap_flag_maxItems1 = 1, soap_flag_orderType1 = 1, soap_flag_reasonType1 = 1, soap_flag_sortType1 = 1, soap_flag_startPosition1 = 1, soap_flag_toDate1 = 1, soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fromDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "fromDate", &(((ns32__BlackListQueryInfo*)a)->fromDate), "xsd:dateTime"))
				{	soap_flag_fromDate1--;
					continue;
				}
			if (soap_flag_logonIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "logonIP", &(((ns32__BlackListQueryInfo*)a)->logonIP), "xsd:string"))
				{	soap_flag_logonIP1--;
					continue;
				}
			if (soap_flag_logonMac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "logonMac", &(((ns32__BlackListQueryInfo*)a)->logonMac), "xsd:string"))
				{	soap_flag_logonMac1--;
					continue;
				}
			if (soap_flag_maxItems1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxItems", &(((ns32__BlackListQueryInfo*)a)->maxItems), "xsd:int"))
				{	soap_flag_maxItems1--;
					continue;
				}
			if (soap_flag_orderType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "orderType", &(((ns32__BlackListQueryInfo*)a)->orderType), "xsd:int"))
				{	soap_flag_orderType1--;
					continue;
				}
			if (soap_flag_reasonType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "reasonType", &(((ns32__BlackListQueryInfo*)a)->reasonType), "xsd:int"))
				{	soap_flag_reasonType1--;
					continue;
				}
			if (soap_flag_sortType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sortType", &(((ns32__BlackListQueryInfo*)a)->sortType), "xsd:int"))
				{	soap_flag_sortType1--;
					continue;
				}
			if (soap_flag_startPosition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startPosition", &(((ns32__BlackListQueryInfo*)a)->startPosition), "xsd:int"))
				{	soap_flag_startPosition1--;
					continue;
				}
			if (soap_flag_toDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "toDate", &(((ns32__BlackListQueryInfo*)a)->toDate), "xsd:dateTime"))
				{	soap_flag_toDate1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns32__BlackListQueryInfo*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_maxItems1 > 0 || soap_flag_orderType1 > 0 || soap_flag_reasonType1 > 0 || soap_flag_sortType1 > 0 || soap_flag_startPosition1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns32__BlackListQueryInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns32__BlackListQueryInfo, 0, sizeof(ns32__BlackListQueryInfo), 0, soap_copy_ns32__BlackListQueryInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns32__BlackListQueryInfo * SOAP_FMAC6 soap_new_ns32__BlackListQueryInfo(struct soap *soap, int n)
{	return soap_instantiate_ns32__BlackListQueryInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns32__BlackListQueryInfo(struct soap *soap, ns32__BlackListQueryInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns32__BlackListQueryInfo * SOAP_FMAC4 soap_instantiate_ns32__BlackListQueryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns32__BlackListQueryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns32__BlackListQueryInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns32__BlackListQueryInfo;
		if (size)
			*size = sizeof(ns32__BlackListQueryInfo);
		((ns32__BlackListQueryInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns32__BlackListQueryInfo[n];
		if (size)
			*size = n * sizeof(ns32__BlackListQueryInfo);
		for (int i = 0; i < n; i++)
			((ns32__BlackListQueryInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns32__BlackListQueryInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns32__BlackListQueryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns32__BlackListQueryInfo %p -> %p\n", q, p));
	*(ns32__BlackListQueryInfo*)p = *(ns32__BlackListQueryInfo*)q;
}

void ns31__DelUserServiceParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns31__DelUserServiceParam*)this)->returnCashType, SOAP_TYPE_int);
	soap_embedded(soap, &((ns31__DelUserServiceParam*)this)->serTmpId, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &((ns31__DelUserServiceParam*)this)->userName);
	/* transient soap skipped */
}

void ns31__DelUserServiceParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ns31__DelUserServiceParam*)this)->returnCashType);
	soap_default_LONG64(soap, &((ns31__DelUserServiceParam*)this)->serTmpId);
	soap_default_string(soap, &((ns31__DelUserServiceParam*)this)->userName);
	/* transient soap skipped */
}

int ns31__DelUserServiceParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns31__DelUserServiceParam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns31__DelUserServiceParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns31__DelUserServiceParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns31__DelUserServiceParam(struct soap *soap, const char *tag, int id, const ns31__DelUserServiceParam *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns31__DelUserServiceParam), type);
	soap_out_int(soap, "returnCashType", -1, &(((ns31__DelUserServiceParam*)a)->returnCashType), "");
	soap_out_LONG64(soap, "serTmpId", -1, &(((ns31__DelUserServiceParam*)a)->serTmpId), "");
	soap_out_string(soap, "userName", -1, &(((ns31__DelUserServiceParam*)a)->userName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns31__DelUserServiceParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns31__DelUserServiceParam(soap, this, tag, type);
}

SOAP_FMAC3 ns31__DelUserServiceParam * SOAP_FMAC4 soap_get_ns31__DelUserServiceParam(struct soap *soap, ns31__DelUserServiceParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns31__DelUserServiceParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns31__DelUserServiceParam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns31__DelUserServiceParam(soap, tag, this, type);
}

SOAP_FMAC3 ns31__DelUserServiceParam * SOAP_FMAC4 soap_in_ns31__DelUserServiceParam(struct soap *soap, const char *tag, ns31__DelUserServiceParam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns31__DelUserServiceParam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns31__DelUserServiceParam, sizeof(ns31__DelUserServiceParam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns31__DelUserServiceParam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns31__DelUserServiceParam *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_returnCashType1 = 1, soap_flag_serTmpId1 = 1, soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnCashType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "returnCashType", &(((ns31__DelUserServiceParam*)a)->returnCashType), "xsd:int"))
				{	soap_flag_returnCashType1--;
					continue;
				}
			if (soap_flag_serTmpId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "serTmpId", &(((ns31__DelUserServiceParam*)a)->serTmpId), "xsd:long"))
				{	soap_flag_serTmpId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns31__DelUserServiceParam*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_returnCashType1 > 0 || soap_flag_serTmpId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns31__DelUserServiceParam *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns31__DelUserServiceParam, 0, sizeof(ns31__DelUserServiceParam), 0, soap_copy_ns31__DelUserServiceParam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns31__DelUserServiceParam * SOAP_FMAC6 soap_new_ns31__DelUserServiceParam(struct soap *soap, int n)
{	return soap_instantiate_ns31__DelUserServiceParam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns31__DelUserServiceParam(struct soap *soap, ns31__DelUserServiceParam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns31__DelUserServiceParam * SOAP_FMAC4 soap_instantiate_ns31__DelUserServiceParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns31__DelUserServiceParam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns31__DelUserServiceParam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns31__DelUserServiceParam;
		if (size)
			*size = sizeof(ns31__DelUserServiceParam);
		((ns31__DelUserServiceParam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns31__DelUserServiceParam[n];
		if (size)
			*size = n * sizeof(ns31__DelUserServiceParam);
		for (int i = 0; i < n; i++)
			((ns31__DelUserServiceParam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns31__DelUserServiceParam*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns31__DelUserServiceParam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns31__DelUserServiceParam %p -> %p\n", q, p));
	*(ns31__DelUserServiceParam*)p = *(ns31__DelUserServiceParam*)q;
}

void ns30__ApplyServiceParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, &((ns30__ApplyServiceParam*)this)->appServList);
	soap_serialize_string(soap, &((ns30__ApplyServiceParam*)this)->userName);
	/* transient soap skipped */
}

void ns30__ApplyServiceParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns30__ApplyServiceParam*)this)->appServList = NULL;
	soap_default_string(soap, &((ns30__ApplyServiceParam*)this)->userName);
	/* transient soap skipped */
}

int ns30__ApplyServiceParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns30__ApplyServiceParam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns30__ApplyServiceParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns30__ApplyServiceParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns30__ApplyServiceParam(struct soap *soap, const char *tag, int id, const ns30__ApplyServiceParam *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns30__ApplyServiceParam), type);
	soap_out_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, "appServList", -1, &(((ns30__ApplyServiceParam*)a)->appServList), "");
	soap_out_string(soap, "userName", -1, &(((ns30__ApplyServiceParam*)a)->userName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns30__ApplyServiceParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns30__ApplyServiceParam(soap, this, tag, type);
}

SOAP_FMAC3 ns30__ApplyServiceParam * SOAP_FMAC4 soap_get_ns30__ApplyServiceParam(struct soap *soap, ns30__ApplyServiceParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns30__ApplyServiceParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns30__ApplyServiceParam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns30__ApplyServiceParam(soap, tag, this, type);
}

SOAP_FMAC3 ns30__ApplyServiceParam * SOAP_FMAC4 soap_in_ns30__ApplyServiceParam(struct soap *soap, const char *tag, ns30__ApplyServiceParam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns30__ApplyServiceParam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns30__ApplyServiceParam, sizeof(ns30__ApplyServiceParam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns30__ApplyServiceParam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns30__ApplyServiceParam *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_appServList1 = 1, soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_appServList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, "appServList", &(((ns30__ApplyServiceParam*)a)->appServList), "ns25:ApplyServiceInfo"))
				{	soap_flag_appServList1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns30__ApplyServiceParam*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns30__ApplyServiceParam *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns30__ApplyServiceParam, 0, sizeof(ns30__ApplyServiceParam), 0, soap_copy_ns30__ApplyServiceParam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns30__ApplyServiceParam * SOAP_FMAC6 soap_new_ns30__ApplyServiceParam(struct soap *soap, int n)
{	return soap_instantiate_ns30__ApplyServiceParam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns30__ApplyServiceParam(struct soap *soap, ns30__ApplyServiceParam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns30__ApplyServiceParam * SOAP_FMAC4 soap_instantiate_ns30__ApplyServiceParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns30__ApplyServiceParam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns30__ApplyServiceParam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns30__ApplyServiceParam;
		if (size)
			*size = sizeof(ns30__ApplyServiceParam);
		((ns30__ApplyServiceParam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns30__ApplyServiceParam[n];
		if (size)
			*size = n * sizeof(ns30__ApplyServiceParam);
		for (int i = 0; i < n; i++)
			((ns30__ApplyServiceParam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns30__ApplyServiceParam*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns30__ApplyServiceParam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns30__ApplyServiceParam %p -> %p\n", q, p));
	*(ns30__ApplyServiceParam*)p = *(ns30__ApplyServiceParam*)q;
}

void ns29__ChgAcctPassParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &((ns29__ChgAcctPassParam*)this)->newPass);
	soap_serialize_string(soap, &((ns29__ChgAcctPassParam*)this)->oldPass);
	soap_serialize_string(soap, &((ns29__ChgAcctPassParam*)this)->userName);
	/* transient soap skipped */
}

void ns29__ChgAcctPassParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns29__ChgAcctPassParam*)this)->newPass);
	soap_default_string(soap, &((ns29__ChgAcctPassParam*)this)->oldPass);
	soap_default_string(soap, &((ns29__ChgAcctPassParam*)this)->userName);
	/* transient soap skipped */
}

int ns29__ChgAcctPassParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns29__ChgAcctPassParam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns29__ChgAcctPassParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns29__ChgAcctPassParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns29__ChgAcctPassParam(struct soap *soap, const char *tag, int id, const ns29__ChgAcctPassParam *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns29__ChgAcctPassParam), type);
	soap_out_string(soap, "newPass", -1, &(((ns29__ChgAcctPassParam*)a)->newPass), "");
	soap_out_string(soap, "oldPass", -1, &(((ns29__ChgAcctPassParam*)a)->oldPass), "");
	soap_out_string(soap, "userName", -1, &(((ns29__ChgAcctPassParam*)a)->userName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns29__ChgAcctPassParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns29__ChgAcctPassParam(soap, this, tag, type);
}

SOAP_FMAC3 ns29__ChgAcctPassParam * SOAP_FMAC4 soap_get_ns29__ChgAcctPassParam(struct soap *soap, ns29__ChgAcctPassParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns29__ChgAcctPassParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns29__ChgAcctPassParam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns29__ChgAcctPassParam(soap, tag, this, type);
}

SOAP_FMAC3 ns29__ChgAcctPassParam * SOAP_FMAC4 soap_in_ns29__ChgAcctPassParam(struct soap *soap, const char *tag, ns29__ChgAcctPassParam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns29__ChgAcctPassParam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns29__ChgAcctPassParam, sizeof(ns29__ChgAcctPassParam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns29__ChgAcctPassParam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns29__ChgAcctPassParam *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_newPass1 = 1, soap_flag_oldPass1 = 1, soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_newPass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "newPass", &(((ns29__ChgAcctPassParam*)a)->newPass), "xsd:string"))
				{	soap_flag_newPass1--;
					continue;
				}
			if (soap_flag_oldPass1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "oldPass", &(((ns29__ChgAcctPassParam*)a)->oldPass), "xsd:string"))
				{	soap_flag_oldPass1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns29__ChgAcctPassParam*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns29__ChgAcctPassParam *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns29__ChgAcctPassParam, 0, sizeof(ns29__ChgAcctPassParam), 0, soap_copy_ns29__ChgAcctPassParam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns29__ChgAcctPassParam * SOAP_FMAC6 soap_new_ns29__ChgAcctPassParam(struct soap *soap, int n)
{	return soap_instantiate_ns29__ChgAcctPassParam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns29__ChgAcctPassParam(struct soap *soap, ns29__ChgAcctPassParam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns29__ChgAcctPassParam * SOAP_FMAC4 soap_instantiate_ns29__ChgAcctPassParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns29__ChgAcctPassParam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns29__ChgAcctPassParam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns29__ChgAcctPassParam;
		if (size)
			*size = sizeof(ns29__ChgAcctPassParam);
		((ns29__ChgAcctPassParam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns29__ChgAcctPassParam[n];
		if (size)
			*size = n * sizeof(ns29__ChgAcctPassParam);
		for (int i = 0; i < n; i++)
			((ns29__ChgAcctPassParam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns29__ChgAcctPassParam*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns29__ChgAcctPassParam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns29__ChgAcctPassParam %p -> %p\n", q, p));
	*(ns29__ChgAcctPassParam*)p = *(ns29__ChgAcctPassParam*)q;
}

void ns28__DelAcctParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &((ns28__DelAcctParam*)this)->cancelType);
	soap_serialize_string(soap, &((ns28__DelAcctParam*)this)->userName);
	/* transient soap skipped */
}

void ns28__DelAcctParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns28__DelAcctParam*)this)->cancelType = NULL;
	soap_default_string(soap, &((ns28__DelAcctParam*)this)->userName);
	/* transient soap skipped */
}

int ns28__DelAcctParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns28__DelAcctParam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns28__DelAcctParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns28__DelAcctParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns28__DelAcctParam(struct soap *soap, const char *tag, int id, const ns28__DelAcctParam *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns28__DelAcctParam), type);
	soap_out_PointerToint(soap, "cancelType", -1, &(((ns28__DelAcctParam*)a)->cancelType), "");
	soap_out_string(soap, "userName", -1, &(((ns28__DelAcctParam*)a)->userName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns28__DelAcctParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns28__DelAcctParam(soap, this, tag, type);
}

SOAP_FMAC3 ns28__DelAcctParam * SOAP_FMAC4 soap_get_ns28__DelAcctParam(struct soap *soap, ns28__DelAcctParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns28__DelAcctParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns28__DelAcctParam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns28__DelAcctParam(soap, tag, this, type);
}

SOAP_FMAC3 ns28__DelAcctParam * SOAP_FMAC4 soap_in_ns28__DelAcctParam(struct soap *soap, const char *tag, ns28__DelAcctParam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns28__DelAcctParam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns28__DelAcctParam, sizeof(ns28__DelAcctParam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns28__DelAcctParam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns28__DelAcctParam *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cancelType1 = 1, soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cancelType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "cancelType", &(((ns28__DelAcctParam*)a)->cancelType), "xsd:int"))
				{	soap_flag_cancelType1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns28__DelAcctParam*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns28__DelAcctParam *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns28__DelAcctParam, 0, sizeof(ns28__DelAcctParam), 0, soap_copy_ns28__DelAcctParam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns28__DelAcctParam * SOAP_FMAC6 soap_new_ns28__DelAcctParam(struct soap *soap, int n)
{	return soap_instantiate_ns28__DelAcctParam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns28__DelAcctParam(struct soap *soap, ns28__DelAcctParam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns28__DelAcctParam * SOAP_FMAC4 soap_instantiate_ns28__DelAcctParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns28__DelAcctParam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns28__DelAcctParam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns28__DelAcctParam;
		if (size)
			*size = sizeof(ns28__DelAcctParam);
		((ns28__DelAcctParam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns28__DelAcctParam[n];
		if (size)
			*size = n * sizeof(ns28__DelAcctParam);
		for (int i = 0; i < n; i++)
			((ns28__DelAcctParam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns28__DelAcctParam*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns28__DelAcctParam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns28__DelAcctParam %p -> %p\n", q, p));
	*(ns28__DelAcctParam*)p = *(ns28__DelAcctParam*)q;
}

void ns27__ModifyAcctParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &((ns27__ModifyAcctParam*)this)->address);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns27__ModifyAcctParam*)this)->appendColumnNames);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns27__ModifyAcctParam*)this)->appendColumnValues);
	soap_serialize_string(soap, &((ns27__ModifyAcctParam*)this)->email);
	soap_serialize_string(soap, &((ns27__ModifyAcctParam*)this)->framedIp);
	soap_serialize_string(soap, &((ns27__ModifyAcctParam*)this)->fullName);
	soap_serialize_string(soap, &((ns27__ModifyAcctParam*)this)->idNumber);
	soap_serialize_PointerToLONG64(soap, &((ns27__ModifyAcctParam*)this)->idleTimeout);
	soap_serialize_PointerTotime(soap, &((ns27__ModifyAcctParam*)this)->invalidTime);
	soap_serialize_string(soap, &((ns27__ModifyAcctParam*)this)->macAddr);
	soap_serialize_string(soap, &((ns27__ModifyAcctParam*)this)->multiMacList);
	soap_serialize_string(soap, &((ns27__ModifyAcctParam*)this)->nasIp);
	soap_serialize_PointerToint(soap, &((ns27__ModifyAcctParam*)this)->nasPort);
	soap_serialize_PointerToint(soap, &((ns27__ModifyAcctParam*)this)->onlineLimit);
	soap_serialize_string(soap, &((ns27__ModifyAcctParam*)this)->promptInfo);
	soap_serialize_string(soap, &((ns27__ModifyAcctParam*)this)->userName);
	soap_serialize_PointerToint(soap, &((ns27__ModifyAcctParam*)this)->vlan);
	/* transient soap skipped */
}

void ns27__ModifyAcctParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns27__ModifyAcctParam*)this)->address);
	((ns27__ModifyAcctParam*)this)->appendColumnNames = NULL;
	((ns27__ModifyAcctParam*)this)->appendColumnValues = NULL;
	soap_default_string(soap, &((ns27__ModifyAcctParam*)this)->email);
	soap_default_string(soap, &((ns27__ModifyAcctParam*)this)->framedIp);
	soap_default_string(soap, &((ns27__ModifyAcctParam*)this)->fullName);
	soap_default_string(soap, &((ns27__ModifyAcctParam*)this)->idNumber);
	((ns27__ModifyAcctParam*)this)->idleTimeout = NULL;
	((ns27__ModifyAcctParam*)this)->invalidTime = NULL;
	soap_default_string(soap, &((ns27__ModifyAcctParam*)this)->macAddr);
	soap_default_bool(soap, &((ns27__ModifyAcctParam*)this)->multiIpMacBind);
	soap_default_string(soap, &((ns27__ModifyAcctParam*)this)->multiMacList);
	soap_default_string(soap, &((ns27__ModifyAcctParam*)this)->nasIp);
	((ns27__ModifyAcctParam*)this)->nasPort = NULL;
	((ns27__ModifyAcctParam*)this)->onlineLimit = NULL;
	soap_default_string(soap, &((ns27__ModifyAcctParam*)this)->promptInfo);
	soap_default_string(soap, &((ns27__ModifyAcctParam*)this)->userName);
	((ns27__ModifyAcctParam*)this)->vlan = NULL;
	/* transient soap skipped */
}

int ns27__ModifyAcctParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns27__ModifyAcctParam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns27__ModifyAcctParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns27__ModifyAcctParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns27__ModifyAcctParam(struct soap *soap, const char *tag, int id, const ns27__ModifyAcctParam *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns27__ModifyAcctParam), type);
	soap_out_string(soap, "address", -1, &(((ns27__ModifyAcctParam*)a)->address), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "appendColumnNames", -1, &(((ns27__ModifyAcctParam*)a)->appendColumnNames), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "appendColumnValues", -1, &(((ns27__ModifyAcctParam*)a)->appendColumnValues), "");
	soap_out_string(soap, "email", -1, &(((ns27__ModifyAcctParam*)a)->email), "");
	soap_out_string(soap, "framedIp", -1, &(((ns27__ModifyAcctParam*)a)->framedIp), "");
	soap_out_string(soap, "fullName", -1, &(((ns27__ModifyAcctParam*)a)->fullName), "");
	soap_out_string(soap, "idNumber", -1, &(((ns27__ModifyAcctParam*)a)->idNumber), "");
	soap_out_PointerToLONG64(soap, "idleTimeout", -1, &(((ns27__ModifyAcctParam*)a)->idleTimeout), "");
	soap_out_PointerTotime(soap, "invalidTime", -1, &(((ns27__ModifyAcctParam*)a)->invalidTime), "");
	soap_out_string(soap, "macAddr", -1, &(((ns27__ModifyAcctParam*)a)->macAddr), "");
	soap_out_bool(soap, "multiIpMacBind", -1, &(((ns27__ModifyAcctParam*)a)->multiIpMacBind), "");
	soap_out_string(soap, "multiMacList", -1, &(((ns27__ModifyAcctParam*)a)->multiMacList), "");
	soap_out_string(soap, "nasIp", -1, &(((ns27__ModifyAcctParam*)a)->nasIp), "");
	soap_out_PointerToint(soap, "nasPort", -1, &(((ns27__ModifyAcctParam*)a)->nasPort), "");
	soap_out_PointerToint(soap, "onlineLimit", -1, &(((ns27__ModifyAcctParam*)a)->onlineLimit), "");
	soap_out_string(soap, "promptInfo", -1, &(((ns27__ModifyAcctParam*)a)->promptInfo), "");
	soap_out_string(soap, "userName", -1, &(((ns27__ModifyAcctParam*)a)->userName), "");
	soap_out_PointerToint(soap, "vlan", -1, &(((ns27__ModifyAcctParam*)a)->vlan), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns27__ModifyAcctParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns27__ModifyAcctParam(soap, this, tag, type);
}

SOAP_FMAC3 ns27__ModifyAcctParam * SOAP_FMAC4 soap_get_ns27__ModifyAcctParam(struct soap *soap, ns27__ModifyAcctParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns27__ModifyAcctParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns27__ModifyAcctParam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns27__ModifyAcctParam(soap, tag, this, type);
}

SOAP_FMAC3 ns27__ModifyAcctParam * SOAP_FMAC4 soap_in_ns27__ModifyAcctParam(struct soap *soap, const char *tag, ns27__ModifyAcctParam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns27__ModifyAcctParam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns27__ModifyAcctParam, sizeof(ns27__ModifyAcctParam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns27__ModifyAcctParam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns27__ModifyAcctParam *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_address1 = 1, soap_flag_appendColumnNames1 = 1, soap_flag_appendColumnValues1 = 1, soap_flag_email1 = 1, soap_flag_framedIp1 = 1, soap_flag_fullName1 = 1, soap_flag_idNumber1 = 1, soap_flag_idleTimeout1 = 1, soap_flag_invalidTime1 = 1, soap_flag_macAddr1 = 1, soap_flag_multiIpMacBind1 = 1, soap_flag_multiMacList1 = 1, soap_flag_nasIp1 = 1, soap_flag_nasPort1 = 1, soap_flag_onlineLimit1 = 1, soap_flag_promptInfo1 = 1, soap_flag_userName1 = 1, soap_flag_vlan1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "address", &(((ns27__ModifyAcctParam*)a)->address), "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_appendColumnNames1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "appendColumnNames", &(((ns27__ModifyAcctParam*)a)->appendColumnNames), "xsd:string"))
				{	soap_flag_appendColumnNames1--;
					continue;
				}
			if (soap_flag_appendColumnValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "appendColumnValues", &(((ns27__ModifyAcctParam*)a)->appendColumnValues), "xsd:string"))
				{	soap_flag_appendColumnValues1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email", &(((ns27__ModifyAcctParam*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_framedIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "framedIp", &(((ns27__ModifyAcctParam*)a)->framedIp), "xsd:string"))
				{	soap_flag_framedIp1--;
					continue;
				}
			if (soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fullName", &(((ns27__ModifyAcctParam*)a)->fullName), "xsd:string"))
				{	soap_flag_fullName1--;
					continue;
				}
			if (soap_flag_idNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "idNumber", &(((ns27__ModifyAcctParam*)a)->idNumber), "xsd:string"))
				{	soap_flag_idNumber1--;
					continue;
				}
			if (soap_flag_idleTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "idleTimeout", &(((ns27__ModifyAcctParam*)a)->idleTimeout), "xsd:long"))
				{	soap_flag_idleTimeout1--;
					continue;
				}
			if (soap_flag_invalidTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "invalidTime", &(((ns27__ModifyAcctParam*)a)->invalidTime), "xsd:dateTime"))
				{	soap_flag_invalidTime1--;
					continue;
				}
			if (soap_flag_macAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "macAddr", &(((ns27__ModifyAcctParam*)a)->macAddr), "xsd:string"))
				{	soap_flag_macAddr1--;
					continue;
				}
			if (soap_flag_multiIpMacBind1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "multiIpMacBind", &(((ns27__ModifyAcctParam*)a)->multiIpMacBind), "xsd:boolean"))
				{	soap_flag_multiIpMacBind1--;
					continue;
				}
			if (soap_flag_multiMacList1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "multiMacList", &(((ns27__ModifyAcctParam*)a)->multiMacList), "xsd:string"))
				{	soap_flag_multiMacList1--;
					continue;
				}
			if (soap_flag_nasIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "nasIp", &(((ns27__ModifyAcctParam*)a)->nasIp), "xsd:string"))
				{	soap_flag_nasIp1--;
					continue;
				}
			if (soap_flag_nasPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "nasPort", &(((ns27__ModifyAcctParam*)a)->nasPort), "xsd:int"))
				{	soap_flag_nasPort1--;
					continue;
				}
			if (soap_flag_onlineLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "onlineLimit", &(((ns27__ModifyAcctParam*)a)->onlineLimit), "xsd:int"))
				{	soap_flag_onlineLimit1--;
					continue;
				}
			if (soap_flag_promptInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "promptInfo", &(((ns27__ModifyAcctParam*)a)->promptInfo), "xsd:string"))
				{	soap_flag_promptInfo1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns27__ModifyAcctParam*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_vlan1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "vlan", &(((ns27__ModifyAcctParam*)a)->vlan), "xsd:int"))
				{	soap_flag_vlan1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_multiIpMacBind1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns27__ModifyAcctParam *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns27__ModifyAcctParam, 0, sizeof(ns27__ModifyAcctParam), 0, soap_copy_ns27__ModifyAcctParam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns27__ModifyAcctParam * SOAP_FMAC6 soap_new_ns27__ModifyAcctParam(struct soap *soap, int n)
{	return soap_instantiate_ns27__ModifyAcctParam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns27__ModifyAcctParam(struct soap *soap, ns27__ModifyAcctParam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns27__ModifyAcctParam * SOAP_FMAC4 soap_instantiate_ns27__ModifyAcctParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns27__ModifyAcctParam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns27__ModifyAcctParam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns27__ModifyAcctParam;
		if (size)
			*size = sizeof(ns27__ModifyAcctParam);
		((ns27__ModifyAcctParam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns27__ModifyAcctParam[n];
		if (size)
			*size = n * sizeof(ns27__ModifyAcctParam);
		for (int i = 0; i < n; i++)
			((ns27__ModifyAcctParam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns27__ModifyAcctParam*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns27__ModifyAcctParam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns27__ModifyAcctParam %p -> %p\n", q, p));
	*(ns27__ModifyAcctParam*)p = *(ns27__ModifyAcctParam*)q;
}

void ns26__AddAcctParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &((ns26__AddAcctParam*)this)->address);
	soap_serialize_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, &((ns26__AddAcctParam*)this)->appServList);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns26__AddAcctParam*)this)->appendColumnNames);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns26__AddAcctParam*)this)->appendColumnValues);
	soap_serialize_string(soap, &((ns26__AddAcctParam*)this)->email);
	soap_serialize_PointerToint(soap, &((ns26__AddAcctParam*)this)->feeType);
	soap_serialize_string(soap, &((ns26__AddAcctParam*)this)->framedIp);
	soap_serialize_string(soap, &((ns26__AddAcctParam*)this)->fullName);
	soap_serialize_string(soap, &((ns26__AddAcctParam*)this)->idNumber);
	soap_serialize_PointerToLONG64(soap, &((ns26__AddAcctParam*)this)->idleTimeout);
	soap_serialize_PointerTotime(soap, &((ns26__AddAcctParam*)this)->invalidTime);
	soap_serialize_string(soap, &((ns26__AddAcctParam*)this)->macAddr);
	soap_serialize_string(soap, &((ns26__AddAcctParam*)this)->multiMacList);
	soap_serialize_string(soap, &((ns26__AddAcctParam*)this)->nasIp);
	soap_serialize_PointerToint(soap, &((ns26__AddAcctParam*)this)->nasPort);
	soap_serialize_PointerToint(soap, &((ns26__AddAcctParam*)this)->onlineLimit);
	soap_serialize_string(soap, &((ns26__AddAcctParam*)this)->openPayAmount);
	soap_serialize_string(soap, &((ns26__AddAcctParam*)this)->password);
	soap_serialize_string(soap, &((ns26__AddAcctParam*)this)->promptInfo);
	soap_serialize_string(soap, &((ns26__AddAcctParam*)this)->userName);
	soap_serialize_PointerToint(soap, &((ns26__AddAcctParam*)this)->vlan);
	/* transient soap skipped */
}

void ns26__AddAcctParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns26__AddAcctParam*)this)->address);
	((ns26__AddAcctParam*)this)->appServList = NULL;
	((ns26__AddAcctParam*)this)->appendColumnNames = NULL;
	((ns26__AddAcctParam*)this)->appendColumnValues = NULL;
	soap_default_string(soap, &((ns26__AddAcctParam*)this)->email);
	((ns26__AddAcctParam*)this)->feeType = NULL;
	soap_default_string(soap, &((ns26__AddAcctParam*)this)->framedIp);
	soap_default_string(soap, &((ns26__AddAcctParam*)this)->fullName);
	soap_default_string(soap, &((ns26__AddAcctParam*)this)->idNumber);
	((ns26__AddAcctParam*)this)->idleTimeout = NULL;
	((ns26__AddAcctParam*)this)->invalidTime = NULL;
	soap_default_string(soap, &((ns26__AddAcctParam*)this)->macAddr);
	soap_default_bool(soap, &((ns26__AddAcctParam*)this)->multiIpMacBind);
	soap_default_string(soap, &((ns26__AddAcctParam*)this)->multiMacList);
	soap_default_string(soap, &((ns26__AddAcctParam*)this)->nasIp);
	((ns26__AddAcctParam*)this)->nasPort = NULL;
	((ns26__AddAcctParam*)this)->onlineLimit = NULL;
	soap_default_string(soap, &((ns26__AddAcctParam*)this)->openPayAmount);
	soap_default_string(soap, &((ns26__AddAcctParam*)this)->password);
	soap_default_string(soap, &((ns26__AddAcctParam*)this)->promptInfo);
	soap_default_string(soap, &((ns26__AddAcctParam*)this)->userName);
	((ns26__AddAcctParam*)this)->vlan = NULL;
	/* transient soap skipped */
}

int ns26__AddAcctParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns26__AddAcctParam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns26__AddAcctParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns26__AddAcctParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns26__AddAcctParam(struct soap *soap, const char *tag, int id, const ns26__AddAcctParam *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns26__AddAcctParam), type);
	soap_out_string(soap, "address", -1, &(((ns26__AddAcctParam*)a)->address), "");
	soap_out_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, "appServList", -1, &(((ns26__AddAcctParam*)a)->appServList), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "appendColumnNames", -1, &(((ns26__AddAcctParam*)a)->appendColumnNames), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "appendColumnValues", -1, &(((ns26__AddAcctParam*)a)->appendColumnValues), "");
	soap_out_string(soap, "email", -1, &(((ns26__AddAcctParam*)a)->email), "");
	soap_out_PointerToint(soap, "feeType", -1, &(((ns26__AddAcctParam*)a)->feeType), "");
	soap_out_string(soap, "framedIp", -1, &(((ns26__AddAcctParam*)a)->framedIp), "");
	soap_out_string(soap, "fullName", -1, &(((ns26__AddAcctParam*)a)->fullName), "");
	soap_out_string(soap, "idNumber", -1, &(((ns26__AddAcctParam*)a)->idNumber), "");
	soap_out_PointerToLONG64(soap, "idleTimeout", -1, &(((ns26__AddAcctParam*)a)->idleTimeout), "");
	soap_out_PointerTotime(soap, "invalidTime", -1, &(((ns26__AddAcctParam*)a)->invalidTime), "");
	soap_out_string(soap, "macAddr", -1, &(((ns26__AddAcctParam*)a)->macAddr), "");
	soap_out_bool(soap, "multiIpMacBind", -1, &(((ns26__AddAcctParam*)a)->multiIpMacBind), "");
	soap_out_string(soap, "multiMacList", -1, &(((ns26__AddAcctParam*)a)->multiMacList), "");
	soap_out_string(soap, "nasIp", -1, &(((ns26__AddAcctParam*)a)->nasIp), "");
	soap_out_PointerToint(soap, "nasPort", -1, &(((ns26__AddAcctParam*)a)->nasPort), "");
	soap_out_PointerToint(soap, "onlineLimit", -1, &(((ns26__AddAcctParam*)a)->onlineLimit), "");
	soap_out_string(soap, "openPayAmount", -1, &(((ns26__AddAcctParam*)a)->openPayAmount), "");
	soap_out_string(soap, "password", -1, &(((ns26__AddAcctParam*)a)->password), "");
	soap_out_string(soap, "promptInfo", -1, &(((ns26__AddAcctParam*)a)->promptInfo), "");
	soap_out_string(soap, "userName", -1, &(((ns26__AddAcctParam*)a)->userName), "");
	soap_out_PointerToint(soap, "vlan", -1, &(((ns26__AddAcctParam*)a)->vlan), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns26__AddAcctParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns26__AddAcctParam(soap, this, tag, type);
}

SOAP_FMAC3 ns26__AddAcctParam * SOAP_FMAC4 soap_get_ns26__AddAcctParam(struct soap *soap, ns26__AddAcctParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns26__AddAcctParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns26__AddAcctParam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns26__AddAcctParam(soap, tag, this, type);
}

SOAP_FMAC3 ns26__AddAcctParam * SOAP_FMAC4 soap_in_ns26__AddAcctParam(struct soap *soap, const char *tag, ns26__AddAcctParam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns26__AddAcctParam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns26__AddAcctParam, sizeof(ns26__AddAcctParam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns26__AddAcctParam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns26__AddAcctParam *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_address1 = 1, soap_flag_appServList1 = 1, soap_flag_appendColumnNames1 = 1, soap_flag_appendColumnValues1 = 1, soap_flag_email1 = 1, soap_flag_feeType1 = 1, soap_flag_framedIp1 = 1, soap_flag_fullName1 = 1, soap_flag_idNumber1 = 1, soap_flag_idleTimeout1 = 1, soap_flag_invalidTime1 = 1, soap_flag_macAddr1 = 1, soap_flag_multiIpMacBind1 = 1, soap_flag_multiMacList1 = 1, soap_flag_nasIp1 = 1, soap_flag_nasPort1 = 1, soap_flag_onlineLimit1 = 1, soap_flag_openPayAmount1 = 1, soap_flag_password1 = 1, soap_flag_promptInfo1 = 1, soap_flag_userName1 = 1, soap_flag_vlan1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "address", &(((ns26__AddAcctParam*)a)->address), "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_appServList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, "appServList", &(((ns26__AddAcctParam*)a)->appServList), "ns25:ApplyServiceInfo"))
				{	soap_flag_appServList1--;
					continue;
				}
			if (soap_flag_appendColumnNames1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "appendColumnNames", &(((ns26__AddAcctParam*)a)->appendColumnNames), "xsd:string"))
				{	soap_flag_appendColumnNames1--;
					continue;
				}
			if (soap_flag_appendColumnValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "appendColumnValues", &(((ns26__AddAcctParam*)a)->appendColumnValues), "xsd:string"))
				{	soap_flag_appendColumnValues1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email", &(((ns26__AddAcctParam*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_feeType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "feeType", &(((ns26__AddAcctParam*)a)->feeType), "xsd:int"))
				{	soap_flag_feeType1--;
					continue;
				}
			if (soap_flag_framedIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "framedIp", &(((ns26__AddAcctParam*)a)->framedIp), "xsd:string"))
				{	soap_flag_framedIp1--;
					continue;
				}
			if (soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fullName", &(((ns26__AddAcctParam*)a)->fullName), "xsd:string"))
				{	soap_flag_fullName1--;
					continue;
				}
			if (soap_flag_idNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "idNumber", &(((ns26__AddAcctParam*)a)->idNumber), "xsd:string"))
				{	soap_flag_idNumber1--;
					continue;
				}
			if (soap_flag_idleTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "idleTimeout", &(((ns26__AddAcctParam*)a)->idleTimeout), "xsd:long"))
				{	soap_flag_idleTimeout1--;
					continue;
				}
			if (soap_flag_invalidTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "invalidTime", &(((ns26__AddAcctParam*)a)->invalidTime), "xsd:dateTime"))
				{	soap_flag_invalidTime1--;
					continue;
				}
			if (soap_flag_macAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "macAddr", &(((ns26__AddAcctParam*)a)->macAddr), "xsd:string"))
				{	soap_flag_macAddr1--;
					continue;
				}
			if (soap_flag_multiIpMacBind1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "multiIpMacBind", &(((ns26__AddAcctParam*)a)->multiIpMacBind), "xsd:boolean"))
				{	soap_flag_multiIpMacBind1--;
					continue;
				}
			if (soap_flag_multiMacList1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "multiMacList", &(((ns26__AddAcctParam*)a)->multiMacList), "xsd:string"))
				{	soap_flag_multiMacList1--;
					continue;
				}
			if (soap_flag_nasIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "nasIp", &(((ns26__AddAcctParam*)a)->nasIp), "xsd:string"))
				{	soap_flag_nasIp1--;
					continue;
				}
			if (soap_flag_nasPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "nasPort", &(((ns26__AddAcctParam*)a)->nasPort), "xsd:int"))
				{	soap_flag_nasPort1--;
					continue;
				}
			if (soap_flag_onlineLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "onlineLimit", &(((ns26__AddAcctParam*)a)->onlineLimit), "xsd:int"))
				{	soap_flag_onlineLimit1--;
					continue;
				}
			if (soap_flag_openPayAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "openPayAmount", &(((ns26__AddAcctParam*)a)->openPayAmount), "xsd:string"))
				{	soap_flag_openPayAmount1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &(((ns26__AddAcctParam*)a)->password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_promptInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "promptInfo", &(((ns26__AddAcctParam*)a)->promptInfo), "xsd:string"))
				{	soap_flag_promptInfo1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns26__AddAcctParam*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_vlan1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "vlan", &(((ns26__AddAcctParam*)a)->vlan), "xsd:int"))
				{	soap_flag_vlan1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_multiIpMacBind1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns26__AddAcctParam *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns26__AddAcctParam, 0, sizeof(ns26__AddAcctParam), 0, soap_copy_ns26__AddAcctParam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns26__AddAcctParam * SOAP_FMAC6 soap_new_ns26__AddAcctParam(struct soap *soap, int n)
{	return soap_instantiate_ns26__AddAcctParam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns26__AddAcctParam(struct soap *soap, ns26__AddAcctParam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns26__AddAcctParam * SOAP_FMAC4 soap_instantiate_ns26__AddAcctParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns26__AddAcctParam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns26__AddAcctParam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns26__AddAcctParam;
		if (size)
			*size = sizeof(ns26__AddAcctParam);
		((ns26__AddAcctParam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns26__AddAcctParam[n];
		if (size)
			*size = n * sizeof(ns26__AddAcctParam);
		for (int i = 0; i < n; i++)
			((ns26__AddAcctParam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns26__AddAcctParam*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns26__AddAcctParam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns26__AddAcctParam %p -> %p\n", q, p));
	*(ns26__AddAcctParam*)p = *(ns26__AddAcctParam*)q;
}

void ns25__ApplyServiceInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns25__ApplyServiceInfo*)this)->serTmpId, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &((ns25__ApplyServiceInfo*)this)->userIpAddress);
	/* transient soap skipped */
}

void ns25__ApplyServiceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &((ns25__ApplyServiceInfo*)this)->serTmpId);
	soap_default_string(soap, &((ns25__ApplyServiceInfo*)this)->userIpAddress);
	/* transient soap skipped */
}

int ns25__ApplyServiceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns25__ApplyServiceInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns25__ApplyServiceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns25__ApplyServiceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns25__ApplyServiceInfo(struct soap *soap, const char *tag, int id, const ns25__ApplyServiceInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns25__ApplyServiceInfo), type);
	soap_out_LONG64(soap, "serTmpId", -1, &(((ns25__ApplyServiceInfo*)a)->serTmpId), "");
	soap_out_string(soap, "userIpAddress", -1, &(((ns25__ApplyServiceInfo*)a)->userIpAddress), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns25__ApplyServiceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns25__ApplyServiceInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns25__ApplyServiceInfo * SOAP_FMAC4 soap_get_ns25__ApplyServiceInfo(struct soap *soap, ns25__ApplyServiceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns25__ApplyServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns25__ApplyServiceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns25__ApplyServiceInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns25__ApplyServiceInfo * SOAP_FMAC4 soap_in_ns25__ApplyServiceInfo(struct soap *soap, const char *tag, ns25__ApplyServiceInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns25__ApplyServiceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns25__ApplyServiceInfo, sizeof(ns25__ApplyServiceInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns25__ApplyServiceInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns25__ApplyServiceInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_serTmpId1 = 1, soap_flag_userIpAddress1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serTmpId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "serTmpId", &(((ns25__ApplyServiceInfo*)a)->serTmpId), "xsd:long"))
				{	soap_flag_serTmpId1--;
					continue;
				}
			if (soap_flag_userIpAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIpAddress", &(((ns25__ApplyServiceInfo*)a)->userIpAddress), "xsd:string"))
				{	soap_flag_userIpAddress1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_serTmpId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns25__ApplyServiceInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns25__ApplyServiceInfo, 0, sizeof(ns25__ApplyServiceInfo), 0, soap_copy_ns25__ApplyServiceInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns25__ApplyServiceInfo * SOAP_FMAC6 soap_new_ns25__ApplyServiceInfo(struct soap *soap, int n)
{	return soap_instantiate_ns25__ApplyServiceInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns25__ApplyServiceInfo(struct soap *soap, ns25__ApplyServiceInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns25__ApplyServiceInfo * SOAP_FMAC4 soap_instantiate_ns25__ApplyServiceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns25__ApplyServiceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns25__ApplyServiceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns25__ApplyServiceInfo;
		if (size)
			*size = sizeof(ns25__ApplyServiceInfo);
		((ns25__ApplyServiceInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns25__ApplyServiceInfo[n];
		if (size)
			*size = n * sizeof(ns25__ApplyServiceInfo);
		for (int i = 0; i < n; i++)
			((ns25__ApplyServiceInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns25__ApplyServiceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns25__ApplyServiceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns25__ApplyServiceInfo %p -> %p\n", q, p));
	*(ns25__ApplyServiceInfo*)p = *(ns25__ApplyServiceInfo*)q;
}

void ns24__QueryActionInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &((ns24__QueryActionInfo*)this)->command);
	soap_embedded(soap, &((ns24__QueryActionInfo*)this)->count, SOAP_TYPE_int);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns24__QueryActionInfo*)this)->paraNames);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns24__QueryActionInfo*)this)->paraValues);
	soap_embedded(soap, &((ns24__QueryActionInfo*)this)->startPos, SOAP_TYPE_int);
	/* transient soap skipped */
}

void ns24__QueryActionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns24__QueryActionInfo*)this)->command);
	soap_default_int(soap, &((ns24__QueryActionInfo*)this)->count);
	((ns24__QueryActionInfo*)this)->paraNames = NULL;
	((ns24__QueryActionInfo*)this)->paraValues = NULL;
	soap_default_int(soap, &((ns24__QueryActionInfo*)this)->startPos);
	/* transient soap skipped */
}

int ns24__QueryActionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns24__QueryActionInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns24__QueryActionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns24__QueryActionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns24__QueryActionInfo(struct soap *soap, const char *tag, int id, const ns24__QueryActionInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns24__QueryActionInfo), type);
	soap_out_string(soap, "command", -1, &(((ns24__QueryActionInfo*)a)->command), "");
	soap_out_int(soap, "count", -1, &(((ns24__QueryActionInfo*)a)->count), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "paraNames", -1, &(((ns24__QueryActionInfo*)a)->paraNames), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "paraValues", -1, &(((ns24__QueryActionInfo*)a)->paraValues), "");
	soap_out_int(soap, "startPos", -1, &(((ns24__QueryActionInfo*)a)->startPos), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns24__QueryActionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns24__QueryActionInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns24__QueryActionInfo * SOAP_FMAC4 soap_get_ns24__QueryActionInfo(struct soap *soap, ns24__QueryActionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns24__QueryActionInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns24__QueryActionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns24__QueryActionInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns24__QueryActionInfo * SOAP_FMAC4 soap_in_ns24__QueryActionInfo(struct soap *soap, const char *tag, ns24__QueryActionInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns24__QueryActionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns24__QueryActionInfo, sizeof(ns24__QueryActionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns24__QueryActionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns24__QueryActionInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_command1 = 1, soap_flag_count1 = 1, soap_flag_paraNames1 = 1, soap_flag_paraValues1 = 1, soap_flag_startPos1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_command1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "command", &(((ns24__QueryActionInfo*)a)->command), "xsd:string"))
				{	soap_flag_command1--;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "count", &(((ns24__QueryActionInfo*)a)->count), "xsd:int"))
				{	soap_flag_count1--;
					continue;
				}
			if (soap_flag_paraNames1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "paraNames", &(((ns24__QueryActionInfo*)a)->paraNames), "xsd:string"))
				{	soap_flag_paraNames1--;
					continue;
				}
			if (soap_flag_paraValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "paraValues", &(((ns24__QueryActionInfo*)a)->paraValues), "xsd:string"))
				{	soap_flag_paraValues1--;
					continue;
				}
			if (soap_flag_startPos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startPos", &(((ns24__QueryActionInfo*)a)->startPos), "xsd:int"))
				{	soap_flag_startPos1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_count1 > 0 || soap_flag_startPos1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns24__QueryActionInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns24__QueryActionInfo, 0, sizeof(ns24__QueryActionInfo), 0, soap_copy_ns24__QueryActionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns24__QueryActionInfo * SOAP_FMAC6 soap_new_ns24__QueryActionInfo(struct soap *soap, int n)
{	return soap_instantiate_ns24__QueryActionInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns24__QueryActionInfo(struct soap *soap, ns24__QueryActionInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns24__QueryActionInfo * SOAP_FMAC4 soap_instantiate_ns24__QueryActionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns24__QueryActionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns24__QueryActionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns24__QueryActionInfo;
		if (size)
			*size = sizeof(ns24__QueryActionInfo);
		((ns24__QueryActionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns24__QueryActionInfo[n];
		if (size)
			*size = n * sizeof(ns24__QueryActionInfo);
		for (int i = 0; i < n; i++)
			((ns24__QueryActionInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns24__QueryActionInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns24__QueryActionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns24__QueryActionInfo %p -> %p\n", q, p));
	*(ns24__QueryActionInfo*)p = *(ns24__QueryActionInfo*)q;
}

void ns23__OperatorInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &((ns23__OperatorInfo*)this)->name);
	soap_serialize_string(soap, &((ns23__OperatorInfo*)this)->password);
	/* transient soap skipped */
}

void ns23__OperatorInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns23__OperatorInfo*)this)->name);
	soap_default_string(soap, &((ns23__OperatorInfo*)this)->password);
	/* transient soap skipped */
}

int ns23__OperatorInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns23__OperatorInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns23__OperatorInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns23__OperatorInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns23__OperatorInfo(struct soap *soap, const char *tag, int id, const ns23__OperatorInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns23__OperatorInfo), type);
	soap_out_string(soap, "name", -1, &(((ns23__OperatorInfo*)a)->name), "");
	soap_out_string(soap, "password", -1, &(((ns23__OperatorInfo*)a)->password), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns23__OperatorInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns23__OperatorInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns23__OperatorInfo * SOAP_FMAC4 soap_get_ns23__OperatorInfo(struct soap *soap, ns23__OperatorInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns23__OperatorInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns23__OperatorInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns23__OperatorInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns23__OperatorInfo * SOAP_FMAC4 soap_in_ns23__OperatorInfo(struct soap *soap, const char *tag, ns23__OperatorInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns23__OperatorInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns23__OperatorInfo, sizeof(ns23__OperatorInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns23__OperatorInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns23__OperatorInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1, soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(((ns23__OperatorInfo*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &(((ns23__OperatorInfo*)a)->password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns23__OperatorInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns23__OperatorInfo, 0, sizeof(ns23__OperatorInfo), 0, soap_copy_ns23__OperatorInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns23__OperatorInfo * SOAP_FMAC6 soap_new_ns23__OperatorInfo(struct soap *soap, int n)
{	return soap_instantiate_ns23__OperatorInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns23__OperatorInfo(struct soap *soap, ns23__OperatorInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns23__OperatorInfo * SOAP_FMAC4 soap_instantiate_ns23__OperatorInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns23__OperatorInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns23__OperatorInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns23__OperatorInfo;
		if (size)
			*size = sizeof(ns23__OperatorInfo);
		((ns23__OperatorInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns23__OperatorInfo[n];
		if (size)
			*size = n * sizeof(ns23__OperatorInfo);
		for (int i = 0; i < n; i++)
			((ns23__OperatorInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns23__OperatorInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns23__OperatorInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns23__OperatorInfo %p -> %p\n", q, p));
	*(ns23__OperatorInfo*)p = *(ns23__OperatorInfo*)q;
}

void ns22__ResultBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns22__ResultBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns22__ResultBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns22__ResultBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns22__ResultBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns22__ResultBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns22__ResultBase(struct soap *soap, const char *tag, int id, const ns22__ResultBase *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns22__ResultBase), type);
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns22__ResultBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns22__ResultBase(soap, this, tag, type);
}

SOAP_FMAC3 ns22__ResultBase * SOAP_FMAC4 soap_get_ns22__ResultBase(struct soap *soap, ns22__ResultBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns22__ResultBase(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns22__ResultBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns22__ResultBase(soap, tag, this, type);
}

SOAP_FMAC3 ns22__ResultBase * SOAP_FMAC4 soap_in_ns22__ResultBase(struct soap *soap, const char *tag, ns22__ResultBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns22__ResultBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns22__ResultBase, sizeof(ns22__ResultBase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns22__ResultBase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns22__ResultBase *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error1 = 1, soap_flag_errorCode1 = 1, soap_flag_errorMsg1 = 1, soap_flag_success1 = 1, soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error1--;
					continue;
				}
			if (soap_flag_errorCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode1--;
					continue;
				}
			if (soap_flag_errorMsg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg1--;
					continue;
				}
			if (soap_flag_success1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error1 > 0 || soap_flag_errorCode1 > 0 || soap_flag_success1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns22__ResultBase *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns22__ResultBase, 0, sizeof(ns22__ResultBase), 0, soap_copy_ns22__ResultBase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns22__ResultBase * SOAP_FMAC6 soap_new_ns22__ResultBase(struct soap *soap, int n)
{	return soap_instantiate_ns22__ResultBase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns22__ResultBase(struct soap *soap, ns22__ResultBase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns22__ResultBase * SOAP_FMAC4 soap_instantiate_ns22__ResultBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns22__ResultBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns22__ResultBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns3:RetDelUserInfo"))
	{	cp->type = SOAP_TYPE_ns3__RetDelUserInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ns3__RetDelUserInfo;
			if (size)
				*size = sizeof(ns3__RetDelUserInfo);
			((ns3__RetDelUserInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns3__RetDelUserInfo[n];
			if (size)
				*size = n * sizeof(ns3__RetDelUserInfo);
			for (int i = 0; i < n; i++)
				((ns3__RetDelUserInfo*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__RetDelUserInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:LanAccessDetailList"))
	{	cp->type = SOAP_TYPE_ns5__LanAccessDetailList;
		if (n < 0)
		{	cp->ptr = (void*)new ns5__LanAccessDetailList;
			if (size)
				*size = sizeof(ns5__LanAccessDetailList);
			((ns5__LanAccessDetailList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns5__LanAccessDetailList[n];
			if (size)
				*size = n * sizeof(ns5__LanAccessDetailList);
			for (int i = 0; i < n; i++)
				((ns5__LanAccessDetailList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__LanAccessDetailList*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:RandomInfo"))
	{	cp->type = SOAP_TYPE_ns6__RandomInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ns6__RandomInfo;
			if (size)
				*size = sizeof(ns6__RandomInfo);
			((ns6__RandomInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns6__RandomInfo[n];
			if (size)
				*size = n * sizeof(ns6__RandomInfo);
			for (int i = 0; i < n; i++)
				((ns6__RandomInfo*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__RandomInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns7:MultiResult"))
	{	cp->type = SOAP_TYPE_ns7__MultiResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns7__MultiResult;
			if (size)
				*size = sizeof(ns7__MultiResult);
			((ns7__MultiResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns7__MultiResult[n];
			if (size)
				*size = n * sizeof(ns7__MultiResult);
			for (int i = 0; i < n; i++)
				((ns7__MultiResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns7__MultiResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns8:RetUserInfo"))
	{	cp->type = SOAP_TYPE_ns8__RetUserInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ns8__RetUserInfo;
			if (size)
				*size = sizeof(ns8__RetUserInfo);
			((ns8__RetUserInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns8__RetUserInfo[n];
			if (size)
				*size = n * sizeof(ns8__RetUserInfo);
			for (int i = 0; i < n; i++)
				((ns8__RetUserInfo*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns8__RetUserInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns10:RetAccountList"))
	{	cp->type = SOAP_TYPE_ns10__RetAccountList;
		if (n < 0)
		{	cp->ptr = (void*)new ns10__RetAccountList;
			if (size)
				*size = sizeof(ns10__RetAccountList);
			((ns10__RetAccountList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns10__RetAccountList[n];
			if (size)
				*size = n * sizeof(ns10__RetAccountList);
			for (int i = 0; i < n; i++)
				((ns10__RetAccountList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns10__RetAccountList*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns11:RetPassword"))
	{	cp->type = SOAP_TYPE_ns11__RetPassword;
		if (n < 0)
		{	cp->ptr = (void*)new ns11__RetPassword;
			if (size)
				*size = sizeof(ns11__RetPassword);
			((ns11__RetPassword*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns11__RetPassword[n];
			if (size)
				*size = n * sizeof(ns11__RetPassword);
			for (int i = 0; i < n; i++)
				((ns11__RetPassword*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns11__RetPassword*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns13:RetAcctServiceInfo"))
	{	cp->type = SOAP_TYPE_ns13__RetAcctServiceInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ns13__RetAcctServiceInfo;
			if (size)
				*size = sizeof(ns13__RetAcctServiceInfo);
			((ns13__RetAcctServiceInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns13__RetAcctServiceInfo[n];
			if (size)
				*size = n * sizeof(ns13__RetAcctServiceInfo);
			for (int i = 0; i < n; i++)
				((ns13__RetAcctServiceInfo*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns13__RetAcctServiceInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns15:RetUserAppendInfo"))
	{	cp->type = SOAP_TYPE_ns15__RetUserAppendInfo;
		if (n < 0)
		{	cp->ptr = (void*)new ns15__RetUserAppendInfo;
			if (size)
				*size = sizeof(ns15__RetUserAppendInfo);
			((ns15__RetUserAppendInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns15__RetUserAppendInfo[n];
			if (size)
				*size = n * sizeof(ns15__RetUserAppendInfo);
			for (int i = 0; i < n; i++)
				((ns15__RetUserAppendInfo*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns15__RetUserAppendInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns17:BlackList"))
	{	cp->type = SOAP_TYPE_ns17__BlackList;
		if (n < 0)
		{	cp->ptr = (void*)new ns17__BlackList;
			if (size)
				*size = sizeof(ns17__BlackList);
			((ns17__BlackList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns17__BlackList[n];
			if (size)
				*size = n * sizeof(ns17__BlackList);
			for (int i = 0; i < n; i++)
				((ns17__BlackList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns17__BlackList*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns19:LanServiceList"))
	{	cp->type = SOAP_TYPE_ns19__LanServiceList;
		if (n < 0)
		{	cp->ptr = (void*)new ns19__LanServiceList;
			if (size)
				*size = sizeof(ns19__LanServiceList);
			((ns19__LanServiceList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns19__LanServiceList[n];
			if (size)
				*size = n * sizeof(ns19__LanServiceList);
			for (int i = 0; i < n; i++)
				((ns19__LanServiceList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns19__LanServiceList*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns20:SingleResult"))
	{	cp->type = SOAP_TYPE_ns20__SingleResult;
		if (n < 0)
		{	cp->ptr = (void*)new ns20__SingleResult;
			if (size)
				*size = sizeof(ns20__SingleResult);
			((ns20__SingleResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns20__SingleResult[n];
			if (size)
				*size = n * sizeof(ns20__SingleResult);
			for (int i = 0; i < n; i++)
				((ns20__SingleResult*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns20__SingleResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns21:UserBalance"))
	{	cp->type = SOAP_TYPE_ns21__UserBalance;
		if (n < 0)
		{	cp->ptr = (void*)new ns21__UserBalance;
			if (size)
				*size = sizeof(ns21__UserBalance);
			((ns21__UserBalance*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns21__UserBalance[n];
			if (size)
				*size = n * sizeof(ns21__UserBalance);
			for (int i = 0; i < n; i++)
				((ns21__UserBalance*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns21__UserBalance*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new ns22__ResultBase;
		if (size)
			*size = sizeof(ns22__ResultBase);
		((ns22__ResultBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns22__ResultBase[n];
		if (size)
			*size = n * sizeof(ns22__ResultBase);
		for (int i = 0; i < n; i++)
			((ns22__ResultBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns22__ResultBase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns22__ResultBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns22__ResultBase %p -> %p\n", q, p));
	*(ns22__ResultBase*)p = *(ns22__ResultBase*)q;
}

void ns21__UserBalance::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns21__UserBalance*)this)->balance, SOAP_TYPE_double);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns21__UserBalance::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &((ns21__UserBalance*)this)->balance);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns21__UserBalance::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns21__UserBalance);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns21__UserBalance::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns21__UserBalance(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns21__UserBalance(struct soap *soap, const char *tag, int id, const ns21__UserBalance *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns21__UserBalance), "ns21:UserBalance");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_double(soap, "balance", -1, &(((ns21__UserBalance*)a)->balance), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns21__UserBalance::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns21__UserBalance(soap, this, tag, type);
}

SOAP_FMAC3 ns21__UserBalance * SOAP_FMAC4 soap_get_ns21__UserBalance(struct soap *soap, ns21__UserBalance *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns21__UserBalance(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns21__UserBalance::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns21__UserBalance(soap, tag, this, type);
}

SOAP_FMAC3 ns21__UserBalance * SOAP_FMAC4 soap_in_ns21__UserBalance(struct soap *soap, const char *tag, ns21__UserBalance *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns21__UserBalance *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns21__UserBalance, sizeof(ns21__UserBalance), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns21__UserBalance)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns21__UserBalance *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_balance1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_balance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "balance", &(((ns21__UserBalance*)a)->balance), "xsd:double"))
				{	soap_flag_balance1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0 || soap_flag_balance1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns21__UserBalance *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns21__UserBalance, 0, sizeof(ns21__UserBalance), 0, soap_copy_ns21__UserBalance);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns21__UserBalance * SOAP_FMAC6 soap_new_ns21__UserBalance(struct soap *soap, int n)
{	return soap_instantiate_ns21__UserBalance(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns21__UserBalance(struct soap *soap, ns21__UserBalance *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns21__UserBalance * SOAP_FMAC4 soap_instantiate_ns21__UserBalance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns21__UserBalance(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns21__UserBalance, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns21__UserBalance;
		if (size)
			*size = sizeof(ns21__UserBalance);
		((ns21__UserBalance*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns21__UserBalance[n];
		if (size)
			*size = n * sizeof(ns21__UserBalance);
		for (int i = 0; i < n; i++)
			((ns21__UserBalance*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns21__UserBalance*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns21__UserBalance(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns21__UserBalance %p -> %p\n", q, p));
	*(ns21__UserBalance*)p = *(ns21__UserBalance*)q;
}

void ns20__SingleResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns20__SingleResult*)this)->columnCount, SOAP_TYPE_int);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns20__SingleResult*)this)->columnNames);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns20__SingleResult*)this)->columnTypes);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns20__SingleResult*)this)->resultValues);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns20__SingleResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ns20__SingleResult*)this)->columnCount);
	((ns20__SingleResult*)this)->columnNames = NULL;
	((ns20__SingleResult*)this)->columnTypes = NULL;
	((ns20__SingleResult*)this)->resultValues = NULL;
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns20__SingleResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns20__SingleResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns20__SingleResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns20__SingleResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns20__SingleResult(struct soap *soap, const char *tag, int id, const ns20__SingleResult *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns20__SingleResult), "ns20:SingleResult");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_int(soap, "columnCount", -1, &(((ns20__SingleResult*)a)->columnCount), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "columnNames", -1, &(((ns20__SingleResult*)a)->columnNames), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "columnTypes", -1, &(((ns20__SingleResult*)a)->columnTypes), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "resultValues", -1, &(((ns20__SingleResult*)a)->resultValues), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns20__SingleResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns20__SingleResult(soap, this, tag, type);
}

SOAP_FMAC3 ns20__SingleResult * SOAP_FMAC4 soap_get_ns20__SingleResult(struct soap *soap, ns20__SingleResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns20__SingleResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns20__SingleResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns20__SingleResult(soap, tag, this, type);
}

SOAP_FMAC3 ns20__SingleResult * SOAP_FMAC4 soap_in_ns20__SingleResult(struct soap *soap, const char *tag, ns20__SingleResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns20__SingleResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns20__SingleResult, sizeof(ns20__SingleResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns20__SingleResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns20__SingleResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_columnCount1 = 1, soap_flag_columnNames1 = 1, soap_flag_columnTypes1 = 1, soap_flag_resultValues1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_columnCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "columnCount", &(((ns20__SingleResult*)a)->columnCount), "xsd:int"))
				{	soap_flag_columnCount1--;
					continue;
				}
			if (soap_flag_columnNames1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "columnNames", &(((ns20__SingleResult*)a)->columnNames), "xsd:string"))
				{	soap_flag_columnNames1--;
					continue;
				}
			if (soap_flag_columnTypes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "columnTypes", &(((ns20__SingleResult*)a)->columnTypes), "xsd:string"))
				{	soap_flag_columnTypes1--;
					continue;
				}
			if (soap_flag_resultValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "resultValues", &(((ns20__SingleResult*)a)->resultValues), "xsd:string"))
				{	soap_flag_resultValues1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0 || soap_flag_columnCount1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns20__SingleResult *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns20__SingleResult, 0, sizeof(ns20__SingleResult), 0, soap_copy_ns20__SingleResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns20__SingleResult * SOAP_FMAC6 soap_new_ns20__SingleResult(struct soap *soap, int n)
{	return soap_instantiate_ns20__SingleResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns20__SingleResult(struct soap *soap, ns20__SingleResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns20__SingleResult * SOAP_FMAC4 soap_instantiate_ns20__SingleResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns20__SingleResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns20__SingleResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns20__SingleResult;
		if (size)
			*size = sizeof(ns20__SingleResult);
		((ns20__SingleResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns20__SingleResult[n];
		if (size)
			*size = n * sizeof(ns20__SingleResult);
		for (int i = 0; i < n; i++)
			((ns20__SingleResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns20__SingleResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns20__SingleResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns20__SingleResult %p -> %p\n", q, p));
	*(ns20__SingleResult*)p = *(ns20__SingleResult*)q;
}

void ns19__LanServiceList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(soap, &((ns19__LanServiceList*)this)->serviceList);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns19__LanServiceList::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns19__LanServiceList*)this)->serviceList = NULL;
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns19__LanServiceList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns19__LanServiceList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns19__LanServiceList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns19__LanServiceList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns19__LanServiceList(struct soap *soap, const char *tag, int id, const ns19__LanServiceList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns19__LanServiceList), "ns19:LanServiceList");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(soap, "serviceList", -1, &(((ns19__LanServiceList*)a)->serviceList), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns19__LanServiceList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns19__LanServiceList(soap, this, tag, type);
}

SOAP_FMAC3 ns19__LanServiceList * SOAP_FMAC4 soap_get_ns19__LanServiceList(struct soap *soap, ns19__LanServiceList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns19__LanServiceList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns19__LanServiceList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns19__LanServiceList(soap, tag, this, type);
}

SOAP_FMAC3 ns19__LanServiceList * SOAP_FMAC4 soap_in_ns19__LanServiceList(struct soap *soap, const char *tag, ns19__LanServiceList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns19__LanServiceList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns19__LanServiceList, sizeof(ns19__LanServiceList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns19__LanServiceList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns19__LanServiceList *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_serviceList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_serviceList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(soap, "serviceList", &(((ns19__LanServiceList*)a)->serviceList), "ns18:LanServiceInfo"))
				{	soap_flag_serviceList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns19__LanServiceList *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns19__LanServiceList, 0, sizeof(ns19__LanServiceList), 0, soap_copy_ns19__LanServiceList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns19__LanServiceList * SOAP_FMAC6 soap_new_ns19__LanServiceList(struct soap *soap, int n)
{	return soap_instantiate_ns19__LanServiceList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns19__LanServiceList(struct soap *soap, ns19__LanServiceList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns19__LanServiceList * SOAP_FMAC4 soap_instantiate_ns19__LanServiceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns19__LanServiceList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns19__LanServiceList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns19__LanServiceList;
		if (size)
			*size = sizeof(ns19__LanServiceList);
		((ns19__LanServiceList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns19__LanServiceList[n];
		if (size)
			*size = n * sizeof(ns19__LanServiceList);
		for (int i = 0; i < n; i++)
			((ns19__LanServiceList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns19__LanServiceList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns19__LanServiceList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns19__LanServiceList %p -> %p\n", q, p));
	*(ns19__LanServiceList*)p = *(ns19__LanServiceList*)q;
}

void ns18__LanServiceInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &((ns18__LanServiceInfo*)this)->acctStrategyName);
	soap_serialize_string(soap, &((ns18__LanServiceInfo*)this)->safePolicyName);
	soap_serialize_string(soap, &((ns18__LanServiceInfo*)this)->serviceDescription);
	soap_serialize_string(soap, &((ns18__LanServiceInfo*)this)->serviceName);
	soap_serialize_string(soap, &((ns18__LanServiceInfo*)this)->serviceSuffix);
	soap_embedded(soap, &((ns18__LanServiceInfo*)this)->serviceTmpId, SOAP_TYPE_LONG64);
	/* transient soap skipped */
}

void ns18__LanServiceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns18__LanServiceInfo*)this)->acctStrategyName);
	soap_default_bool(soap, &((ns18__LanServiceInfo*)this)->inputIpAddr);
	soap_default_string(soap, &((ns18__LanServiceInfo*)this)->safePolicyName);
	soap_default_string(soap, &((ns18__LanServiceInfo*)this)->serviceDescription);
	soap_default_string(soap, &((ns18__LanServiceInfo*)this)->serviceName);
	soap_default_string(soap, &((ns18__LanServiceInfo*)this)->serviceSuffix);
	soap_default_LONG64(soap, &((ns18__LanServiceInfo*)this)->serviceTmpId);
	soap_default_bool(soap, &((ns18__LanServiceInfo*)this)->valid);
	/* transient soap skipped */
}

int ns18__LanServiceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns18__LanServiceInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns18__LanServiceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns18__LanServiceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns18__LanServiceInfo(struct soap *soap, const char *tag, int id, const ns18__LanServiceInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns18__LanServiceInfo), type);
	soap_out_string(soap, "acctStrategyName", -1, &(((ns18__LanServiceInfo*)a)->acctStrategyName), "");
	soap_out_bool(soap, "inputIpAddr", -1, &(((ns18__LanServiceInfo*)a)->inputIpAddr), "");
	soap_out_string(soap, "safePolicyName", -1, &(((ns18__LanServiceInfo*)a)->safePolicyName), "");
	soap_out_string(soap, "serviceDescription", -1, &(((ns18__LanServiceInfo*)a)->serviceDescription), "");
	soap_out_string(soap, "serviceName", -1, &(((ns18__LanServiceInfo*)a)->serviceName), "");
	soap_out_string(soap, "serviceSuffix", -1, &(((ns18__LanServiceInfo*)a)->serviceSuffix), "");
	soap_out_LONG64(soap, "serviceTmpId", -1, &(((ns18__LanServiceInfo*)a)->serviceTmpId), "");
	soap_out_bool(soap, "valid", -1, &(((ns18__LanServiceInfo*)a)->valid), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns18__LanServiceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns18__LanServiceInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns18__LanServiceInfo * SOAP_FMAC4 soap_get_ns18__LanServiceInfo(struct soap *soap, ns18__LanServiceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns18__LanServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns18__LanServiceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns18__LanServiceInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns18__LanServiceInfo * SOAP_FMAC4 soap_in_ns18__LanServiceInfo(struct soap *soap, const char *tag, ns18__LanServiceInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns18__LanServiceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns18__LanServiceInfo, sizeof(ns18__LanServiceInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns18__LanServiceInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns18__LanServiceInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_acctStrategyName1 = 1, soap_flag_inputIpAddr1 = 1, soap_flag_safePolicyName1 = 1, soap_flag_serviceDescription1 = 1, soap_flag_serviceName1 = 1, soap_flag_serviceSuffix1 = 1, soap_flag_serviceTmpId1 = 1, soap_flag_valid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_acctStrategyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "acctStrategyName", &(((ns18__LanServiceInfo*)a)->acctStrategyName), "xsd:string"))
				{	soap_flag_acctStrategyName1--;
					continue;
				}
			if (soap_flag_inputIpAddr1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "inputIpAddr", &(((ns18__LanServiceInfo*)a)->inputIpAddr), "xsd:boolean"))
				{	soap_flag_inputIpAddr1--;
					continue;
				}
			if (soap_flag_safePolicyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "safePolicyName", &(((ns18__LanServiceInfo*)a)->safePolicyName), "xsd:string"))
				{	soap_flag_safePolicyName1--;
					continue;
				}
			if (soap_flag_serviceDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "serviceDescription", &(((ns18__LanServiceInfo*)a)->serviceDescription), "xsd:string"))
				{	soap_flag_serviceDescription1--;
					continue;
				}
			if (soap_flag_serviceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "serviceName", &(((ns18__LanServiceInfo*)a)->serviceName), "xsd:string"))
				{	soap_flag_serviceName1--;
					continue;
				}
			if (soap_flag_serviceSuffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "serviceSuffix", &(((ns18__LanServiceInfo*)a)->serviceSuffix), "xsd:string"))
				{	soap_flag_serviceSuffix1--;
					continue;
				}
			if (soap_flag_serviceTmpId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "serviceTmpId", &(((ns18__LanServiceInfo*)a)->serviceTmpId), "xsd:long"))
				{	soap_flag_serviceTmpId1--;
					continue;
				}
			if (soap_flag_valid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "valid", &(((ns18__LanServiceInfo*)a)->valid), "xsd:boolean"))
				{	soap_flag_valid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_inputIpAddr1 > 0 || soap_flag_serviceTmpId1 > 0 || soap_flag_valid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns18__LanServiceInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns18__LanServiceInfo, 0, sizeof(ns18__LanServiceInfo), 0, soap_copy_ns18__LanServiceInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns18__LanServiceInfo * SOAP_FMAC6 soap_new_ns18__LanServiceInfo(struct soap *soap, int n)
{	return soap_instantiate_ns18__LanServiceInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns18__LanServiceInfo(struct soap *soap, ns18__LanServiceInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns18__LanServiceInfo * SOAP_FMAC4 soap_instantiate_ns18__LanServiceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns18__LanServiceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns18__LanServiceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns18__LanServiceInfo;
		if (size)
			*size = sizeof(ns18__LanServiceInfo);
		((ns18__LanServiceInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns18__LanServiceInfo[n];
		if (size)
			*size = n * sizeof(ns18__LanServiceInfo);
		for (int i = 0; i < n; i++)
			((ns18__LanServiceInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns18__LanServiceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns18__LanServiceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns18__LanServiceInfo %p -> %p\n", q, p));
	*(ns18__LanServiceInfo*)p = *(ns18__LanServiceInfo*)q;
}

void ns17__BlackList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(soap, &((ns17__BlackList*)this)->list);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns17__BlackList::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns17__BlackList*)this)->list = NULL;
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns17__BlackList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns17__BlackList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns17__BlackList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns17__BlackList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns17__BlackList(struct soap *soap, const char *tag, int id, const ns17__BlackList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns17__BlackList), "ns17:BlackList");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(soap, "list", -1, &(((ns17__BlackList*)a)->list), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns17__BlackList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns17__BlackList(soap, this, tag, type);
}

SOAP_FMAC3 ns17__BlackList * SOAP_FMAC4 soap_get_ns17__BlackList(struct soap *soap, ns17__BlackList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns17__BlackList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns17__BlackList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns17__BlackList(soap, tag, this, type);
}

SOAP_FMAC3 ns17__BlackList * SOAP_FMAC4 soap_in_ns17__BlackList(struct soap *soap, const char *tag, ns17__BlackList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns17__BlackList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns17__BlackList, sizeof(ns17__BlackList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns17__BlackList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns17__BlackList *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_list1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_list1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(soap, "list", &(((ns17__BlackList*)a)->list), "ns16:BlackListInfo"))
				{	soap_flag_list1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns17__BlackList *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns17__BlackList, 0, sizeof(ns17__BlackList), 0, soap_copy_ns17__BlackList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns17__BlackList * SOAP_FMAC6 soap_new_ns17__BlackList(struct soap *soap, int n)
{	return soap_instantiate_ns17__BlackList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns17__BlackList(struct soap *soap, ns17__BlackList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns17__BlackList * SOAP_FMAC4 soap_instantiate_ns17__BlackList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns17__BlackList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns17__BlackList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns17__BlackList;
		if (size)
			*size = sizeof(ns17__BlackList);
		((ns17__BlackList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns17__BlackList[n];
		if (size)
			*size = n * sizeof(ns17__BlackList);
		for (int i = 0; i < n; i++)
			((ns17__BlackList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns17__BlackList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns17__BlackList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns17__BlackList %p -> %p\n", q, p));
	*(ns17__BlackList*)p = *(ns17__BlackList*)q;
}

void ns16__BlackListInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns16__BlackListInfo*)this)->faultCount, SOAP_TYPE_int);
	soap_embedded(soap, &((ns16__BlackListInfo*)this)->id, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &((ns16__BlackListInfo*)this)->insertTime);
	soap_serialize_string(soap, &((ns16__BlackListInfo*)this)->loginIP);
	soap_serialize_string(soap, &((ns16__BlackListInfo*)this)->loginMAC);
	soap_serialize_string(soap, &((ns16__BlackListInfo*)this)->nasIP);
	soap_serialize_string(soap, &((ns16__BlackListInfo*)this)->nasPort);
	soap_embedded(soap, &((ns16__BlackListInfo*)this)->type, SOAP_TYPE_int);
	soap_embedded(soap, &((ns16__BlackListInfo*)this)->userID, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &((ns16__BlackListInfo*)this)->userName);
	/* transient soap skipped */
}

void ns16__BlackListInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ns16__BlackListInfo*)this)->faultCount);
	soap_default_LONG64(soap, &((ns16__BlackListInfo*)this)->id);
	soap_default_string(soap, &((ns16__BlackListInfo*)this)->insertTime);
	soap_default_string(soap, &((ns16__BlackListInfo*)this)->loginIP);
	soap_default_string(soap, &((ns16__BlackListInfo*)this)->loginMAC);
	soap_default_string(soap, &((ns16__BlackListInfo*)this)->nasIP);
	soap_default_string(soap, &((ns16__BlackListInfo*)this)->nasPort);
	soap_default_int(soap, &((ns16__BlackListInfo*)this)->type);
	soap_default_LONG64(soap, &((ns16__BlackListInfo*)this)->userID);
	soap_default_string(soap, &((ns16__BlackListInfo*)this)->userName);
	/* transient soap skipped */
}

int ns16__BlackListInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns16__BlackListInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns16__BlackListInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns16__BlackListInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns16__BlackListInfo(struct soap *soap, const char *tag, int id, const ns16__BlackListInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns16__BlackListInfo), type);
	soap_out_int(soap, "faultCount", -1, &(((ns16__BlackListInfo*)a)->faultCount), "");
	soap_out_LONG64(soap, "id", -1, &(((ns16__BlackListInfo*)a)->id), "");
	soap_out_string(soap, "insertTime", -1, &(((ns16__BlackListInfo*)a)->insertTime), "");
	soap_out_string(soap, "loginIP", -1, &(((ns16__BlackListInfo*)a)->loginIP), "");
	soap_out_string(soap, "loginMAC", -1, &(((ns16__BlackListInfo*)a)->loginMAC), "");
	soap_out_string(soap, "nasIP", -1, &(((ns16__BlackListInfo*)a)->nasIP), "");
	soap_out_string(soap, "nasPort", -1, &(((ns16__BlackListInfo*)a)->nasPort), "");
	soap_out_int(soap, "type", -1, &(((ns16__BlackListInfo*)a)->type), "");
	soap_out_LONG64(soap, "userID", -1, &(((ns16__BlackListInfo*)a)->userID), "");
	soap_out_string(soap, "userName", -1, &(((ns16__BlackListInfo*)a)->userName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns16__BlackListInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns16__BlackListInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns16__BlackListInfo * SOAP_FMAC4 soap_get_ns16__BlackListInfo(struct soap *soap, ns16__BlackListInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns16__BlackListInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns16__BlackListInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns16__BlackListInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns16__BlackListInfo * SOAP_FMAC4 soap_in_ns16__BlackListInfo(struct soap *soap, const char *tag, ns16__BlackListInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns16__BlackListInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns16__BlackListInfo, sizeof(ns16__BlackListInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns16__BlackListInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns16__BlackListInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_faultCount1 = 1, soap_flag_id1 = 1, soap_flag_insertTime1 = 1, soap_flag_loginIP1 = 1, soap_flag_loginMAC1 = 1, soap_flag_nasIP1 = 1, soap_flag_nasPort1 = 1, soap_flag_type1 = 1, soap_flag_userID1 = 1, soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "faultCount", &(((ns16__BlackListInfo*)a)->faultCount), "xsd:int"))
				{	soap_flag_faultCount1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(((ns16__BlackListInfo*)a)->id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_insertTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "insertTime", &(((ns16__BlackListInfo*)a)->insertTime), "xsd:string"))
				{	soap_flag_insertTime1--;
					continue;
				}
			if (soap_flag_loginIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "loginIP", &(((ns16__BlackListInfo*)a)->loginIP), "xsd:string"))
				{	soap_flag_loginIP1--;
					continue;
				}
			if (soap_flag_loginMAC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "loginMAC", &(((ns16__BlackListInfo*)a)->loginMAC), "xsd:string"))
				{	soap_flag_loginMAC1--;
					continue;
				}
			if (soap_flag_nasIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "nasIP", &(((ns16__BlackListInfo*)a)->nasIP), "xsd:string"))
				{	soap_flag_nasIP1--;
					continue;
				}
			if (soap_flag_nasPort1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "nasPort", &(((ns16__BlackListInfo*)a)->nasPort), "xsd:string"))
				{	soap_flag_nasPort1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(((ns16__BlackListInfo*)a)->type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_userID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userID", &(((ns16__BlackListInfo*)a)->userID), "xsd:long"))
				{	soap_flag_userID1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns16__BlackListInfo*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_faultCount1 > 0 || soap_flag_id1 > 0 || soap_flag_type1 > 0 || soap_flag_userID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns16__BlackListInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns16__BlackListInfo, 0, sizeof(ns16__BlackListInfo), 0, soap_copy_ns16__BlackListInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns16__BlackListInfo * SOAP_FMAC6 soap_new_ns16__BlackListInfo(struct soap *soap, int n)
{	return soap_instantiate_ns16__BlackListInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns16__BlackListInfo(struct soap *soap, ns16__BlackListInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns16__BlackListInfo * SOAP_FMAC4 soap_instantiate_ns16__BlackListInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns16__BlackListInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns16__BlackListInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns16__BlackListInfo;
		if (size)
			*size = sizeof(ns16__BlackListInfo);
		((ns16__BlackListInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns16__BlackListInfo[n];
		if (size)
			*size = n * sizeof(ns16__BlackListInfo);
		for (int i = 0; i < n; i++)
			((ns16__BlackListInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns16__BlackListInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns16__BlackListInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns16__BlackListInfo %p -> %p\n", q, p));
	*(ns16__BlackListInfo*)p = *(ns16__BlackListInfo*)q;
}

void ns15__RetUserAppendInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, &((ns15__RetUserAppendInfo*)this)->appendDefines);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns15__RetUserAppendInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns15__RetUserAppendInfo*)this)->appendDefines = NULL;
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns15__RetUserAppendInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns15__RetUserAppendInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns15__RetUserAppendInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns15__RetUserAppendInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns15__RetUserAppendInfo(struct soap *soap, const char *tag, int id, const ns15__RetUserAppendInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns15__RetUserAppendInfo), "ns15:RetUserAppendInfo");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, "appendDefines", -1, &(((ns15__RetUserAppendInfo*)a)->appendDefines), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns15__RetUserAppendInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns15__RetUserAppendInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns15__RetUserAppendInfo * SOAP_FMAC4 soap_get_ns15__RetUserAppendInfo(struct soap *soap, ns15__RetUserAppendInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns15__RetUserAppendInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns15__RetUserAppendInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns15__RetUserAppendInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns15__RetUserAppendInfo * SOAP_FMAC4 soap_in_ns15__RetUserAppendInfo(struct soap *soap, const char *tag, ns15__RetUserAppendInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns15__RetUserAppendInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns15__RetUserAppendInfo, sizeof(ns15__RetUserAppendInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns15__RetUserAppendInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns15__RetUserAppendInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_appendDefines1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_appendDefines1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, "appendDefines", &(((ns15__RetUserAppendInfo*)a)->appendDefines), "ns14:UserAppendInfo"))
				{	soap_flag_appendDefines1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns15__RetUserAppendInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns15__RetUserAppendInfo, 0, sizeof(ns15__RetUserAppendInfo), 0, soap_copy_ns15__RetUserAppendInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns15__RetUserAppendInfo * SOAP_FMAC6 soap_new_ns15__RetUserAppendInfo(struct soap *soap, int n)
{	return soap_instantiate_ns15__RetUserAppendInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns15__RetUserAppendInfo(struct soap *soap, ns15__RetUserAppendInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns15__RetUserAppendInfo * SOAP_FMAC4 soap_instantiate_ns15__RetUserAppendInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns15__RetUserAppendInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns15__RetUserAppendInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns15__RetUserAppendInfo;
		if (size)
			*size = sizeof(ns15__RetUserAppendInfo);
		((ns15__RetUserAppendInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns15__RetUserAppendInfo[n];
		if (size)
			*size = n * sizeof(ns15__RetUserAppendInfo);
		for (int i = 0; i < n; i++)
			((ns15__RetUserAppendInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns15__RetUserAppendInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns15__RetUserAppendInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns15__RetUserAppendInfo %p -> %p\n", q, p));
	*(ns15__RetUserAppendInfo*)p = *(ns15__RetUserAppendInfo*)q;
}

void ns14__UserAppendInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &((ns14__UserAppendInfo*)this)->columnName);
	soap_serialize_string(soap, &((ns14__UserAppendInfo*)this)->defaultValue);
	soap_serialize_PointerToint(soap, &((ns14__UserAppendInfo*)this)->fieldLen);
	soap_serialize_PointerTodouble(soap, &((ns14__UserAppendInfo*)this)->fieldMax);
	soap_serialize_PointerTodouble(soap, &((ns14__UserAppendInfo*)this)->fieldMin);
	soap_serialize_string(soap, &((ns14__UserAppendInfo*)this)->fieldName);
	soap_serialize_PointerToint(soap, &((ns14__UserAppendInfo*)this)->fieldPriority);
	soap_serialize_PointerToint(soap, &((ns14__UserAppendInfo*)this)->fieldState);
	soap_serialize_PointerToint(soap, &((ns14__UserAppendInfo*)this)->fieldType);
	soap_serialize_PointerToint(soap, &((ns14__UserAppendInfo*)this)->ifPreregisterUse);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns14__UserAppendInfo*)this)->options);
	/* transient soap skipped */
}

void ns14__UserAppendInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns14__UserAppendInfo*)this)->columnName);
	soap_default_string(soap, &((ns14__UserAppendInfo*)this)->defaultValue);
	((ns14__UserAppendInfo*)this)->fieldLen = NULL;
	((ns14__UserAppendInfo*)this)->fieldMax = NULL;
	((ns14__UserAppendInfo*)this)->fieldMin = NULL;
	soap_default_string(soap, &((ns14__UserAppendInfo*)this)->fieldName);
	((ns14__UserAppendInfo*)this)->fieldPriority = NULL;
	((ns14__UserAppendInfo*)this)->fieldState = NULL;
	((ns14__UserAppendInfo*)this)->fieldType = NULL;
	((ns14__UserAppendInfo*)this)->ifPreregisterUse = NULL;
	((ns14__UserAppendInfo*)this)->options = NULL;
	/* transient soap skipped */
}

int ns14__UserAppendInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns14__UserAppendInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns14__UserAppendInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns14__UserAppendInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns14__UserAppendInfo(struct soap *soap, const char *tag, int id, const ns14__UserAppendInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns14__UserAppendInfo), type);
	soap_out_string(soap, "columnName", -1, &(((ns14__UserAppendInfo*)a)->columnName), "");
	soap_out_string(soap, "defaultValue", -1, &(((ns14__UserAppendInfo*)a)->defaultValue), "");
	soap_out_PointerToint(soap, "fieldLen", -1, &(((ns14__UserAppendInfo*)a)->fieldLen), "");
	soap_out_PointerTodouble(soap, "fieldMax", -1, &(((ns14__UserAppendInfo*)a)->fieldMax), "");
	soap_out_PointerTodouble(soap, "fieldMin", -1, &(((ns14__UserAppendInfo*)a)->fieldMin), "");
	soap_out_string(soap, "fieldName", -1, &(((ns14__UserAppendInfo*)a)->fieldName), "");
	soap_out_PointerToint(soap, "fieldPriority", -1, &(((ns14__UserAppendInfo*)a)->fieldPriority), "");
	soap_out_PointerToint(soap, "fieldState", -1, &(((ns14__UserAppendInfo*)a)->fieldState), "");
	soap_out_PointerToint(soap, "fieldType", -1, &(((ns14__UserAppendInfo*)a)->fieldType), "");
	soap_out_PointerToint(soap, "ifPreregisterUse", -1, &(((ns14__UserAppendInfo*)a)->ifPreregisterUse), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "options", -1, &(((ns14__UserAppendInfo*)a)->options), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns14__UserAppendInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns14__UserAppendInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns14__UserAppendInfo * SOAP_FMAC4 soap_get_ns14__UserAppendInfo(struct soap *soap, ns14__UserAppendInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns14__UserAppendInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns14__UserAppendInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns14__UserAppendInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns14__UserAppendInfo * SOAP_FMAC4 soap_in_ns14__UserAppendInfo(struct soap *soap, const char *tag, ns14__UserAppendInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns14__UserAppendInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns14__UserAppendInfo, sizeof(ns14__UserAppendInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns14__UserAppendInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns14__UserAppendInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_columnName1 = 1, soap_flag_defaultValue1 = 1, soap_flag_fieldLen1 = 1, soap_flag_fieldMax1 = 1, soap_flag_fieldMin1 = 1, soap_flag_fieldName1 = 1, soap_flag_fieldPriority1 = 1, soap_flag_fieldState1 = 1, soap_flag_fieldType1 = 1, soap_flag_ifPreregisterUse1 = 1, soap_flag_options1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_columnName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "columnName", &(((ns14__UserAppendInfo*)a)->columnName), "xsd:string"))
				{	soap_flag_columnName1--;
					continue;
				}
			if (soap_flag_defaultValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "defaultValue", &(((ns14__UserAppendInfo*)a)->defaultValue), "xsd:string"))
				{	soap_flag_defaultValue1--;
					continue;
				}
			if (soap_flag_fieldLen1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "fieldLen", &(((ns14__UserAppendInfo*)a)->fieldLen), "xsd:int"))
				{	soap_flag_fieldLen1--;
					continue;
				}
			if (soap_flag_fieldMax1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "fieldMax", &(((ns14__UserAppendInfo*)a)->fieldMax), "xsd:double"))
				{	soap_flag_fieldMax1--;
					continue;
				}
			if (soap_flag_fieldMin1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "fieldMin", &(((ns14__UserAppendInfo*)a)->fieldMin), "xsd:double"))
				{	soap_flag_fieldMin1--;
					continue;
				}
			if (soap_flag_fieldName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fieldName", &(((ns14__UserAppendInfo*)a)->fieldName), "xsd:string"))
				{	soap_flag_fieldName1--;
					continue;
				}
			if (soap_flag_fieldPriority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "fieldPriority", &(((ns14__UserAppendInfo*)a)->fieldPriority), "xsd:int"))
				{	soap_flag_fieldPriority1--;
					continue;
				}
			if (soap_flag_fieldState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "fieldState", &(((ns14__UserAppendInfo*)a)->fieldState), "xsd:int"))
				{	soap_flag_fieldState1--;
					continue;
				}
			if (soap_flag_fieldType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "fieldType", &(((ns14__UserAppendInfo*)a)->fieldType), "xsd:int"))
				{	soap_flag_fieldType1--;
					continue;
				}
			if (soap_flag_ifPreregisterUse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ifPreregisterUse", &(((ns14__UserAppendInfo*)a)->ifPreregisterUse), "xsd:int"))
				{	soap_flag_ifPreregisterUse1--;
					continue;
				}
			if (soap_flag_options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "options", &(((ns14__UserAppendInfo*)a)->options), "xsd:string"))
				{	soap_flag_options1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns14__UserAppendInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns14__UserAppendInfo, 0, sizeof(ns14__UserAppendInfo), 0, soap_copy_ns14__UserAppendInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns14__UserAppendInfo * SOAP_FMAC6 soap_new_ns14__UserAppendInfo(struct soap *soap, int n)
{	return soap_instantiate_ns14__UserAppendInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns14__UserAppendInfo(struct soap *soap, ns14__UserAppendInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns14__UserAppendInfo * SOAP_FMAC4 soap_instantiate_ns14__UserAppendInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns14__UserAppendInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns14__UserAppendInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns14__UserAppendInfo;
		if (size)
			*size = sizeof(ns14__UserAppendInfo);
		((ns14__UserAppendInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns14__UserAppendInfo[n];
		if (size)
			*size = n * sizeof(ns14__UserAppendInfo);
		for (int i = 0; i < n; i++)
			((ns14__UserAppendInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns14__UserAppendInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns14__UserAppendInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns14__UserAppendInfo %p -> %p\n", q, p));
	*(ns14__UserAppendInfo*)p = *(ns14__UserAppendInfo*)q;
}

void ns13__RetAcctServiceInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, &((ns13__RetAcctServiceInfo*)this)->serviceInfo);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns13__RetAcctServiceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns13__RetAcctServiceInfo*)this)->serviceInfo = NULL;
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns13__RetAcctServiceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns13__RetAcctServiceInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns13__RetAcctServiceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns13__RetAcctServiceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns13__RetAcctServiceInfo(struct soap *soap, const char *tag, int id, const ns13__RetAcctServiceInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns13__RetAcctServiceInfo), "ns13:RetAcctServiceInfo");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, "serviceInfo", -1, &(((ns13__RetAcctServiceInfo*)a)->serviceInfo), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns13__RetAcctServiceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns13__RetAcctServiceInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns13__RetAcctServiceInfo * SOAP_FMAC4 soap_get_ns13__RetAcctServiceInfo(struct soap *soap, ns13__RetAcctServiceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns13__RetAcctServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns13__RetAcctServiceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns13__RetAcctServiceInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns13__RetAcctServiceInfo * SOAP_FMAC4 soap_in_ns13__RetAcctServiceInfo(struct soap *soap, const char *tag, ns13__RetAcctServiceInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns13__RetAcctServiceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns13__RetAcctServiceInfo, sizeof(ns13__RetAcctServiceInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns13__RetAcctServiceInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns13__RetAcctServiceInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_serviceInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_serviceInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, "serviceInfo", &(((ns13__RetAcctServiceInfo*)a)->serviceInfo), "ns12:AcctServiceInfo"))
				{	soap_flag_serviceInfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns13__RetAcctServiceInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns13__RetAcctServiceInfo, 0, sizeof(ns13__RetAcctServiceInfo), 0, soap_copy_ns13__RetAcctServiceInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns13__RetAcctServiceInfo * SOAP_FMAC6 soap_new_ns13__RetAcctServiceInfo(struct soap *soap, int n)
{	return soap_instantiate_ns13__RetAcctServiceInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns13__RetAcctServiceInfo(struct soap *soap, ns13__RetAcctServiceInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns13__RetAcctServiceInfo * SOAP_FMAC4 soap_instantiate_ns13__RetAcctServiceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns13__RetAcctServiceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns13__RetAcctServiceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns13__RetAcctServiceInfo;
		if (size)
			*size = sizeof(ns13__RetAcctServiceInfo);
		((ns13__RetAcctServiceInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns13__RetAcctServiceInfo[n];
		if (size)
			*size = n * sizeof(ns13__RetAcctServiceInfo);
		for (int i = 0; i < n; i++)
			((ns13__RetAcctServiceInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns13__RetAcctServiceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns13__RetAcctServiceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns13__RetAcctServiceInfo %p -> %p\n", q, p));
	*(ns13__RetAcctServiceInfo*)p = *(ns13__RetAcctServiceInfo*)q;
}

void ns12__AcctServiceInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &((ns12__AcctServiceInfo*)this)->serSuffix);
	soap_embedded(soap, &((ns12__AcctServiceInfo*)this)->serTmpId, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &((ns12__AcctServiceInfo*)this)->serTmpName);
	soap_serialize_string(soap, &((ns12__AcctServiceInfo*)this)->userIpAddress);
	/* transient soap skipped */
}

void ns12__AcctServiceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns12__AcctServiceInfo*)this)->serSuffix);
	soap_default_LONG64(soap, &((ns12__AcctServiceInfo*)this)->serTmpId);
	soap_default_string(soap, &((ns12__AcctServiceInfo*)this)->serTmpName);
	soap_default_string(soap, &((ns12__AcctServiceInfo*)this)->userIpAddress);
	/* transient soap skipped */
}

int ns12__AcctServiceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns12__AcctServiceInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns12__AcctServiceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns12__AcctServiceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns12__AcctServiceInfo(struct soap *soap, const char *tag, int id, const ns12__AcctServiceInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns12__AcctServiceInfo), type);
	soap_out_string(soap, "serSuffix", -1, &(((ns12__AcctServiceInfo*)a)->serSuffix), "");
	soap_out_LONG64(soap, "serTmpId", -1, &(((ns12__AcctServiceInfo*)a)->serTmpId), "");
	soap_out_string(soap, "serTmpName", -1, &(((ns12__AcctServiceInfo*)a)->serTmpName), "");
	soap_out_string(soap, "userIpAddress", -1, &(((ns12__AcctServiceInfo*)a)->userIpAddress), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns12__AcctServiceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns12__AcctServiceInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns12__AcctServiceInfo * SOAP_FMAC4 soap_get_ns12__AcctServiceInfo(struct soap *soap, ns12__AcctServiceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns12__AcctServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns12__AcctServiceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns12__AcctServiceInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns12__AcctServiceInfo * SOAP_FMAC4 soap_in_ns12__AcctServiceInfo(struct soap *soap, const char *tag, ns12__AcctServiceInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns12__AcctServiceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns12__AcctServiceInfo, sizeof(ns12__AcctServiceInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns12__AcctServiceInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns12__AcctServiceInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_serSuffix1 = 1, soap_flag_serTmpId1 = 1, soap_flag_serTmpName1 = 1, soap_flag_userIpAddress1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serSuffix1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "serSuffix", &(((ns12__AcctServiceInfo*)a)->serSuffix), "xsd:string"))
				{	soap_flag_serSuffix1--;
					continue;
				}
			if (soap_flag_serTmpId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "serTmpId", &(((ns12__AcctServiceInfo*)a)->serTmpId), "xsd:long"))
				{	soap_flag_serTmpId1--;
					continue;
				}
			if (soap_flag_serTmpName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "serTmpName", &(((ns12__AcctServiceInfo*)a)->serTmpName), "xsd:string"))
				{	soap_flag_serTmpName1--;
					continue;
				}
			if (soap_flag_userIpAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIpAddress", &(((ns12__AcctServiceInfo*)a)->userIpAddress), "xsd:string"))
				{	soap_flag_userIpAddress1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_serTmpId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns12__AcctServiceInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns12__AcctServiceInfo, 0, sizeof(ns12__AcctServiceInfo), 0, soap_copy_ns12__AcctServiceInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns12__AcctServiceInfo * SOAP_FMAC6 soap_new_ns12__AcctServiceInfo(struct soap *soap, int n)
{	return soap_instantiate_ns12__AcctServiceInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns12__AcctServiceInfo(struct soap *soap, ns12__AcctServiceInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns12__AcctServiceInfo * SOAP_FMAC4 soap_instantiate_ns12__AcctServiceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns12__AcctServiceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns12__AcctServiceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns12__AcctServiceInfo;
		if (size)
			*size = sizeof(ns12__AcctServiceInfo);
		((ns12__AcctServiceInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns12__AcctServiceInfo[n];
		if (size)
			*size = n * sizeof(ns12__AcctServiceInfo);
		for (int i = 0; i < n; i++)
			((ns12__AcctServiceInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns12__AcctServiceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns12__AcctServiceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns12__AcctServiceInfo %p -> %p\n", q, p));
	*(ns12__AcctServiceInfo*)p = *(ns12__AcctServiceInfo*)q;
}

void ns11__RetPassword::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &((ns11__RetPassword*)this)->password);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns11__RetPassword::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns11__RetPassword*)this)->password);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns11__RetPassword::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns11__RetPassword);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns11__RetPassword::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns11__RetPassword(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns11__RetPassword(struct soap *soap, const char *tag, int id, const ns11__RetPassword *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns11__RetPassword), "ns11:RetPassword");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_string(soap, "password", -1, &(((ns11__RetPassword*)a)->password), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns11__RetPassword::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns11__RetPassword(soap, this, tag, type);
}

SOAP_FMAC3 ns11__RetPassword * SOAP_FMAC4 soap_get_ns11__RetPassword(struct soap *soap, ns11__RetPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns11__RetPassword(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns11__RetPassword::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns11__RetPassword(soap, tag, this, type);
}

SOAP_FMAC3 ns11__RetPassword * SOAP_FMAC4 soap_in_ns11__RetPassword(struct soap *soap, const char *tag, ns11__RetPassword *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns11__RetPassword *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns11__RetPassword, sizeof(ns11__RetPassword), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns11__RetPassword)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns11__RetPassword *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &(((ns11__RetPassword*)a)->password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns11__RetPassword *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns11__RetPassword, 0, sizeof(ns11__RetPassword), 0, soap_copy_ns11__RetPassword);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns11__RetPassword * SOAP_FMAC6 soap_new_ns11__RetPassword(struct soap *soap, int n)
{	return soap_instantiate_ns11__RetPassword(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns11__RetPassword(struct soap *soap, ns11__RetPassword *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns11__RetPassword * SOAP_FMAC4 soap_instantiate_ns11__RetPassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns11__RetPassword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns11__RetPassword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns11__RetPassword;
		if (size)
			*size = sizeof(ns11__RetPassword);
		((ns11__RetPassword*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns11__RetPassword[n];
		if (size)
			*size = n * sizeof(ns11__RetPassword);
		for (int i = 0; i < n; i++)
			((ns11__RetPassword*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns11__RetPassword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns11__RetPassword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns11__RetPassword %p -> %p\n", q, p));
	*(ns11__RetPassword*)p = *(ns11__RetPassword*)q;
}

void ns10__RetAccountList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, &((ns10__RetAccountList*)this)->acctList);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns10__RetAccountList::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns10__RetAccountList*)this)->acctList = NULL;
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns10__RetAccountList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns10__RetAccountList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns10__RetAccountList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns10__RetAccountList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns10__RetAccountList(struct soap *soap, const char *tag, int id, const ns10__RetAccountList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns10__RetAccountList), "ns10:RetAccountList");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, "acctList", -1, &(((ns10__RetAccountList*)a)->acctList), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns10__RetAccountList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns10__RetAccountList(soap, this, tag, type);
}

SOAP_FMAC3 ns10__RetAccountList * SOAP_FMAC4 soap_get_ns10__RetAccountList(struct soap *soap, ns10__RetAccountList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns10__RetAccountList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns10__RetAccountList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns10__RetAccountList(soap, tag, this, type);
}

SOAP_FMAC3 ns10__RetAccountList * SOAP_FMAC4 soap_in_ns10__RetAccountList(struct soap *soap, const char *tag, ns10__RetAccountList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns10__RetAccountList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns10__RetAccountList, sizeof(ns10__RetAccountList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns10__RetAccountList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns10__RetAccountList *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_acctList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_acctList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, "acctList", &(((ns10__RetAccountList*)a)->acctList), "ns9:AcctBasicInfo"))
				{	soap_flag_acctList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns10__RetAccountList *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns10__RetAccountList, 0, sizeof(ns10__RetAccountList), 0, soap_copy_ns10__RetAccountList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns10__RetAccountList * SOAP_FMAC6 soap_new_ns10__RetAccountList(struct soap *soap, int n)
{	return soap_instantiate_ns10__RetAccountList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns10__RetAccountList(struct soap *soap, ns10__RetAccountList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns10__RetAccountList * SOAP_FMAC4 soap_instantiate_ns10__RetAccountList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns10__RetAccountList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns10__RetAccountList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns10__RetAccountList;
		if (size)
			*size = sizeof(ns10__RetAccountList);
		((ns10__RetAccountList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns10__RetAccountList[n];
		if (size)
			*size = n * sizeof(ns10__RetAccountList);
		for (int i = 0; i < n; i++)
			((ns10__RetAccountList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns10__RetAccountList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns10__RetAccountList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns10__RetAccountList %p -> %p\n", q, p));
	*(ns10__RetAccountList*)p = *(ns10__RetAccountList*)q;
}

void ns9__AcctBasicInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns9__AcctBasicInfo*)this)->curBalance, SOAP_TYPE_double);
	soap_serialize_PointerToint(soap, &((ns9__AcctBasicInfo*)this)->feeType);
	soap_serialize_string(soap, &((ns9__AcctBasicInfo*)this)->fullName);
	soap_embedded(soap, &((ns9__AcctBasicInfo*)this)->state, SOAP_TYPE_int);
	soap_embedded(soap, &((ns9__AcctBasicInfo*)this)->userId, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &((ns9__AcctBasicInfo*)this)->userName);
	/* transient soap skipped */
}

void ns9__AcctBasicInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &((ns9__AcctBasicInfo*)this)->curBalance);
	((ns9__AcctBasicInfo*)this)->feeType = NULL;
	soap_default_string(soap, &((ns9__AcctBasicInfo*)this)->fullName);
	soap_default_int(soap, &((ns9__AcctBasicInfo*)this)->state);
	soap_default_LONG64(soap, &((ns9__AcctBasicInfo*)this)->userId);
	soap_default_string(soap, &((ns9__AcctBasicInfo*)this)->userName);
	/* transient soap skipped */
}

int ns9__AcctBasicInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns9__AcctBasicInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns9__AcctBasicInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns9__AcctBasicInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns9__AcctBasicInfo(struct soap *soap, const char *tag, int id, const ns9__AcctBasicInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns9__AcctBasicInfo), type);
	soap_out_double(soap, "curBalance", -1, &(((ns9__AcctBasicInfo*)a)->curBalance), "");
	soap_out_PointerToint(soap, "feeType", -1, &(((ns9__AcctBasicInfo*)a)->feeType), "");
	soap_out_string(soap, "fullName", -1, &(((ns9__AcctBasicInfo*)a)->fullName), "");
	soap_out_int(soap, "state", -1, &(((ns9__AcctBasicInfo*)a)->state), "");
	soap_out_LONG64(soap, "userId", -1, &(((ns9__AcctBasicInfo*)a)->userId), "");
	soap_out_string(soap, "userName", -1, &(((ns9__AcctBasicInfo*)a)->userName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns9__AcctBasicInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns9__AcctBasicInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns9__AcctBasicInfo * SOAP_FMAC4 soap_get_ns9__AcctBasicInfo(struct soap *soap, ns9__AcctBasicInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns9__AcctBasicInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns9__AcctBasicInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns9__AcctBasicInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns9__AcctBasicInfo * SOAP_FMAC4 soap_in_ns9__AcctBasicInfo(struct soap *soap, const char *tag, ns9__AcctBasicInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns9__AcctBasicInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns9__AcctBasicInfo, sizeof(ns9__AcctBasicInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns9__AcctBasicInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns9__AcctBasicInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_curBalance1 = 1, soap_flag_feeType1 = 1, soap_flag_fullName1 = 1, soap_flag_state1 = 1, soap_flag_userId1 = 1, soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_curBalance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "curBalance", &(((ns9__AcctBasicInfo*)a)->curBalance), "xsd:double"))
				{	soap_flag_curBalance1--;
					continue;
				}
			if (soap_flag_feeType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "feeType", &(((ns9__AcctBasicInfo*)a)->feeType), "xsd:int"))
				{	soap_flag_feeType1--;
					continue;
				}
			if (soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fullName", &(((ns9__AcctBasicInfo*)a)->fullName), "xsd:string"))
				{	soap_flag_fullName1--;
					continue;
				}
			if (soap_flag_state1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "state", &(((ns9__AcctBasicInfo*)a)->state), "xsd:int"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(((ns9__AcctBasicInfo*)a)->userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns9__AcctBasicInfo*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_curBalance1 > 0 || soap_flag_state1 > 0 || soap_flag_userId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns9__AcctBasicInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns9__AcctBasicInfo, 0, sizeof(ns9__AcctBasicInfo), 0, soap_copy_ns9__AcctBasicInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns9__AcctBasicInfo * SOAP_FMAC6 soap_new_ns9__AcctBasicInfo(struct soap *soap, int n)
{	return soap_instantiate_ns9__AcctBasicInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns9__AcctBasicInfo(struct soap *soap, ns9__AcctBasicInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns9__AcctBasicInfo * SOAP_FMAC4 soap_instantiate_ns9__AcctBasicInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns9__AcctBasicInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns9__AcctBasicInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns9__AcctBasicInfo;
		if (size)
			*size = sizeof(ns9__AcctBasicInfo);
		((ns9__AcctBasicInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns9__AcctBasicInfo[n];
		if (size)
			*size = n * sizeof(ns9__AcctBasicInfo);
		for (int i = 0; i < n; i++)
			((ns9__AcctBasicInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns9__AcctBasicInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns9__AcctBasicInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns9__AcctBasicInfo %p -> %p\n", q, p));
	*(ns9__AcctBasicInfo*)p = *(ns9__AcctBasicInfo*)q;
}

void ns8__RetUserInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &((ns8__RetUserInfo*)this)->accountType);
	soap_serialize_string(soap, &((ns8__RetUserInfo*)this)->address);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns8__RetUserInfo*)this)->appendColumnNames);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns8__RetUserInfo*)this)->appendColumnValues);
	soap_serialize_PointerTodouble(soap, &((ns8__RetUserInfo*)this)->curBalance);
	soap_serialize_string(soap, &((ns8__RetUserInfo*)this)->email);
	soap_serialize_PointerToint(soap, &((ns8__RetUserInfo*)this)->feeType);
	soap_serialize_string(soap, &((ns8__RetUserInfo*)this)->framedIp);
	soap_serialize_string(soap, &((ns8__RetUserInfo*)this)->fullName);
	soap_serialize_string(soap, &((ns8__RetUserInfo*)this)->idNumber);
	soap_serialize_PointerToLONG64(soap, &((ns8__RetUserInfo*)this)->idleTimeout);
	soap_serialize_PointerTotime(soap, &((ns8__RetUserInfo*)this)->invalidTime);
	soap_serialize_string(soap, &((ns8__RetUserInfo*)this)->macAddr);
	soap_serialize_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(soap, &((ns8__RetUserInfo*)this)->multiMacList);
	soap_serialize_string(soap, &((ns8__RetUserInfo*)this)->nasIp);
	soap_serialize_PointerToint(soap, &((ns8__RetUserInfo*)this)->nasPort);
	soap_serialize_PointerToint(soap, &((ns8__RetUserInfo*)this)->onlineLimit);
	soap_serialize_string(soap, &((ns8__RetUserInfo*)this)->promptInfo);
	soap_serialize_string(soap, &((ns8__RetUserInfo*)this)->state);
	soap_serialize_PointerToLONG64(soap, &((ns8__RetUserInfo*)this)->userId);
	soap_serialize_string(soap, &((ns8__RetUserInfo*)this)->userName);
	soap_serialize_PointerToint(soap, &((ns8__RetUserInfo*)this)->vlan);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns8__RetUserInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns8__RetUserInfo*)this)->accountType = NULL;
	soap_default_string(soap, &((ns8__RetUserInfo*)this)->address);
	((ns8__RetUserInfo*)this)->appendColumnNames = NULL;
	((ns8__RetUserInfo*)this)->appendColumnValues = NULL;
	((ns8__RetUserInfo*)this)->curBalance = NULL;
	soap_default_string(soap, &((ns8__RetUserInfo*)this)->email);
	((ns8__RetUserInfo*)this)->feeType = NULL;
	soap_default_string(soap, &((ns8__RetUserInfo*)this)->framedIp);
	soap_default_string(soap, &((ns8__RetUserInfo*)this)->fullName);
	soap_default_string(soap, &((ns8__RetUserInfo*)this)->idNumber);
	((ns8__RetUserInfo*)this)->idleTimeout = NULL;
	((ns8__RetUserInfo*)this)->invalidTime = NULL;
	soap_default_string(soap, &((ns8__RetUserInfo*)this)->macAddr);
	soap_default_bool(soap, &((ns8__RetUserInfo*)this)->multiIpMacBind);
	((ns8__RetUserInfo*)this)->multiMacList = NULL;
	soap_default_string(soap, &((ns8__RetUserInfo*)this)->nasIp);
	((ns8__RetUserInfo*)this)->nasPort = NULL;
	((ns8__RetUserInfo*)this)->onlineLimit = NULL;
	soap_default_bool(soap, &((ns8__RetUserInfo*)this)->onlineState);
	soap_default_string(soap, &((ns8__RetUserInfo*)this)->promptInfo);
	soap_default_string(soap, &((ns8__RetUserInfo*)this)->state);
	((ns8__RetUserInfo*)this)->userId = NULL;
	soap_default_string(soap, &((ns8__RetUserInfo*)this)->userName);
	((ns8__RetUserInfo*)this)->vlan = NULL;
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns8__RetUserInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns8__RetUserInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns8__RetUserInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns8__RetUserInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__RetUserInfo(struct soap *soap, const char *tag, int id, const ns8__RetUserInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__RetUserInfo), "ns8:RetUserInfo");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_PointerToint(soap, "accountType", -1, &(((ns8__RetUserInfo*)a)->accountType), "");
	soap_out_string(soap, "address", -1, &(((ns8__RetUserInfo*)a)->address), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "appendColumnNames", -1, &(((ns8__RetUserInfo*)a)->appendColumnNames), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "appendColumnValues", -1, &(((ns8__RetUserInfo*)a)->appendColumnValues), "");
	soap_out_PointerTodouble(soap, "curBalance", -1, &(((ns8__RetUserInfo*)a)->curBalance), "");
	soap_out_string(soap, "email", -1, &(((ns8__RetUserInfo*)a)->email), "");
	soap_out_PointerToint(soap, "feeType", -1, &(((ns8__RetUserInfo*)a)->feeType), "");
	soap_out_string(soap, "framedIp", -1, &(((ns8__RetUserInfo*)a)->framedIp), "");
	soap_out_string(soap, "fullName", -1, &(((ns8__RetUserInfo*)a)->fullName), "");
	soap_out_string(soap, "idNumber", -1, &(((ns8__RetUserInfo*)a)->idNumber), "");
	soap_out_PointerToLONG64(soap, "idleTimeout", -1, &(((ns8__RetUserInfo*)a)->idleTimeout), "");
	soap_out_PointerTotime(soap, "invalidTime", -1, &(((ns8__RetUserInfo*)a)->invalidTime), "");
	soap_out_string(soap, "macAddr", -1, &(((ns8__RetUserInfo*)a)->macAddr), "");
	soap_out_bool(soap, "multiIpMacBind", -1, &(((ns8__RetUserInfo*)a)->multiIpMacBind), "");
	soap_out_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(soap, "multiMacList", -1, &(((ns8__RetUserInfo*)a)->multiMacList), "");
	soap_out_string(soap, "nasIp", -1, &(((ns8__RetUserInfo*)a)->nasIp), "");
	soap_out_PointerToint(soap, "nasPort", -1, &(((ns8__RetUserInfo*)a)->nasPort), "");
	soap_out_PointerToint(soap, "onlineLimit", -1, &(((ns8__RetUserInfo*)a)->onlineLimit), "");
	soap_out_bool(soap, "onlineState", -1, &(((ns8__RetUserInfo*)a)->onlineState), "");
	soap_out_string(soap, "promptInfo", -1, &(((ns8__RetUserInfo*)a)->promptInfo), "");
	soap_out_string(soap, "state", -1, &(((ns8__RetUserInfo*)a)->state), "");
	soap_out_PointerToLONG64(soap, "userId", -1, &(((ns8__RetUserInfo*)a)->userId), "");
	soap_out_string(soap, "userName", -1, &(((ns8__RetUserInfo*)a)->userName), "");
	soap_out_PointerToint(soap, "vlan", -1, &(((ns8__RetUserInfo*)a)->vlan), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns8__RetUserInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns8__RetUserInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns8__RetUserInfo * SOAP_FMAC4 soap_get_ns8__RetUserInfo(struct soap *soap, ns8__RetUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns8__RetUserInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns8__RetUserInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns8__RetUserInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns8__RetUserInfo * SOAP_FMAC4 soap_in_ns8__RetUserInfo(struct soap *soap, const char *tag, ns8__RetUserInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns8__RetUserInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__RetUserInfo, sizeof(ns8__RetUserInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns8__RetUserInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns8__RetUserInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_accountType1 = 1, soap_flag_address1 = 1, soap_flag_appendColumnNames1 = 1, soap_flag_appendColumnValues1 = 1, soap_flag_curBalance1 = 1, soap_flag_email1 = 1, soap_flag_feeType1 = 1, soap_flag_framedIp1 = 1, soap_flag_fullName1 = 1, soap_flag_idNumber1 = 1, soap_flag_idleTimeout1 = 1, soap_flag_invalidTime1 = 1, soap_flag_macAddr1 = 1, soap_flag_multiIpMacBind1 = 1, soap_flag_multiMacList1 = 1, soap_flag_nasIp1 = 1, soap_flag_nasPort1 = 1, soap_flag_onlineLimit1 = 1, soap_flag_onlineState1 = 1, soap_flag_promptInfo1 = 1, soap_flag_state1 = 1, soap_flag_userId1 = 1, soap_flag_userName1 = 1, soap_flag_vlan1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_accountType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "accountType", &(((ns8__RetUserInfo*)a)->accountType), "xsd:int"))
				{	soap_flag_accountType1--;
					continue;
				}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "address", &(((ns8__RetUserInfo*)a)->address), "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_appendColumnNames1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "appendColumnNames", &(((ns8__RetUserInfo*)a)->appendColumnNames), "xsd:string"))
				{	soap_flag_appendColumnNames1--;
					continue;
				}
			if (soap_flag_appendColumnValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "appendColumnValues", &(((ns8__RetUserInfo*)a)->appendColumnValues), "xsd:string"))
				{	soap_flag_appendColumnValues1--;
					continue;
				}
			if (soap_flag_curBalance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "curBalance", &(((ns8__RetUserInfo*)a)->curBalance), "xsd:double"))
				{	soap_flag_curBalance1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email", &(((ns8__RetUserInfo*)a)->email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_feeType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "feeType", &(((ns8__RetUserInfo*)a)->feeType), "xsd:int"))
				{	soap_flag_feeType1--;
					continue;
				}
			if (soap_flag_framedIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "framedIp", &(((ns8__RetUserInfo*)a)->framedIp), "xsd:string"))
				{	soap_flag_framedIp1--;
					continue;
				}
			if (soap_flag_fullName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fullName", &(((ns8__RetUserInfo*)a)->fullName), "xsd:string"))
				{	soap_flag_fullName1--;
					continue;
				}
			if (soap_flag_idNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "idNumber", &(((ns8__RetUserInfo*)a)->idNumber), "xsd:string"))
				{	soap_flag_idNumber1--;
					continue;
				}
			if (soap_flag_idleTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "idleTimeout", &(((ns8__RetUserInfo*)a)->idleTimeout), "xsd:long"))
				{	soap_flag_idleTimeout1--;
					continue;
				}
			if (soap_flag_invalidTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "invalidTime", &(((ns8__RetUserInfo*)a)->invalidTime), "xsd:dateTime"))
				{	soap_flag_invalidTime1--;
					continue;
				}
			if (soap_flag_macAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "macAddr", &(((ns8__RetUserInfo*)a)->macAddr), "xsd:string"))
				{	soap_flag_macAddr1--;
					continue;
				}
			if (soap_flag_multiIpMacBind1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "multiIpMacBind", &(((ns8__RetUserInfo*)a)->multiIpMacBind), "xsd:boolean"))
				{	soap_flag_multiIpMacBind1--;
					continue;
				}
			if (soap_flag_multiMacList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(soap, "multiMacList", &(((ns8__RetUserInfo*)a)->multiMacList), "xsd:string[]"))
				{	soap_flag_multiMacList1--;
					continue;
				}
			if (soap_flag_nasIp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "nasIp", &(((ns8__RetUserInfo*)a)->nasIp), "xsd:string"))
				{	soap_flag_nasIp1--;
					continue;
				}
			if (soap_flag_nasPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "nasPort", &(((ns8__RetUserInfo*)a)->nasPort), "xsd:int"))
				{	soap_flag_nasPort1--;
					continue;
				}
			if (soap_flag_onlineLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "onlineLimit", &(((ns8__RetUserInfo*)a)->onlineLimit), "xsd:int"))
				{	soap_flag_onlineLimit1--;
					continue;
				}
			if (soap_flag_onlineState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "onlineState", &(((ns8__RetUserInfo*)a)->onlineState), "xsd:boolean"))
				{	soap_flag_onlineState1--;
					continue;
				}
			if (soap_flag_promptInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "promptInfo", &(((ns8__RetUserInfo*)a)->promptInfo), "xsd:string"))
				{	soap_flag_promptInfo1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "state", &(((ns8__RetUserInfo*)a)->state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "userId", &(((ns8__RetUserInfo*)a)->userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns8__RetUserInfo*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_vlan1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "vlan", &(((ns8__RetUserInfo*)a)->vlan), "xsd:int"))
				{	soap_flag_vlan1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0 || soap_flag_multiIpMacBind1 > 0 || soap_flag_onlineState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns8__RetUserInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns8__RetUserInfo, 0, sizeof(ns8__RetUserInfo), 0, soap_copy_ns8__RetUserInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns8__RetUserInfo * SOAP_FMAC6 soap_new_ns8__RetUserInfo(struct soap *soap, int n)
{	return soap_instantiate_ns8__RetUserInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns8__RetUserInfo(struct soap *soap, ns8__RetUserInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns8__RetUserInfo * SOAP_FMAC4 soap_instantiate_ns8__RetUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns8__RetUserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns8__RetUserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns8__RetUserInfo;
		if (size)
			*size = sizeof(ns8__RetUserInfo);
		((ns8__RetUserInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns8__RetUserInfo[n];
		if (size)
			*size = n * sizeof(ns8__RetUserInfo);
		for (int i = 0; i < n; i++)
			((ns8__RetUserInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns8__RetUserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns8__RetUserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns8__RetUserInfo %p -> %p\n", q, p));
	*(ns8__RetUserInfo*)p = *(ns8__RetUserInfo*)q;
}

void ns7__MultiResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns7__MultiResult*)this)->columnCount, SOAP_TYPE_int);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns7__MultiResult*)this)->columnNames);
	soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &((ns7__MultiResult*)this)->columnTypes);
	soap_embedded(soap, &((ns7__MultiResult*)this)->recordCount, SOAP_TYPE_int);
	soap_serialize_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(soap, &((ns7__MultiResult*)this)->resultValues);
	soap_embedded(soap, &((ns7__MultiResult*)this)->totalRecordCount, SOAP_TYPE_int);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns7__MultiResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((ns7__MultiResult*)this)->columnCount);
	((ns7__MultiResult*)this)->columnNames = NULL;
	((ns7__MultiResult*)this)->columnTypes = NULL;
	soap_default_int(soap, &((ns7__MultiResult*)this)->recordCount);
	((ns7__MultiResult*)this)->resultValues = NULL;
	soap_default_int(soap, &((ns7__MultiResult*)this)->totalRecordCount);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns7__MultiResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns7__MultiResult);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns7__MultiResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns7__MultiResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__MultiResult(struct soap *soap, const char *tag, int id, const ns7__MultiResult *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__MultiResult), "ns7:MultiResult");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_int(soap, "columnCount", -1, &(((ns7__MultiResult*)a)->columnCount), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "columnNames", -1, &(((ns7__MultiResult*)a)->columnNames), "");
	soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "columnTypes", -1, &(((ns7__MultiResult*)a)->columnTypes), "");
	soap_out_int(soap, "recordCount", -1, &(((ns7__MultiResult*)a)->recordCount), "");
	soap_out_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(soap, "resultValues", -1, &(((ns7__MultiResult*)a)->resultValues), "");
	soap_out_int(soap, "totalRecordCount", -1, &(((ns7__MultiResult*)a)->totalRecordCount), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns7__MultiResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns7__MultiResult(soap, this, tag, type);
}

SOAP_FMAC3 ns7__MultiResult * SOAP_FMAC4 soap_get_ns7__MultiResult(struct soap *soap, ns7__MultiResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__MultiResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns7__MultiResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns7__MultiResult(soap, tag, this, type);
}

SOAP_FMAC3 ns7__MultiResult * SOAP_FMAC4 soap_in_ns7__MultiResult(struct soap *soap, const char *tag, ns7__MultiResult *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns7__MultiResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__MultiResult, sizeof(ns7__MultiResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns7__MultiResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns7__MultiResult *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_columnCount1 = 1, soap_flag_columnNames1 = 1, soap_flag_columnTypes1 = 1, soap_flag_recordCount1 = 1, soap_flag_resultValues1 = 1, soap_flag_totalRecordCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_columnCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "columnCount", &(((ns7__MultiResult*)a)->columnCount), "xsd:int"))
				{	soap_flag_columnCount1--;
					continue;
				}
			if (soap_flag_columnNames1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "columnNames", &(((ns7__MultiResult*)a)->columnNames), "xsd:string"))
				{	soap_flag_columnNames1--;
					continue;
				}
			if (soap_flag_columnTypes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "columnTypes", &(((ns7__MultiResult*)a)->columnTypes), "xsd:string"))
				{	soap_flag_columnTypes1--;
					continue;
				}
			if (soap_flag_recordCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "recordCount", &(((ns7__MultiResult*)a)->recordCount), "xsd:int"))
				{	soap_flag_recordCount1--;
					continue;
				}
			if (soap_flag_resultValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(soap, "resultValues", &(((ns7__MultiResult*)a)->resultValues), "xsd:string[]"))
				{	soap_flag_resultValues1--;
					continue;
				}
			if (soap_flag_totalRecordCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "totalRecordCount", &(((ns7__MultiResult*)a)->totalRecordCount), "xsd:int"))
				{	soap_flag_totalRecordCount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0 || soap_flag_columnCount1 > 0 || soap_flag_recordCount1 > 0 || soap_flag_totalRecordCount1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns7__MultiResult *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns7__MultiResult, 0, sizeof(ns7__MultiResult), 0, soap_copy_ns7__MultiResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns7__MultiResult * SOAP_FMAC6 soap_new_ns7__MultiResult(struct soap *soap, int n)
{	return soap_instantiate_ns7__MultiResult(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns7__MultiResult(struct soap *soap, ns7__MultiResult *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns7__MultiResult * SOAP_FMAC4 soap_instantiate_ns7__MultiResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns7__MultiResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns7__MultiResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns7__MultiResult;
		if (size)
			*size = sizeof(ns7__MultiResult);
		((ns7__MultiResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns7__MultiResult[n];
		if (size)
			*size = n * sizeof(ns7__MultiResult);
		for (int i = 0; i < n; i++)
			((ns7__MultiResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns7__MultiResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns7__MultiResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns7__MultiResult %p -> %p\n", q, p));
	*(ns7__MultiResult*)p = *(ns7__MultiResult*)q;
}

void ns6__RandomInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &((ns6__RandomInfo*)this)->random);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns6__RandomInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns6__RandomInfo*)this)->random);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns6__RandomInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__RandomInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns6__RandomInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__RandomInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__RandomInfo(struct soap *soap, const char *tag, int id, const ns6__RandomInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__RandomInfo), "ns6:RandomInfo");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_string(soap, "random", -1, &(((ns6__RandomInfo*)a)->random), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns6__RandomInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__RandomInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns6__RandomInfo * SOAP_FMAC4 soap_get_ns6__RandomInfo(struct soap *soap, ns6__RandomInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__RandomInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns6__RandomInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__RandomInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns6__RandomInfo * SOAP_FMAC4 soap_in_ns6__RandomInfo(struct soap *soap, const char *tag, ns6__RandomInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__RandomInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__RandomInfo, sizeof(ns6__RandomInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__RandomInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__RandomInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_random1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_random1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "random", &(((ns6__RandomInfo*)a)->random), "xsd:string"))
				{	soap_flag_random1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__RandomInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns6__RandomInfo, 0, sizeof(ns6__RandomInfo), 0, soap_copy_ns6__RandomInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns6__RandomInfo * SOAP_FMAC6 soap_new_ns6__RandomInfo(struct soap *soap, int n)
{	return soap_instantiate_ns6__RandomInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__RandomInfo(struct soap *soap, ns6__RandomInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns6__RandomInfo * SOAP_FMAC4 soap_instantiate_ns6__RandomInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__RandomInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__RandomInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns6__RandomInfo;
		if (size)
			*size = sizeof(ns6__RandomInfo);
		((ns6__RandomInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns6__RandomInfo[n];
		if (size)
			*size = n * sizeof(ns6__RandomInfo);
		for (int i = 0; i < n; i++)
			((ns6__RandomInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__RandomInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__RandomInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__RandomInfo %p -> %p\n", q, p));
	*(ns6__RandomInfo*)p = *(ns6__RandomInfo*)q;
}

void ns5__LanAccessDetailList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, &((ns5__LanAccessDetailList*)this)->details);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns5__LanAccessDetailList::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns5__LanAccessDetailList*)this)->details = NULL;
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns5__LanAccessDetailList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__LanAccessDetailList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__LanAccessDetailList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__LanAccessDetailList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__LanAccessDetailList(struct soap *soap, const char *tag, int id, const ns5__LanAccessDetailList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__LanAccessDetailList), "ns5:LanAccessDetailList");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, "details", -1, &(((ns5__LanAccessDetailList*)a)->details), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns5__LanAccessDetailList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__LanAccessDetailList(soap, this, tag, type);
}

SOAP_FMAC3 ns5__LanAccessDetailList * SOAP_FMAC4 soap_get_ns5__LanAccessDetailList(struct soap *soap, ns5__LanAccessDetailList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__LanAccessDetailList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns5__LanAccessDetailList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__LanAccessDetailList(soap, tag, this, type);
}

SOAP_FMAC3 ns5__LanAccessDetailList * SOAP_FMAC4 soap_in_ns5__LanAccessDetailList(struct soap *soap, const char *tag, ns5__LanAccessDetailList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__LanAccessDetailList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__LanAccessDetailList, sizeof(ns5__LanAccessDetailList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__LanAccessDetailList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__LanAccessDetailList *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_details1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_details1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, "details", &(((ns5__LanAccessDetailList*)a)->details), "ns4:LanAccessDetailInfo"))
				{	soap_flag_details1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__LanAccessDetailList *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns5__LanAccessDetailList, 0, sizeof(ns5__LanAccessDetailList), 0, soap_copy_ns5__LanAccessDetailList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns5__LanAccessDetailList * SOAP_FMAC6 soap_new_ns5__LanAccessDetailList(struct soap *soap, int n)
{	return soap_instantiate_ns5__LanAccessDetailList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns5__LanAccessDetailList(struct soap *soap, ns5__LanAccessDetailList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns5__LanAccessDetailList * SOAP_FMAC4 soap_instantiate_ns5__LanAccessDetailList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__LanAccessDetailList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__LanAccessDetailList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__LanAccessDetailList;
		if (size)
			*size = sizeof(ns5__LanAccessDetailList);
		((ns5__LanAccessDetailList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__LanAccessDetailList[n];
		if (size)
			*size = n * sizeof(ns5__LanAccessDetailList);
		for (int i = 0; i < n; i++)
			((ns5__LanAccessDetailList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__LanAccessDetailList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__LanAccessDetailList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__LanAccessDetailList %p -> %p\n", q, p));
	*(ns5__LanAccessDetailList*)p = *(ns5__LanAccessDetailList*)q;
}

void ArrayOf_USCOREtns25_USCOREApplyServiceInfo::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons25__ApplyServiceInfo(soap, this->__ptr + i);
		}
}

void ArrayOf_USCOREtns25_USCOREApplyServiceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOf_USCOREtns25_USCOREApplyServiceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns25_USCOREApplyServiceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns25_USCOREApplyServiceInfo *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns25:ApplyServiceInfo", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons25__ApplyServiceInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOf_USCOREtns25_USCOREApplyServiceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns25_USCOREApplyServiceInfo * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(struct soap *soap, ArrayOf_USCOREtns25_USCOREApplyServiceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOf_USCOREtns25_USCOREApplyServiceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns25_USCOREApplyServiceInfo * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns25_USCOREApplyServiceInfo *a, const char *type)
{	int i, j;
	ns25__ApplyServiceInfo **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns25_USCOREApplyServiceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo, sizeof(ArrayOf_USCOREtns25_USCOREApplyServiceInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns25__ApplyServiceInfo **)soap_malloc(soap, sizeof(ns25__ApplyServiceInfo *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons25__ApplyServiceInfo(soap, NULL, a->__ptr + i, "ns25:ApplyServiceInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns25__ApplyServiceInfo **)soap_push_block(soap, sizeof(ns25__ApplyServiceInfo *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons25__ApplyServiceInfo(soap, NULL, p, "ns25:ApplyServiceInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns25__ApplyServiceInfo **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns25_USCOREApplyServiceInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo, 0, sizeof(ArrayOf_USCOREtns25_USCOREApplyServiceInfo), 0, soap_copy_ArrayOf_USCOREtns25_USCOREApplyServiceInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns25_USCOREApplyServiceInfo * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(struct soap *soap, ArrayOf_USCOREtns25_USCOREApplyServiceInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns25_USCOREApplyServiceInfo * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns25_USCOREApplyServiceInfo;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns25_USCOREApplyServiceInfo);
		((ArrayOf_USCOREtns25_USCOREApplyServiceInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns25_USCOREApplyServiceInfo[n];
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns25_USCOREApplyServiceInfo);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns25_USCOREApplyServiceInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns25_USCOREApplyServiceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns25_USCOREApplyServiceInfo %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns25_USCOREApplyServiceInfo*)p = *(ArrayOf_USCOREtns25_USCOREApplyServiceInfo*)q;
}

void ArrayOf_USCOREtns19_USCORELanServiceInfo::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons18__LanServiceInfo(soap, this->__ptr + i);
		}
}

void ArrayOf_USCOREtns19_USCORELanServiceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOf_USCOREtns19_USCORELanServiceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns19_USCORELanServiceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns19_USCORELanServiceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns19_USCORELanServiceInfo(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns19_USCORELanServiceInfo *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns18:LanServiceInfo", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons18__LanServiceInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOf_USCOREtns19_USCORELanServiceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns19_USCORELanServiceInfo(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns19_USCORELanServiceInfo * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns19_USCORELanServiceInfo(struct soap *soap, ArrayOf_USCOREtns19_USCORELanServiceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns19_USCORELanServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOf_USCOREtns19_USCORELanServiceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns19_USCORELanServiceInfo(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns19_USCORELanServiceInfo * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns19_USCORELanServiceInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns19_USCORELanServiceInfo *a, const char *type)
{	int i, j;
	ns18__LanServiceInfo **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns19_USCORELanServiceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo, sizeof(ArrayOf_USCOREtns19_USCORELanServiceInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns18__LanServiceInfo **)soap_malloc(soap, sizeof(ns18__LanServiceInfo *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons18__LanServiceInfo(soap, NULL, a->__ptr + i, "ns18:LanServiceInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns18__LanServiceInfo **)soap_push_block(soap, sizeof(ns18__LanServiceInfo *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons18__LanServiceInfo(soap, NULL, p, "ns18:LanServiceInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns18__LanServiceInfo **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns19_USCORELanServiceInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo, 0, sizeof(ArrayOf_USCOREtns19_USCORELanServiceInfo), 0, soap_copy_ArrayOf_USCOREtns19_USCORELanServiceInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns19_USCORELanServiceInfo * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns19_USCORELanServiceInfo(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns19_USCORELanServiceInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns19_USCORELanServiceInfo(struct soap *soap, ArrayOf_USCOREtns19_USCORELanServiceInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns19_USCORELanServiceInfo * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns19_USCORELanServiceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns19_USCORELanServiceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns19_USCORELanServiceInfo;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns19_USCORELanServiceInfo);
		((ArrayOf_USCOREtns19_USCORELanServiceInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns19_USCORELanServiceInfo[n];
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns19_USCORELanServiceInfo);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns19_USCORELanServiceInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns19_USCORELanServiceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns19_USCORELanServiceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns19_USCORELanServiceInfo %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns19_USCORELanServiceInfo*)p = *(ArrayOf_USCOREtns19_USCORELanServiceInfo*)q;
}

void ArrayOf_USCOREtns17_USCOREBlackListInfo::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons16__BlackListInfo(soap, this->__ptr + i);
		}
}

void ArrayOf_USCOREtns17_USCOREBlackListInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOf_USCOREtns17_USCOREBlackListInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns17_USCOREBlackListInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns17_USCOREBlackListInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns17_USCOREBlackListInfo(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns17_USCOREBlackListInfo *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns16:BlackListInfo", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons16__BlackListInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOf_USCOREtns17_USCOREBlackListInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns17_USCOREBlackListInfo(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns17_USCOREBlackListInfo * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns17_USCOREBlackListInfo(struct soap *soap, ArrayOf_USCOREtns17_USCOREBlackListInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns17_USCOREBlackListInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOf_USCOREtns17_USCOREBlackListInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns17_USCOREBlackListInfo(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns17_USCOREBlackListInfo * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns17_USCOREBlackListInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns17_USCOREBlackListInfo *a, const char *type)
{	int i, j;
	ns16__BlackListInfo **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns17_USCOREBlackListInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo, sizeof(ArrayOf_USCOREtns17_USCOREBlackListInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns16__BlackListInfo **)soap_malloc(soap, sizeof(ns16__BlackListInfo *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons16__BlackListInfo(soap, NULL, a->__ptr + i, "ns16:BlackListInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns16__BlackListInfo **)soap_push_block(soap, sizeof(ns16__BlackListInfo *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons16__BlackListInfo(soap, NULL, p, "ns16:BlackListInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns16__BlackListInfo **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns17_USCOREBlackListInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo, 0, sizeof(ArrayOf_USCOREtns17_USCOREBlackListInfo), 0, soap_copy_ArrayOf_USCOREtns17_USCOREBlackListInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns17_USCOREBlackListInfo * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns17_USCOREBlackListInfo(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns17_USCOREBlackListInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns17_USCOREBlackListInfo(struct soap *soap, ArrayOf_USCOREtns17_USCOREBlackListInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns17_USCOREBlackListInfo * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns17_USCOREBlackListInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns17_USCOREBlackListInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns17_USCOREBlackListInfo;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns17_USCOREBlackListInfo);
		((ArrayOf_USCOREtns17_USCOREBlackListInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns17_USCOREBlackListInfo[n];
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns17_USCOREBlackListInfo);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns17_USCOREBlackListInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns17_USCOREBlackListInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns17_USCOREBlackListInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns17_USCOREBlackListInfo %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns17_USCOREBlackListInfo*)p = *(ArrayOf_USCOREtns17_USCOREBlackListInfo*)q;
}

void ArrayOf_USCOREtns15_USCOREUserAppendInfo::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons14__UserAppendInfo(soap, this->__ptr + i);
		}
}

void ArrayOf_USCOREtns15_USCOREUserAppendInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOf_USCOREtns15_USCOREUserAppendInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns15_USCOREUserAppendInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns15_USCOREUserAppendInfo(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns15_USCOREUserAppendInfo *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns14:UserAppendInfo", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons14__UserAppendInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOf_USCOREtns15_USCOREUserAppendInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns15_USCOREUserAppendInfo * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns15_USCOREUserAppendInfo(struct soap *soap, ArrayOf_USCOREtns15_USCOREUserAppendInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOf_USCOREtns15_USCOREUserAppendInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns15_USCOREUserAppendInfo * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns15_USCOREUserAppendInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns15_USCOREUserAppendInfo *a, const char *type)
{	int i, j;
	ns14__UserAppendInfo **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns15_USCOREUserAppendInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo, sizeof(ArrayOf_USCOREtns15_USCOREUserAppendInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns14__UserAppendInfo **)soap_malloc(soap, sizeof(ns14__UserAppendInfo *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons14__UserAppendInfo(soap, NULL, a->__ptr + i, "ns14:UserAppendInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns14__UserAppendInfo **)soap_push_block(soap, sizeof(ns14__UserAppendInfo *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons14__UserAppendInfo(soap, NULL, p, "ns14:UserAppendInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns14__UserAppendInfo **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns15_USCOREUserAppendInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo, 0, sizeof(ArrayOf_USCOREtns15_USCOREUserAppendInfo), 0, soap_copy_ArrayOf_USCOREtns15_USCOREUserAppendInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns15_USCOREUserAppendInfo * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns15_USCOREUserAppendInfo(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns15_USCOREUserAppendInfo(struct soap *soap, ArrayOf_USCOREtns15_USCOREUserAppendInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns15_USCOREUserAppendInfo * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns15_USCOREUserAppendInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns15_USCOREUserAppendInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns15_USCOREUserAppendInfo;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns15_USCOREUserAppendInfo);
		((ArrayOf_USCOREtns15_USCOREUserAppendInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns15_USCOREUserAppendInfo[n];
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns15_USCOREUserAppendInfo);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns15_USCOREUserAppendInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns15_USCOREUserAppendInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns15_USCOREUserAppendInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns15_USCOREUserAppendInfo %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns15_USCOREUserAppendInfo*)p = *(ArrayOf_USCOREtns15_USCOREUserAppendInfo*)q;
}

void ArrayOf_USCOREtns13_USCOREAcctServiceInfo::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons12__AcctServiceInfo(soap, this->__ptr + i);
		}
}

void ArrayOf_USCOREtns13_USCOREAcctServiceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOf_USCOREtns13_USCOREAcctServiceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns13_USCOREAcctServiceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns13_USCOREAcctServiceInfo *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns12:AcctServiceInfo", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons12__AcctServiceInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOf_USCOREtns13_USCOREAcctServiceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns13_USCOREAcctServiceInfo * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(struct soap *soap, ArrayOf_USCOREtns13_USCOREAcctServiceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOf_USCOREtns13_USCOREAcctServiceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns13_USCOREAcctServiceInfo * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns13_USCOREAcctServiceInfo *a, const char *type)
{	int i, j;
	ns12__AcctServiceInfo **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns13_USCOREAcctServiceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo, sizeof(ArrayOf_USCOREtns13_USCOREAcctServiceInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns12__AcctServiceInfo **)soap_malloc(soap, sizeof(ns12__AcctServiceInfo *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons12__AcctServiceInfo(soap, NULL, a->__ptr + i, "ns12:AcctServiceInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns12__AcctServiceInfo **)soap_push_block(soap, sizeof(ns12__AcctServiceInfo *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons12__AcctServiceInfo(soap, NULL, p, "ns12:AcctServiceInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns12__AcctServiceInfo **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns13_USCOREAcctServiceInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo, 0, sizeof(ArrayOf_USCOREtns13_USCOREAcctServiceInfo), 0, soap_copy_ArrayOf_USCOREtns13_USCOREAcctServiceInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns13_USCOREAcctServiceInfo * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(struct soap *soap, ArrayOf_USCOREtns13_USCOREAcctServiceInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns13_USCOREAcctServiceInfo * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns13_USCOREAcctServiceInfo;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns13_USCOREAcctServiceInfo);
		((ArrayOf_USCOREtns13_USCOREAcctServiceInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns13_USCOREAcctServiceInfo[n];
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns13_USCOREAcctServiceInfo);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns13_USCOREAcctServiceInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns13_USCOREAcctServiceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns13_USCOREAcctServiceInfo %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns13_USCOREAcctServiceInfo*)p = *(ArrayOf_USCOREtns13_USCOREAcctServiceInfo*)q;
}

void ArrayOf_USCOREtns10_USCOREAcctBasicInfo::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons9__AcctBasicInfo(soap, this->__ptr + i);
		}
}

void ArrayOf_USCOREtns10_USCOREAcctBasicInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOf_USCOREtns10_USCOREAcctBasicInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns10_USCOREAcctBasicInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns10_USCOREAcctBasicInfo *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns9:AcctBasicInfo", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons9__AcctBasicInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOf_USCOREtns10_USCOREAcctBasicInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns10_USCOREAcctBasicInfo * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(struct soap *soap, ArrayOf_USCOREtns10_USCOREAcctBasicInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOf_USCOREtns10_USCOREAcctBasicInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns10_USCOREAcctBasicInfo * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns10_USCOREAcctBasicInfo *a, const char *type)
{	int i, j;
	ns9__AcctBasicInfo **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns10_USCOREAcctBasicInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo, sizeof(ArrayOf_USCOREtns10_USCOREAcctBasicInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns9__AcctBasicInfo **)soap_malloc(soap, sizeof(ns9__AcctBasicInfo *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons9__AcctBasicInfo(soap, NULL, a->__ptr + i, "ns9:AcctBasicInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns9__AcctBasicInfo **)soap_push_block(soap, sizeof(ns9__AcctBasicInfo *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons9__AcctBasicInfo(soap, NULL, p, "ns9:AcctBasicInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns9__AcctBasicInfo **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns10_USCOREAcctBasicInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo, 0, sizeof(ArrayOf_USCOREtns10_USCOREAcctBasicInfo), 0, soap_copy_ArrayOf_USCOREtns10_USCOREAcctBasicInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns10_USCOREAcctBasicInfo * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(struct soap *soap, ArrayOf_USCOREtns10_USCOREAcctBasicInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns10_USCOREAcctBasicInfo * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns10_USCOREAcctBasicInfo;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns10_USCOREAcctBasicInfo);
		((ArrayOf_USCOREtns10_USCOREAcctBasicInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns10_USCOREAcctBasicInfo[n];
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns10_USCOREAcctBasicInfo);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns10_USCOREAcctBasicInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns10_USCOREAcctBasicInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns10_USCOREAcctBasicInfo %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns10_USCOREAcctBasicInfo*)p = *(ArrayOf_USCOREtns10_USCOREAcctBasicInfo*)q;
}

void ArrayOfArrayOf_USCORExsd_USCOREstring::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE__Struct_1);
			this->__ptr[i].soap_serialize(soap);
		}
}

void ArrayOfArrayOf_USCORExsd_USCOREstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOfArrayOf_USCORExsd_USCOREstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfArrayOf_USCORExsd_USCOREstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfArrayOf_USCORExsd_USCOREstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, int id, const ArrayOfArrayOf_USCORExsd_USCOREstring *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string[]", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		a->__ptr[i].soap_out(soap, "item", -1, "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfArrayOf_USCORExsd_USCOREstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfArrayOf_USCORExsd_USCOREstring(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_get_ArrayOfArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOfArrayOf_USCORExsd_USCOREstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfArrayOf_USCORExsd_USCOREstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfArrayOf_USCORExsd_USCOREstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfArrayOf_USCORExsd_USCOREstring(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_in_ArrayOfArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, ArrayOfArrayOf_USCORExsd_USCOREstring *a, const char *type)
{	int i, j;
	_Struct_1 *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfArrayOf_USCORExsd_USCOREstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring, sizeof(ArrayOfArrayOf_USCORExsd_USCOREstring), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new__Struct_1(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->_Struct_1::soap_default(soap);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in__Struct_1(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	_Struct_1 q;
			soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (_Struct_1 *)soap_push_block(soap, sizeof(_Struct_1));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(_Struct_1));
				p->soap_default(soap);
				if (!soap_in__Struct_1(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			if (soap->blist->size)
				a->__ptr = soap_new__Struct_1(soap, soap->blist->size/sizeof(_Struct_1));
			else
				a->__ptr = NULL;
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfArrayOf_USCORExsd_USCOREstring *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring, 0, sizeof(ArrayOfArrayOf_USCORExsd_USCOREstring), 0, soap_copy_ArrayOfArrayOf_USCORExsd_USCOREstring);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfArrayOf_USCORExsd_USCOREstring * SOAP_FMAC6 soap_new_ArrayOfArrayOf_USCORExsd_USCOREstring(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfArrayOf_USCORExsd_USCOREstring(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOfArrayOf_USCORExsd_USCOREstring *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_instantiate_ArrayOfArrayOf_USCORExsd_USCOREstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfArrayOf_USCORExsd_USCOREstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfArrayOf_USCORExsd_USCOREstring;
		if (size)
			*size = sizeof(ArrayOfArrayOf_USCORExsd_USCOREstring);
		((ArrayOfArrayOf_USCORExsd_USCOREstring*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfArrayOf_USCORExsd_USCOREstring[n];
		if (size)
			*size = n * sizeof(ArrayOfArrayOf_USCORExsd_USCOREstring);
		for (int i = 0; i < n; i++)
			((ArrayOfArrayOf_USCORExsd_USCOREstring*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfArrayOf_USCORExsd_USCOREstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfArrayOf_USCORExsd_USCOREstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfArrayOf_USCORExsd_USCOREstring %p -> %p\n", q, p));
	*(ArrayOfArrayOf_USCORExsd_USCOREstring*)p = *(ArrayOfArrayOf_USCORExsd_USCOREstring*)q;
}

void ArrayOf_USCORExsd_USCOREstring::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_string(soap, this->__ptr + i);
		}
}

void ArrayOf_USCORExsd_USCOREstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOf_USCORExsd_USCOREstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCORExsd_USCOREstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCORExsd_USCOREstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, int id, const ArrayOf_USCORExsd_USCOREstring *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOf_USCORExsd_USCOREstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCORExsd_USCOREstring(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_get_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCORExsd_USCOREstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOf_USCORExsd_USCOREstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCORExsd_USCOREstring(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_in_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, ArrayOf_USCORExsd_USCOREstring *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCORExsd_USCOREstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring, sizeof(ArrayOf_USCORExsd_USCOREstring), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCORExsd_USCOREstring *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring, 0, sizeof(ArrayOf_USCORExsd_USCOREstring), 0, soap_copy_ArrayOf_USCORExsd_USCOREstring);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC6 soap_new_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCORExsd_USCOREstring(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_instantiate_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCORExsd_USCOREstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCORExsd_USCOREstring;
		if (size)
			*size = sizeof(ArrayOf_USCORExsd_USCOREstring);
		((ArrayOf_USCORExsd_USCOREstring*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCORExsd_USCOREstring[n];
		if (size)
			*size = n * sizeof(ArrayOf_USCORExsd_USCOREstring);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCORExsd_USCOREstring*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCORExsd_USCOREstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCORExsd_USCOREstring %p -> %p\n", q, p));
	*(ArrayOf_USCORExsd_USCOREstring*)p = *(ArrayOf_USCORExsd_USCOREstring*)q;
}

void ArrayOf_USCOREtns5_USCORELanAccessDetailInfo::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons4__LanAccessDetailInfo(soap, this->__ptr + i);
		}
}

void ArrayOf_USCOREtns5_USCORELanAccessDetailInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

int ArrayOf_USCOREtns5_USCORELanAccessDetailInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns5_USCORELanAccessDetailInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns4:LanAccessDetailInfo", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons4__LanAccessDetailInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOf_USCOREtns5_USCORELanAccessDetailInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns5_USCORELanAccessDetailInfo * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(struct soap *soap, ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOf_USCOREtns5_USCORELanAccessDetailInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns5_USCORELanAccessDetailInfo * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *a, const char *type)
{	int i, j;
	ns4__LanAccessDetailInfo **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo, sizeof(ArrayOf_USCOREtns5_USCORELanAccessDetailInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns4__LanAccessDetailInfo **)soap_malloc(soap, sizeof(ns4__LanAccessDetailInfo *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons4__LanAccessDetailInfo(soap, NULL, a->__ptr + i, "ns4:LanAccessDetailInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns4__LanAccessDetailInfo **)soap_push_block(soap, sizeof(ns4__LanAccessDetailInfo *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons4__LanAccessDetailInfo(soap, NULL, p, "ns4:LanAccessDetailInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns4__LanAccessDetailInfo **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo, 0, sizeof(ArrayOf_USCOREtns5_USCORELanAccessDetailInfo), 0, soap_copy_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns5_USCORELanAccessDetailInfo * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(struct soap *soap, ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns5_USCORELanAccessDetailInfo * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns5_USCORELanAccessDetailInfo;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns5_USCORELanAccessDetailInfo);
		((ArrayOf_USCOREtns5_USCORELanAccessDetailInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns5_USCORELanAccessDetailInfo[n];
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns5_USCORELanAccessDetailInfo);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns5_USCORELanAccessDetailInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns5_USCORELanAccessDetailInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns5_USCORELanAccessDetailInfo %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns5_USCORELanAccessDetailInfo*)p = *(ArrayOf_USCOREtns5_USCORELanAccessDetailInfo*)q;
}

void ns4__LanAccessDetailInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &((ns4__LanAccessDetailInfo*)this)->accessEndTime);
	soap_embedded(soap, &((ns4__LanAccessDetailInfo*)this)->accessSessionTime, SOAP_TYPE_LONG64);
	soap_serialize_PointerTotime(soap, &((ns4__LanAccessDetailInfo*)this)->accessStartTime);
	soap_embedded(soap, &((ns4__LanAccessDetailInfo*)this)->bonusCash, SOAP_TYPE_double);
	soap_embedded(soap, &((ns4__LanAccessDetailInfo*)this)->eventID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &((ns4__LanAccessDetailInfo*)this)->inGigaWords, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &((ns4__LanAccessDetailInfo*)this)->macAddr);
	soap_serialize_string(soap, &((ns4__LanAccessDetailInfo*)this)->nasIP);
	soap_embedded(soap, &((ns4__LanAccessDetailInfo*)this)->nasPort, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns4__LanAccessDetailInfo*)this)->offlineCause);
	soap_embedded(soap, &((ns4__LanAccessDetailInfo*)this)->outGigaWords, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &((ns4__LanAccessDetailInfo*)this)->serviceName);
	soap_embedded(soap, &((ns4__LanAccessDetailInfo*)this)->usedCash, SOAP_TYPE_double);
	soap_serialize_string(soap, &((ns4__LanAccessDetailInfo*)this)->userIP);
	soap_serialize_string(soap, &((ns4__LanAccessDetailInfo*)this)->userName);
	soap_serialize_string(soap, &((ns4__LanAccessDetailInfo*)this)->vlanID);
	/* transient soap skipped */
}

void ns4__LanAccessDetailInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns4__LanAccessDetailInfo*)this)->accessEndTime = NULL;
	soap_default_LONG64(soap, &((ns4__LanAccessDetailInfo*)this)->accessSessionTime);
	((ns4__LanAccessDetailInfo*)this)->accessStartTime = NULL;
	soap_default_double(soap, &((ns4__LanAccessDetailInfo*)this)->bonusCash);
	soap_default_LONG64(soap, &((ns4__LanAccessDetailInfo*)this)->eventID);
	soap_default_LONG64(soap, &((ns4__LanAccessDetailInfo*)this)->inGigaWords);
	soap_default_string(soap, &((ns4__LanAccessDetailInfo*)this)->macAddr);
	soap_default_string(soap, &((ns4__LanAccessDetailInfo*)this)->nasIP);
	soap_default_int(soap, &((ns4__LanAccessDetailInfo*)this)->nasPort);
	soap_default_string(soap, &((ns4__LanAccessDetailInfo*)this)->offlineCause);
	soap_default_LONG64(soap, &((ns4__LanAccessDetailInfo*)this)->outGigaWords);
	soap_default_string(soap, &((ns4__LanAccessDetailInfo*)this)->serviceName);
	soap_default_double(soap, &((ns4__LanAccessDetailInfo*)this)->usedCash);
	soap_default_string(soap, &((ns4__LanAccessDetailInfo*)this)->userIP);
	soap_default_string(soap, &((ns4__LanAccessDetailInfo*)this)->userName);
	soap_default_string(soap, &((ns4__LanAccessDetailInfo*)this)->vlanID);
	/* transient soap skipped */
}

int ns4__LanAccessDetailInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__LanAccessDetailInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__LanAccessDetailInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__LanAccessDetailInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__LanAccessDetailInfo(struct soap *soap, const char *tag, int id, const ns4__LanAccessDetailInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__LanAccessDetailInfo), type);
	soap_out_PointerTotime(soap, "accessEndTime", -1, &(((ns4__LanAccessDetailInfo*)a)->accessEndTime), "");
	soap_out_LONG64(soap, "accessSessionTime", -1, &(((ns4__LanAccessDetailInfo*)a)->accessSessionTime), "");
	soap_out_PointerTotime(soap, "accessStartTime", -1, &(((ns4__LanAccessDetailInfo*)a)->accessStartTime), "");
	soap_out_double(soap, "bonusCash", -1, &(((ns4__LanAccessDetailInfo*)a)->bonusCash), "");
	soap_out_LONG64(soap, "eventID", -1, &(((ns4__LanAccessDetailInfo*)a)->eventID), "");
	soap_out_LONG64(soap, "inGigaWords", -1, &(((ns4__LanAccessDetailInfo*)a)->inGigaWords), "");
	soap_out_string(soap, "macAddr", -1, &(((ns4__LanAccessDetailInfo*)a)->macAddr), "");
	soap_out_string(soap, "nasIP", -1, &(((ns4__LanAccessDetailInfo*)a)->nasIP), "");
	soap_out_int(soap, "nasPort", -1, &(((ns4__LanAccessDetailInfo*)a)->nasPort), "");
	soap_out_string(soap, "offlineCause", -1, &(((ns4__LanAccessDetailInfo*)a)->offlineCause), "");
	soap_out_LONG64(soap, "outGigaWords", -1, &(((ns4__LanAccessDetailInfo*)a)->outGigaWords), "");
	soap_out_string(soap, "serviceName", -1, &(((ns4__LanAccessDetailInfo*)a)->serviceName), "");
	soap_out_double(soap, "usedCash", -1, &(((ns4__LanAccessDetailInfo*)a)->usedCash), "");
	soap_out_string(soap, "userIP", -1, &(((ns4__LanAccessDetailInfo*)a)->userIP), "");
	soap_out_string(soap, "userName", -1, &(((ns4__LanAccessDetailInfo*)a)->userName), "");
	soap_out_string(soap, "vlanID", -1, &(((ns4__LanAccessDetailInfo*)a)->vlanID), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns4__LanAccessDetailInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__LanAccessDetailInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns4__LanAccessDetailInfo * SOAP_FMAC4 soap_get_ns4__LanAccessDetailInfo(struct soap *soap, ns4__LanAccessDetailInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__LanAccessDetailInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns4__LanAccessDetailInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__LanAccessDetailInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns4__LanAccessDetailInfo * SOAP_FMAC4 soap_in_ns4__LanAccessDetailInfo(struct soap *soap, const char *tag, ns4__LanAccessDetailInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__LanAccessDetailInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__LanAccessDetailInfo, sizeof(ns4__LanAccessDetailInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__LanAccessDetailInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__LanAccessDetailInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_accessEndTime1 = 1, soap_flag_accessSessionTime1 = 1, soap_flag_accessStartTime1 = 1, soap_flag_bonusCash1 = 1, soap_flag_eventID1 = 1, soap_flag_inGigaWords1 = 1, soap_flag_macAddr1 = 1, soap_flag_nasIP1 = 1, soap_flag_nasPort1 = 1, soap_flag_offlineCause1 = 1, soap_flag_outGigaWords1 = 1, soap_flag_serviceName1 = 1, soap_flag_usedCash1 = 1, soap_flag_userIP1 = 1, soap_flag_userName1 = 1, soap_flag_vlanID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessEndTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "accessEndTime", &(((ns4__LanAccessDetailInfo*)a)->accessEndTime), "xsd:dateTime"))
				{	soap_flag_accessEndTime1--;
					continue;
				}
			if (soap_flag_accessSessionTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "accessSessionTime", &(((ns4__LanAccessDetailInfo*)a)->accessSessionTime), "xsd:long"))
				{	soap_flag_accessSessionTime1--;
					continue;
				}
			if (soap_flag_accessStartTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "accessStartTime", &(((ns4__LanAccessDetailInfo*)a)->accessStartTime), "xsd:dateTime"))
				{	soap_flag_accessStartTime1--;
					continue;
				}
			if (soap_flag_bonusCash1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "bonusCash", &(((ns4__LanAccessDetailInfo*)a)->bonusCash), "xsd:double"))
				{	soap_flag_bonusCash1--;
					continue;
				}
			if (soap_flag_eventID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "eventID", &(((ns4__LanAccessDetailInfo*)a)->eventID), "xsd:long"))
				{	soap_flag_eventID1--;
					continue;
				}
			if (soap_flag_inGigaWords1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "inGigaWords", &(((ns4__LanAccessDetailInfo*)a)->inGigaWords), "xsd:long"))
				{	soap_flag_inGigaWords1--;
					continue;
				}
			if (soap_flag_macAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "macAddr", &(((ns4__LanAccessDetailInfo*)a)->macAddr), "xsd:string"))
				{	soap_flag_macAddr1--;
					continue;
				}
			if (soap_flag_nasIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "nasIP", &(((ns4__LanAccessDetailInfo*)a)->nasIP), "xsd:string"))
				{	soap_flag_nasIP1--;
					continue;
				}
			if (soap_flag_nasPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nasPort", &(((ns4__LanAccessDetailInfo*)a)->nasPort), "xsd:int"))
				{	soap_flag_nasPort1--;
					continue;
				}
			if (soap_flag_offlineCause1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "offlineCause", &(((ns4__LanAccessDetailInfo*)a)->offlineCause), "xsd:string"))
				{	soap_flag_offlineCause1--;
					continue;
				}
			if (soap_flag_outGigaWords1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "outGigaWords", &(((ns4__LanAccessDetailInfo*)a)->outGigaWords), "xsd:long"))
				{	soap_flag_outGigaWords1--;
					continue;
				}
			if (soap_flag_serviceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "serviceName", &(((ns4__LanAccessDetailInfo*)a)->serviceName), "xsd:string"))
				{	soap_flag_serviceName1--;
					continue;
				}
			if (soap_flag_usedCash1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "usedCash", &(((ns4__LanAccessDetailInfo*)a)->usedCash), "xsd:double"))
				{	soap_flag_usedCash1--;
					continue;
				}
			if (soap_flag_userIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIP", &(((ns4__LanAccessDetailInfo*)a)->userIP), "xsd:string"))
				{	soap_flag_userIP1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns4__LanAccessDetailInfo*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_vlanID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "vlanID", &(((ns4__LanAccessDetailInfo*)a)->vlanID), "xsd:string"))
				{	soap_flag_vlanID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_accessSessionTime1 > 0 || soap_flag_bonusCash1 > 0 || soap_flag_eventID1 > 0 || soap_flag_inGigaWords1 > 0 || soap_flag_nasPort1 > 0 || soap_flag_outGigaWords1 > 0 || soap_flag_usedCash1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__LanAccessDetailInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns4__LanAccessDetailInfo, 0, sizeof(ns4__LanAccessDetailInfo), 0, soap_copy_ns4__LanAccessDetailInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__LanAccessDetailInfo * SOAP_FMAC6 soap_new_ns4__LanAccessDetailInfo(struct soap *soap, int n)
{	return soap_instantiate_ns4__LanAccessDetailInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__LanAccessDetailInfo(struct soap *soap, ns4__LanAccessDetailInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__LanAccessDetailInfo * SOAP_FMAC4 soap_instantiate_ns4__LanAccessDetailInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__LanAccessDetailInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__LanAccessDetailInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__LanAccessDetailInfo;
		if (size)
			*size = sizeof(ns4__LanAccessDetailInfo);
		((ns4__LanAccessDetailInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns4__LanAccessDetailInfo[n];
		if (size)
			*size = n * sizeof(ns4__LanAccessDetailInfo);
		for (int i = 0; i < n; i++)
			((ns4__LanAccessDetailInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__LanAccessDetailInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__LanAccessDetailInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__LanAccessDetailInfo %p -> %p\n", q, p));
	*(ns4__LanAccessDetailInfo*)p = *(ns4__LanAccessDetailInfo*)q;
}

void ns3__RetDelUserInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTodouble(soap, &((ns3__RetDelUserInfo*)this)->retCurrency);
	soap_embedded(soap, &((ns22__ResultBase*)this)->errorCode, SOAP_TYPE_int);
	soap_serialize_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_serialize_PointerTons22__ResultBase(soap, &((ns22__ResultBase*)this)->value);
	/* transient soap skipped */
}

void ns3__RetDelUserInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns3__RetDelUserInfo*)this)->retCurrency = NULL;
	soap_default_bool(soap, &((ns22__ResultBase*)this)->error);
	soap_default_int(soap, &((ns22__ResultBase*)this)->errorCode);
	soap_default_string(soap, &((ns22__ResultBase*)this)->errorMsg);
	soap_default_bool(soap, &((ns22__ResultBase*)this)->success);
	((ns22__ResultBase*)this)->value = NULL;
	/* transient soap skipped */
}

int ns3__RetDelUserInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__RetDelUserInfo);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__RetDelUserInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__RetDelUserInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__RetDelUserInfo(struct soap *soap, const char *tag, int id, const ns3__RetDelUserInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__RetDelUserInfo), "ns3:RetDelUserInfo");
	soap_out_bool(soap, "error", -1, &(((ns22__ResultBase*)a)->error), "");
	soap_out_int(soap, "errorCode", -1, &(((ns22__ResultBase*)a)->errorCode), "");
	soap_out_string(soap, "errorMsg", -1, &(((ns22__ResultBase*)a)->errorMsg), "");
	soap_out_bool(soap, "success", -1, &(((ns22__ResultBase*)a)->success), "");
	soap_out_PointerTons22__ResultBase(soap, "value", -1, &(((ns22__ResultBase*)a)->value), "");
	/* transient soap skipped */
	soap_out_PointerTodouble(soap, "retCurrency", -1, &(((ns3__RetDelUserInfo*)a)->retCurrency), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns3__RetDelUserInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__RetDelUserInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns3__RetDelUserInfo * SOAP_FMAC4 soap_get_ns3__RetDelUserInfo(struct soap *soap, ns3__RetDelUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__RetDelUserInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns3__RetDelUserInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__RetDelUserInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns3__RetDelUserInfo * SOAP_FMAC4 soap_in_ns3__RetDelUserInfo(struct soap *soap, const char *tag, ns3__RetDelUserInfo *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__RetDelUserInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__RetDelUserInfo, sizeof(ns3__RetDelUserInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__RetDelUserInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__RetDelUserInfo *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_error2 = 1, soap_flag_errorCode2 = 1, soap_flag_errorMsg2 = 1, soap_flag_success2 = 1, soap_flag_value2 = 1, soap_flag_retCurrency1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "error", &(((ns22__ResultBase*)a)->error), "xsd:boolean"))
				{	soap_flag_error2--;
					continue;
				}
			if (soap_flag_errorCode2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "errorCode", &(((ns22__ResultBase*)a)->errorCode), "xsd:int"))
				{	soap_flag_errorCode2--;
					continue;
				}
			if (soap_flag_errorMsg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "errorMsg", &(((ns22__ResultBase*)a)->errorMsg), "xsd:string"))
				{	soap_flag_errorMsg2--;
					continue;
				}
			if (soap_flag_success2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "success", &(((ns22__ResultBase*)a)->success), "xsd:boolean"))
				{	soap_flag_success2--;
					continue;
				}
			if (soap_flag_value2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "value", &(((ns22__ResultBase*)a)->value), "ns22:ResultBase"))
				{	soap_flag_value2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_retCurrency1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "retCurrency", &(((ns3__RetDelUserInfo*)a)->retCurrency), "xsd:double"))
				{	soap_flag_retCurrency1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_error2 > 0 || soap_flag_errorCode2 > 0 || soap_flag_success2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__RetDelUserInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns3__RetDelUserInfo, 0, sizeof(ns3__RetDelUserInfo), 0, soap_copy_ns3__RetDelUserInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns3__RetDelUserInfo * SOAP_FMAC6 soap_new_ns3__RetDelUserInfo(struct soap *soap, int n)
{	return soap_instantiate_ns3__RetDelUserInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns3__RetDelUserInfo(struct soap *soap, ns3__RetDelUserInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns3__RetDelUserInfo * SOAP_FMAC4 soap_instantiate_ns3__RetDelUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__RetDelUserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__RetDelUserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__RetDelUserInfo;
		if (size)
			*size = sizeof(ns3__RetDelUserInfo);
		((ns3__RetDelUserInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__RetDelUserInfo[n];
		if (size)
			*size = n * sizeof(ns3__RetDelUserInfo);
		for (int i = 0; i < n; i++)
			((ns3__RetDelUserInfo*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__RetDelUserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__RetDelUserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__RetDelUserInfo %p -> %p\n", q, p));
	*(ns3__RetDelUserInfo*)p = *(ns3__RetDelUserInfo*)q;
}

void ns2__PayParam::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &((ns2__PayParam*)this)->payAmount);
	soap_serialize_string(soap, &((ns2__PayParam*)this)->userName);
	/* transient soap skipped */
}

void ns2__PayParam::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &((ns2__PayParam*)this)->payAmount);
	soap_default_string(soap, &((ns2__PayParam*)this)->userName);
	/* transient soap skipped */
}

int ns2__PayParam::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__PayParam);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__PayParam::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PayParam(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PayParam(struct soap *soap, const char *tag, int id, const ns2__PayParam *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PayParam), type);
	soap_out_string(soap, "payAmount", -1, &(((ns2__PayParam*)a)->payAmount), "");
	soap_out_string(soap, "userName", -1, &(((ns2__PayParam*)a)->userName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns2__PayParam::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PayParam(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PayParam * SOAP_FMAC4 soap_get_ns2__PayParam(struct soap *soap, ns2__PayParam *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PayParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns2__PayParam::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PayParam(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PayParam * SOAP_FMAC4 soap_in_ns2__PayParam(struct soap *soap, const char *tag, ns2__PayParam *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PayParam *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PayParam, sizeof(ns2__PayParam), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__PayParam)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__PayParam *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_payAmount1 = 1, soap_flag_userName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_payAmount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "payAmount", &(((ns2__PayParam*)a)->payAmount), "xsd:string"))
				{	soap_flag_payAmount1--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userName", &(((ns2__PayParam*)a)->userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PayParam *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns2__PayParam, 0, sizeof(ns2__PayParam), 0, soap_copy_ns2__PayParam);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns2__PayParam * SOAP_FMAC6 soap_new_ns2__PayParam(struct soap *soap, int n)
{	return soap_instantiate_ns2__PayParam(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__PayParam(struct soap *soap, ns2__PayParam *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns2__PayParam * SOAP_FMAC4 soap_instantiate_ns2__PayParam(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PayParam(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__PayParam, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__PayParam;
		if (size)
			*size = sizeof(ns2__PayParam);
		((ns2__PayParam*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__PayParam[n];
		if (size)
			*size = n * sizeof(ns2__PayParam);
		for (int i = 0; i < n; i++)
			((ns2__PayParam*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__PayParam*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__PayParam(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__PayParam %p -> %p\n", q, p));
	*(ns2__PayParam*)p = *(ns2__PayParam*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__bindAccount(struct soap *soap, const struct ns37__bindAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons36__BindParam(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__bindAccount(struct soap *soap, struct ns37__bindAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__bindAccount(struct soap *soap, const struct ns37__bindAccount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__bindAccount);
	if (soap_out_ns37__bindAccount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__bindAccount(struct soap *soap, const char *tag, int id, const struct ns37__bindAccount *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__bindAccount), type);
	soap_out_PointerTons36__BindParam(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__bindAccount * SOAP_FMAC4 soap_get_ns37__bindAccount(struct soap *soap, struct ns37__bindAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__bindAccount(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__bindAccount * SOAP_FMAC4 soap_in_ns37__bindAccount(struct soap *soap, const char *tag, struct ns37__bindAccount *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__bindAccount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__bindAccount, sizeof(struct ns37__bindAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__bindAccount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons36__BindParam(soap, NULL, &a->_in0, "ns36:BindParam"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__bindAccount *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__bindAccount, 0, sizeof(struct ns37__bindAccount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__bindAccount * SOAP_FMAC6 soap_new_ns37__bindAccount(struct soap *soap, int n)
{	return soap_instantiate_ns37__bindAccount(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__bindAccount(struct soap *soap, struct ns37__bindAccount *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__bindAccount * SOAP_FMAC4 soap_instantiate_ns37__bindAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__bindAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__bindAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__bindAccount;
		if (size)
			*size = sizeof(struct ns37__bindAccount);
	}
	else
	{	cp->ptr = (void*)new struct ns37__bindAccount[n];
		if (size)
			*size = n * sizeof(struct ns37__bindAccount);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__bindAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__bindAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__bindAccount %p -> %p\n", q, p));
	*(struct ns37__bindAccount*)p = *(struct ns37__bindAccount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__bindAccountResponse(struct soap *soap, const struct ns37__bindAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons22__ResultBase(soap, &a->_bindAccountReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__bindAccountResponse(struct soap *soap, struct ns37__bindAccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_bindAccountReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__bindAccountResponse(struct soap *soap, const struct ns37__bindAccountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__bindAccountResponse);
	if (soap_out_ns37__bindAccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__bindAccountResponse(struct soap *soap, const char *tag, int id, const struct ns37__bindAccountResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__bindAccountResponse), type);
	if (a->_bindAccountReturn)
		soap_element_result(soap, "bindAccountReturn");
	soap_out_PointerTons22__ResultBase(soap, "bindAccountReturn", -1, &a->_bindAccountReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__bindAccountResponse * SOAP_FMAC4 soap_get_ns37__bindAccountResponse(struct soap *soap, struct ns37__bindAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__bindAccountResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__bindAccountResponse * SOAP_FMAC4 soap_in_ns37__bindAccountResponse(struct soap *soap, const char *tag, struct ns37__bindAccountResponse *a, const char *type)
{
	short soap_flag__bindAccountReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__bindAccountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__bindAccountResponse, sizeof(struct ns37__bindAccountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__bindAccountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__bindAccountReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, NULL, &a->_bindAccountReturn, "ns22:ResultBase"))
				{	soap_flag__bindAccountReturn--;
					continue;
				}
			soap_check_result(soap, "bindAccountReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__bindAccountResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__bindAccountResponse, 0, sizeof(struct ns37__bindAccountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__bindAccountResponse * SOAP_FMAC6 soap_new_ns37__bindAccountResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__bindAccountResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__bindAccountResponse(struct soap *soap, struct ns37__bindAccountResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__bindAccountResponse * SOAP_FMAC4 soap_instantiate_ns37__bindAccountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__bindAccountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__bindAccountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__bindAccountResponse;
		if (size)
			*size = sizeof(struct ns37__bindAccountResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__bindAccountResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__bindAccountResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__bindAccountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__bindAccountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__bindAccountResponse %p -> %p\n", q, p));
	*(struct ns37__bindAccountResponse*)p = *(struct ns37__bindAccountResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryAcctList(struct soap *soap, const struct ns37__queryAcctList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons35__AccountListQueryInfo(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryAcctList(struct soap *soap, struct ns37__queryAcctList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryAcctList(struct soap *soap, const struct ns37__queryAcctList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryAcctList);
	if (soap_out_ns37__queryAcctList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryAcctList(struct soap *soap, const char *tag, int id, const struct ns37__queryAcctList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryAcctList), type);
	soap_out_PointerTons35__AccountListQueryInfo(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryAcctList * SOAP_FMAC4 soap_get_ns37__queryAcctList(struct soap *soap, struct ns37__queryAcctList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryAcctList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryAcctList * SOAP_FMAC4 soap_in_ns37__queryAcctList(struct soap *soap, const char *tag, struct ns37__queryAcctList *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryAcctList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryAcctList, sizeof(struct ns37__queryAcctList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryAcctList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons35__AccountListQueryInfo(soap, NULL, &a->_in0, "ns35:AccountListQueryInfo"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryAcctList *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryAcctList, 0, sizeof(struct ns37__queryAcctList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryAcctList * SOAP_FMAC6 soap_new_ns37__queryAcctList(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryAcctList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryAcctList(struct soap *soap, struct ns37__queryAcctList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryAcctList * SOAP_FMAC4 soap_instantiate_ns37__queryAcctList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryAcctList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryAcctList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryAcctList;
		if (size)
			*size = sizeof(struct ns37__queryAcctList);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryAcctList[n];
		if (size)
			*size = n * sizeof(struct ns37__queryAcctList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryAcctList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryAcctList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryAcctList %p -> %p\n", q, p));
	*(struct ns37__queryAcctList*)p = *(struct ns37__queryAcctList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryAcctListResponse(struct soap *soap, const struct ns37__queryAcctListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons10__RetAccountList(soap, &a->_queryAcctListReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryAcctListResponse(struct soap *soap, struct ns37__queryAcctListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_queryAcctListReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryAcctListResponse(struct soap *soap, const struct ns37__queryAcctListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryAcctListResponse);
	if (soap_out_ns37__queryAcctListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryAcctListResponse(struct soap *soap, const char *tag, int id, const struct ns37__queryAcctListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryAcctListResponse), type);
	if (a->_queryAcctListReturn)
		soap_element_result(soap, "queryAcctListReturn");
	soap_out_PointerTons10__RetAccountList(soap, "queryAcctListReturn", -1, &a->_queryAcctListReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryAcctListResponse * SOAP_FMAC4 soap_get_ns37__queryAcctListResponse(struct soap *soap, struct ns37__queryAcctListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryAcctListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryAcctListResponse * SOAP_FMAC4 soap_in_ns37__queryAcctListResponse(struct soap *soap, const char *tag, struct ns37__queryAcctListResponse *a, const char *type)
{
	short soap_flag__queryAcctListReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryAcctListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryAcctListResponse, sizeof(struct ns37__queryAcctListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryAcctListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__queryAcctListReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons10__RetAccountList(soap, NULL, &a->_queryAcctListReturn, "ns10:RetAccountList"))
				{	soap_flag__queryAcctListReturn--;
					continue;
				}
			soap_check_result(soap, "queryAcctListReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryAcctListResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryAcctListResponse, 0, sizeof(struct ns37__queryAcctListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryAcctListResponse * SOAP_FMAC6 soap_new_ns37__queryAcctListResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryAcctListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryAcctListResponse(struct soap *soap, struct ns37__queryAcctListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryAcctListResponse * SOAP_FMAC4 soap_instantiate_ns37__queryAcctListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryAcctListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryAcctListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryAcctListResponse;
		if (size)
			*size = sizeof(struct ns37__queryAcctListResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryAcctListResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__queryAcctListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryAcctListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryAcctListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryAcctListResponse %p -> %p\n", q, p));
	*(struct ns37__queryAcctListResponse*)p = *(struct ns37__queryAcctListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryLanAccessDetail(struct soap *soap, const struct ns37__queryLanAccessDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons34__LanAccessDetailQueryInfo(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryLanAccessDetail(struct soap *soap, struct ns37__queryLanAccessDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryLanAccessDetail(struct soap *soap, const struct ns37__queryLanAccessDetail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryLanAccessDetail);
	if (soap_out_ns37__queryLanAccessDetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryLanAccessDetail(struct soap *soap, const char *tag, int id, const struct ns37__queryLanAccessDetail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryLanAccessDetail), type);
	soap_out_PointerTons34__LanAccessDetailQueryInfo(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryLanAccessDetail * SOAP_FMAC4 soap_get_ns37__queryLanAccessDetail(struct soap *soap, struct ns37__queryLanAccessDetail *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryLanAccessDetail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryLanAccessDetail * SOAP_FMAC4 soap_in_ns37__queryLanAccessDetail(struct soap *soap, const char *tag, struct ns37__queryLanAccessDetail *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryLanAccessDetail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryLanAccessDetail, sizeof(struct ns37__queryLanAccessDetail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryLanAccessDetail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons34__LanAccessDetailQueryInfo(soap, NULL, &a->_in0, "ns34:LanAccessDetailQueryInfo"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryLanAccessDetail *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryLanAccessDetail, 0, sizeof(struct ns37__queryLanAccessDetail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryLanAccessDetail * SOAP_FMAC6 soap_new_ns37__queryLanAccessDetail(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryLanAccessDetail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryLanAccessDetail(struct soap *soap, struct ns37__queryLanAccessDetail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryLanAccessDetail * SOAP_FMAC4 soap_instantiate_ns37__queryLanAccessDetail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryLanAccessDetail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryLanAccessDetail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryLanAccessDetail;
		if (size)
			*size = sizeof(struct ns37__queryLanAccessDetail);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryLanAccessDetail[n];
		if (size)
			*size = n * sizeof(struct ns37__queryLanAccessDetail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryLanAccessDetail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryLanAccessDetail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryLanAccessDetail %p -> %p\n", q, p));
	*(struct ns37__queryLanAccessDetail*)p = *(struct ns37__queryLanAccessDetail*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryLanAccessDetailResponse(struct soap *soap, const struct ns37__queryLanAccessDetailResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__LanAccessDetailList(soap, &a->_queryLanAccessDetailReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryLanAccessDetailResponse(struct soap *soap, struct ns37__queryLanAccessDetailResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_queryLanAccessDetailReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryLanAccessDetailResponse(struct soap *soap, const struct ns37__queryLanAccessDetailResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryLanAccessDetailResponse);
	if (soap_out_ns37__queryLanAccessDetailResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryLanAccessDetailResponse(struct soap *soap, const char *tag, int id, const struct ns37__queryLanAccessDetailResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryLanAccessDetailResponse), type);
	if (a->_queryLanAccessDetailReturn)
		soap_element_result(soap, "queryLanAccessDetailReturn");
	soap_out_PointerTons5__LanAccessDetailList(soap, "queryLanAccessDetailReturn", -1, &a->_queryLanAccessDetailReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryLanAccessDetailResponse * SOAP_FMAC4 soap_get_ns37__queryLanAccessDetailResponse(struct soap *soap, struct ns37__queryLanAccessDetailResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryLanAccessDetailResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryLanAccessDetailResponse * SOAP_FMAC4 soap_in_ns37__queryLanAccessDetailResponse(struct soap *soap, const char *tag, struct ns37__queryLanAccessDetailResponse *a, const char *type)
{
	short soap_flag__queryLanAccessDetailReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryLanAccessDetailResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryLanAccessDetailResponse, sizeof(struct ns37__queryLanAccessDetailResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryLanAccessDetailResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__queryLanAccessDetailReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__LanAccessDetailList(soap, NULL, &a->_queryLanAccessDetailReturn, "ns5:LanAccessDetailList"))
				{	soap_flag__queryLanAccessDetailReturn--;
					continue;
				}
			soap_check_result(soap, "queryLanAccessDetailReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryLanAccessDetailResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryLanAccessDetailResponse, 0, sizeof(struct ns37__queryLanAccessDetailResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryLanAccessDetailResponse * SOAP_FMAC6 soap_new_ns37__queryLanAccessDetailResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryLanAccessDetailResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryLanAccessDetailResponse(struct soap *soap, struct ns37__queryLanAccessDetailResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryLanAccessDetailResponse * SOAP_FMAC4 soap_instantiate_ns37__queryLanAccessDetailResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryLanAccessDetailResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryLanAccessDetailResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryLanAccessDetailResponse;
		if (size)
			*size = sizeof(struct ns37__queryLanAccessDetailResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryLanAccessDetailResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__queryLanAccessDetailResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryLanAccessDetailResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryLanAccessDetailResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryLanAccessDetailResponse %p -> %p\n", q, p));
	*(struct ns37__queryLanAccessDetailResponse*)p = *(struct ns37__queryLanAccessDetailResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryLanService(struct soap *soap, const struct ns37__queryLanService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons33__LanQryCondition(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryLanService(struct soap *soap, struct ns37__queryLanService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryLanService(struct soap *soap, const struct ns37__queryLanService *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryLanService);
	if (soap_out_ns37__queryLanService(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryLanService(struct soap *soap, const char *tag, int id, const struct ns37__queryLanService *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryLanService), type);
	soap_out_PointerTons33__LanQryCondition(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryLanService * SOAP_FMAC4 soap_get_ns37__queryLanService(struct soap *soap, struct ns37__queryLanService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryLanService(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryLanService * SOAP_FMAC4 soap_in_ns37__queryLanService(struct soap *soap, const char *tag, struct ns37__queryLanService *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryLanService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryLanService, sizeof(struct ns37__queryLanService), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryLanService(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons33__LanQryCondition(soap, NULL, &a->_in0, "ns33:LanQryCondition"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryLanService *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryLanService, 0, sizeof(struct ns37__queryLanService), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryLanService * SOAP_FMAC6 soap_new_ns37__queryLanService(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryLanService(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryLanService(struct soap *soap, struct ns37__queryLanService *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryLanService * SOAP_FMAC4 soap_instantiate_ns37__queryLanService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryLanService(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryLanService, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryLanService;
		if (size)
			*size = sizeof(struct ns37__queryLanService);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryLanService[n];
		if (size)
			*size = n * sizeof(struct ns37__queryLanService);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryLanService*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryLanService(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryLanService %p -> %p\n", q, p));
	*(struct ns37__queryLanService*)p = *(struct ns37__queryLanService*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryLanServiceResponse(struct soap *soap, const struct ns37__queryLanServiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons19__LanServiceList(soap, &a->_queryLanServiceReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryLanServiceResponse(struct soap *soap, struct ns37__queryLanServiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_queryLanServiceReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryLanServiceResponse(struct soap *soap, const struct ns37__queryLanServiceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryLanServiceResponse);
	if (soap_out_ns37__queryLanServiceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryLanServiceResponse(struct soap *soap, const char *tag, int id, const struct ns37__queryLanServiceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryLanServiceResponse), type);
	if (a->_queryLanServiceReturn)
		soap_element_result(soap, "queryLanServiceReturn");
	soap_out_PointerTons19__LanServiceList(soap, "queryLanServiceReturn", -1, &a->_queryLanServiceReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryLanServiceResponse * SOAP_FMAC4 soap_get_ns37__queryLanServiceResponse(struct soap *soap, struct ns37__queryLanServiceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryLanServiceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryLanServiceResponse * SOAP_FMAC4 soap_in_ns37__queryLanServiceResponse(struct soap *soap, const char *tag, struct ns37__queryLanServiceResponse *a, const char *type)
{
	short soap_flag__queryLanServiceReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryLanServiceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryLanServiceResponse, sizeof(struct ns37__queryLanServiceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryLanServiceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__queryLanServiceReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons19__LanServiceList(soap, NULL, &a->_queryLanServiceReturn, "ns19:LanServiceList"))
				{	soap_flag__queryLanServiceReturn--;
					continue;
				}
			soap_check_result(soap, "queryLanServiceReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryLanServiceResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryLanServiceResponse, 0, sizeof(struct ns37__queryLanServiceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryLanServiceResponse * SOAP_FMAC6 soap_new_ns37__queryLanServiceResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryLanServiceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryLanServiceResponse(struct soap *soap, struct ns37__queryLanServiceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryLanServiceResponse * SOAP_FMAC4 soap_instantiate_ns37__queryLanServiceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryLanServiceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryLanServiceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryLanServiceResponse;
		if (size)
			*size = sizeof(struct ns37__queryLanServiceResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryLanServiceResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__queryLanServiceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryLanServiceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryLanServiceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryLanServiceResponse %p -> %p\n", q, p));
	*(struct ns37__queryLanServiceResponse*)p = *(struct ns37__queryLanServiceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryUserBalance(struct soap *soap, const struct ns37__queryUserBalance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryUserBalance(struct soap *soap, struct ns37__queryUserBalance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryUserBalance(struct soap *soap, const struct ns37__queryUserBalance *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryUserBalance);
	if (soap_out_ns37__queryUserBalance(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryUserBalance(struct soap *soap, const char *tag, int id, const struct ns37__queryUserBalance *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryUserBalance), type);
	soap_out_string(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryUserBalance * SOAP_FMAC4 soap_get_ns37__queryUserBalance(struct soap *soap, struct ns37__queryUserBalance *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryUserBalance(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryUserBalance * SOAP_FMAC4 soap_in_ns37__queryUserBalance(struct soap *soap, const char *tag, struct ns37__queryUserBalance *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryUserBalance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryUserBalance, sizeof(struct ns37__queryUserBalance), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryUserBalance(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryUserBalance *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryUserBalance, 0, sizeof(struct ns37__queryUserBalance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryUserBalance * SOAP_FMAC6 soap_new_ns37__queryUserBalance(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryUserBalance(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryUserBalance(struct soap *soap, struct ns37__queryUserBalance *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryUserBalance * SOAP_FMAC4 soap_instantiate_ns37__queryUserBalance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryUserBalance(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryUserBalance, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryUserBalance;
		if (size)
			*size = sizeof(struct ns37__queryUserBalance);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryUserBalance[n];
		if (size)
			*size = n * sizeof(struct ns37__queryUserBalance);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryUserBalance*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryUserBalance(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryUserBalance %p -> %p\n", q, p));
	*(struct ns37__queryUserBalance*)p = *(struct ns37__queryUserBalance*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryUserBalanceResponse(struct soap *soap, const struct ns37__queryUserBalanceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons21__UserBalance(soap, &a->_queryUserBalanceReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryUserBalanceResponse(struct soap *soap, struct ns37__queryUserBalanceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_queryUserBalanceReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryUserBalanceResponse(struct soap *soap, const struct ns37__queryUserBalanceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryUserBalanceResponse);
	if (soap_out_ns37__queryUserBalanceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryUserBalanceResponse(struct soap *soap, const char *tag, int id, const struct ns37__queryUserBalanceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryUserBalanceResponse), type);
	if (a->_queryUserBalanceReturn)
		soap_element_result(soap, "queryUserBalanceReturn");
	soap_out_PointerTons21__UserBalance(soap, "queryUserBalanceReturn", -1, &a->_queryUserBalanceReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryUserBalanceResponse * SOAP_FMAC4 soap_get_ns37__queryUserBalanceResponse(struct soap *soap, struct ns37__queryUserBalanceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryUserBalanceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryUserBalanceResponse * SOAP_FMAC4 soap_in_ns37__queryUserBalanceResponse(struct soap *soap, const char *tag, struct ns37__queryUserBalanceResponse *a, const char *type)
{
	short soap_flag__queryUserBalanceReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryUserBalanceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryUserBalanceResponse, sizeof(struct ns37__queryUserBalanceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryUserBalanceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__queryUserBalanceReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons21__UserBalance(soap, NULL, &a->_queryUserBalanceReturn, "ns21:UserBalance"))
				{	soap_flag__queryUserBalanceReturn--;
					continue;
				}
			soap_check_result(soap, "queryUserBalanceReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryUserBalanceResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryUserBalanceResponse, 0, sizeof(struct ns37__queryUserBalanceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryUserBalanceResponse * SOAP_FMAC6 soap_new_ns37__queryUserBalanceResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryUserBalanceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryUserBalanceResponse(struct soap *soap, struct ns37__queryUserBalanceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryUserBalanceResponse * SOAP_FMAC4 soap_instantiate_ns37__queryUserBalanceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryUserBalanceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryUserBalanceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryUserBalanceResponse;
		if (size)
			*size = sizeof(struct ns37__queryUserBalanceResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryUserBalanceResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__queryUserBalanceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryUserBalanceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryUserBalanceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryUserBalanceResponse %p -> %p\n", q, p));
	*(struct ns37__queryUserBalanceResponse*)p = *(struct ns37__queryUserBalanceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryBlackList(struct soap *soap, const struct ns37__queryBlackList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons32__BlackListQueryInfo(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryBlackList(struct soap *soap, struct ns37__queryBlackList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryBlackList(struct soap *soap, const struct ns37__queryBlackList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryBlackList);
	if (soap_out_ns37__queryBlackList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryBlackList(struct soap *soap, const char *tag, int id, const struct ns37__queryBlackList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryBlackList), type);
	soap_out_PointerTons32__BlackListQueryInfo(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryBlackList * SOAP_FMAC4 soap_get_ns37__queryBlackList(struct soap *soap, struct ns37__queryBlackList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryBlackList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryBlackList * SOAP_FMAC4 soap_in_ns37__queryBlackList(struct soap *soap, const char *tag, struct ns37__queryBlackList *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryBlackList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryBlackList, sizeof(struct ns37__queryBlackList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryBlackList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons32__BlackListQueryInfo(soap, NULL, &a->_in0, "ns32:BlackListQueryInfo"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryBlackList *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryBlackList, 0, sizeof(struct ns37__queryBlackList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryBlackList * SOAP_FMAC6 soap_new_ns37__queryBlackList(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryBlackList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryBlackList(struct soap *soap, struct ns37__queryBlackList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryBlackList * SOAP_FMAC4 soap_instantiate_ns37__queryBlackList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryBlackList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryBlackList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryBlackList;
		if (size)
			*size = sizeof(struct ns37__queryBlackList);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryBlackList[n];
		if (size)
			*size = n * sizeof(struct ns37__queryBlackList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryBlackList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryBlackList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryBlackList %p -> %p\n", q, p));
	*(struct ns37__queryBlackList*)p = *(struct ns37__queryBlackList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryBlackListResponse(struct soap *soap, const struct ns37__queryBlackListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons17__BlackList(soap, &a->_queryBlackListReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryBlackListResponse(struct soap *soap, struct ns37__queryBlackListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_queryBlackListReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryBlackListResponse(struct soap *soap, const struct ns37__queryBlackListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryBlackListResponse);
	if (soap_out_ns37__queryBlackListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryBlackListResponse(struct soap *soap, const char *tag, int id, const struct ns37__queryBlackListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryBlackListResponse), type);
	if (a->_queryBlackListReturn)
		soap_element_result(soap, "queryBlackListReturn");
	soap_out_PointerTons17__BlackList(soap, "queryBlackListReturn", -1, &a->_queryBlackListReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryBlackListResponse * SOAP_FMAC4 soap_get_ns37__queryBlackListResponse(struct soap *soap, struct ns37__queryBlackListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryBlackListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryBlackListResponse * SOAP_FMAC4 soap_in_ns37__queryBlackListResponse(struct soap *soap, const char *tag, struct ns37__queryBlackListResponse *a, const char *type)
{
	short soap_flag__queryBlackListReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryBlackListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryBlackListResponse, sizeof(struct ns37__queryBlackListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryBlackListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__queryBlackListReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons17__BlackList(soap, NULL, &a->_queryBlackListReturn, "ns17:BlackList"))
				{	soap_flag__queryBlackListReturn--;
					continue;
				}
			soap_check_result(soap, "queryBlackListReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryBlackListResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryBlackListResponse, 0, sizeof(struct ns37__queryBlackListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryBlackListResponse * SOAP_FMAC6 soap_new_ns37__queryBlackListResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryBlackListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryBlackListResponse(struct soap *soap, struct ns37__queryBlackListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryBlackListResponse * SOAP_FMAC4 soap_instantiate_ns37__queryBlackListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryBlackListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryBlackListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryBlackListResponse;
		if (size)
			*size = sizeof(struct ns37__queryBlackListResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryBlackListResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__queryBlackListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryBlackListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryBlackListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryBlackListResponse %p -> %p\n", q, p));
	*(struct ns37__queryBlackListResponse*)p = *(struct ns37__queryBlackListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__deleteBlackList(struct soap *soap, const struct ns37__deleteBlackList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__deleteBlackList(struct soap *soap, struct ns37__deleteBlackList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__deleteBlackList(struct soap *soap, const struct ns37__deleteBlackList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__deleteBlackList);
	if (soap_out_ns37__deleteBlackList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__deleteBlackList(struct soap *soap, const char *tag, int id, const struct ns37__deleteBlackList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__deleteBlackList), type);
	soap_out_string(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__deleteBlackList * SOAP_FMAC4 soap_get_ns37__deleteBlackList(struct soap *soap, struct ns37__deleteBlackList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__deleteBlackList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__deleteBlackList * SOAP_FMAC4 soap_in_ns37__deleteBlackList(struct soap *soap, const char *tag, struct ns37__deleteBlackList *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__deleteBlackList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__deleteBlackList, sizeof(struct ns37__deleteBlackList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__deleteBlackList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__deleteBlackList *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__deleteBlackList, 0, sizeof(struct ns37__deleteBlackList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__deleteBlackList * SOAP_FMAC6 soap_new_ns37__deleteBlackList(struct soap *soap, int n)
{	return soap_instantiate_ns37__deleteBlackList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__deleteBlackList(struct soap *soap, struct ns37__deleteBlackList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__deleteBlackList * SOAP_FMAC4 soap_instantiate_ns37__deleteBlackList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__deleteBlackList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__deleteBlackList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__deleteBlackList;
		if (size)
			*size = sizeof(struct ns37__deleteBlackList);
	}
	else
	{	cp->ptr = (void*)new struct ns37__deleteBlackList[n];
		if (size)
			*size = n * sizeof(struct ns37__deleteBlackList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__deleteBlackList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__deleteBlackList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__deleteBlackList %p -> %p\n", q, p));
	*(struct ns37__deleteBlackList*)p = *(struct ns37__deleteBlackList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__deleteBlackListResponse(struct soap *soap, const struct ns37__deleteBlackListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons22__ResultBase(soap, &a->_deleteBlackListReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__deleteBlackListResponse(struct soap *soap, struct ns37__deleteBlackListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_deleteBlackListReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__deleteBlackListResponse(struct soap *soap, const struct ns37__deleteBlackListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__deleteBlackListResponse);
	if (soap_out_ns37__deleteBlackListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__deleteBlackListResponse(struct soap *soap, const char *tag, int id, const struct ns37__deleteBlackListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__deleteBlackListResponse), type);
	if (a->_deleteBlackListReturn)
		soap_element_result(soap, "deleteBlackListReturn");
	soap_out_PointerTons22__ResultBase(soap, "deleteBlackListReturn", -1, &a->_deleteBlackListReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__deleteBlackListResponse * SOAP_FMAC4 soap_get_ns37__deleteBlackListResponse(struct soap *soap, struct ns37__deleteBlackListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__deleteBlackListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__deleteBlackListResponse * SOAP_FMAC4 soap_in_ns37__deleteBlackListResponse(struct soap *soap, const char *tag, struct ns37__deleteBlackListResponse *a, const char *type)
{
	short soap_flag__deleteBlackListReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__deleteBlackListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__deleteBlackListResponse, sizeof(struct ns37__deleteBlackListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__deleteBlackListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__deleteBlackListReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, NULL, &a->_deleteBlackListReturn, "ns22:ResultBase"))
				{	soap_flag__deleteBlackListReturn--;
					continue;
				}
			soap_check_result(soap, "deleteBlackListReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__deleteBlackListResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__deleteBlackListResponse, 0, sizeof(struct ns37__deleteBlackListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__deleteBlackListResponse * SOAP_FMAC6 soap_new_ns37__deleteBlackListResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__deleteBlackListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__deleteBlackListResponse(struct soap *soap, struct ns37__deleteBlackListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__deleteBlackListResponse * SOAP_FMAC4 soap_instantiate_ns37__deleteBlackListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__deleteBlackListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__deleteBlackListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__deleteBlackListResponse;
		if (size)
			*size = sizeof(struct ns37__deleteBlackListResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__deleteBlackListResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__deleteBlackListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__deleteBlackListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__deleteBlackListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__deleteBlackListResponse %p -> %p\n", q, p));
	*(struct ns37__deleteBlackListResponse*)p = *(struct ns37__deleteBlackListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__addBlackList(struct soap *soap, const struct ns37__addBlackList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__addBlackList(struct soap *soap, struct ns37__addBlackList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__addBlackList(struct soap *soap, const struct ns37__addBlackList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__addBlackList);
	if (soap_out_ns37__addBlackList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__addBlackList(struct soap *soap, const char *tag, int id, const struct ns37__addBlackList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__addBlackList), type);
	soap_out_string(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__addBlackList * SOAP_FMAC4 soap_get_ns37__addBlackList(struct soap *soap, struct ns37__addBlackList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__addBlackList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__addBlackList * SOAP_FMAC4 soap_in_ns37__addBlackList(struct soap *soap, const char *tag, struct ns37__addBlackList *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__addBlackList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__addBlackList, sizeof(struct ns37__addBlackList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__addBlackList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__addBlackList *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__addBlackList, 0, sizeof(struct ns37__addBlackList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__addBlackList * SOAP_FMAC6 soap_new_ns37__addBlackList(struct soap *soap, int n)
{	return soap_instantiate_ns37__addBlackList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__addBlackList(struct soap *soap, struct ns37__addBlackList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__addBlackList * SOAP_FMAC4 soap_instantiate_ns37__addBlackList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__addBlackList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__addBlackList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__addBlackList;
		if (size)
			*size = sizeof(struct ns37__addBlackList);
	}
	else
	{	cp->ptr = (void*)new struct ns37__addBlackList[n];
		if (size)
			*size = n * sizeof(struct ns37__addBlackList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__addBlackList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__addBlackList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__addBlackList %p -> %p\n", q, p));
	*(struct ns37__addBlackList*)p = *(struct ns37__addBlackList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__addBlackListResponse(struct soap *soap, const struct ns37__addBlackListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons22__ResultBase(soap, &a->_addBlackListReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__addBlackListResponse(struct soap *soap, struct ns37__addBlackListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_addBlackListReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__addBlackListResponse(struct soap *soap, const struct ns37__addBlackListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__addBlackListResponse);
	if (soap_out_ns37__addBlackListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__addBlackListResponse(struct soap *soap, const char *tag, int id, const struct ns37__addBlackListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__addBlackListResponse), type);
	if (a->_addBlackListReturn)
		soap_element_result(soap, "addBlackListReturn");
	soap_out_PointerTons22__ResultBase(soap, "addBlackListReturn", -1, &a->_addBlackListReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__addBlackListResponse * SOAP_FMAC4 soap_get_ns37__addBlackListResponse(struct soap *soap, struct ns37__addBlackListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__addBlackListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__addBlackListResponse * SOAP_FMAC4 soap_in_ns37__addBlackListResponse(struct soap *soap, const char *tag, struct ns37__addBlackListResponse *a, const char *type)
{
	short soap_flag__addBlackListReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__addBlackListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__addBlackListResponse, sizeof(struct ns37__addBlackListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__addBlackListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addBlackListReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, NULL, &a->_addBlackListReturn, "ns22:ResultBase"))
				{	soap_flag__addBlackListReturn--;
					continue;
				}
			soap_check_result(soap, "addBlackListReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__addBlackListResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__addBlackListResponse, 0, sizeof(struct ns37__addBlackListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__addBlackListResponse * SOAP_FMAC6 soap_new_ns37__addBlackListResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__addBlackListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__addBlackListResponse(struct soap *soap, struct ns37__addBlackListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__addBlackListResponse * SOAP_FMAC4 soap_instantiate_ns37__addBlackListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__addBlackListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__addBlackListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__addBlackListResponse;
		if (size)
			*size = sizeof(struct ns37__addBlackListResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__addBlackListResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__addBlackListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__addBlackListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__addBlackListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__addBlackListResponse %p -> %p\n", q, p));
	*(struct ns37__addBlackListResponse*)p = *(struct ns37__addBlackListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryAppendDefInfo(struct soap *soap, const struct ns37__queryAppendDefInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryAppendDefInfo(struct soap *soap, struct ns37__queryAppendDefInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryAppendDefInfo(struct soap *soap, const struct ns37__queryAppendDefInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryAppendDefInfo);
	if (soap_out_ns37__queryAppendDefInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryAppendDefInfo(struct soap *soap, const char *tag, int id, const struct ns37__queryAppendDefInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryAppendDefInfo), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryAppendDefInfo * SOAP_FMAC4 soap_get_ns37__queryAppendDefInfo(struct soap *soap, struct ns37__queryAppendDefInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryAppendDefInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryAppendDefInfo * SOAP_FMAC4 soap_in_ns37__queryAppendDefInfo(struct soap *soap, const char *tag, struct ns37__queryAppendDefInfo *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryAppendDefInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryAppendDefInfo, sizeof(struct ns37__queryAppendDefInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryAppendDefInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryAppendDefInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryAppendDefInfo, 0, sizeof(struct ns37__queryAppendDefInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryAppendDefInfo * SOAP_FMAC6 soap_new_ns37__queryAppendDefInfo(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryAppendDefInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryAppendDefInfo(struct soap *soap, struct ns37__queryAppendDefInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryAppendDefInfo * SOAP_FMAC4 soap_instantiate_ns37__queryAppendDefInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryAppendDefInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryAppendDefInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryAppendDefInfo;
		if (size)
			*size = sizeof(struct ns37__queryAppendDefInfo);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryAppendDefInfo[n];
		if (size)
			*size = n * sizeof(struct ns37__queryAppendDefInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryAppendDefInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryAppendDefInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryAppendDefInfo %p -> %p\n", q, p));
	*(struct ns37__queryAppendDefInfo*)p = *(struct ns37__queryAppendDefInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryAppendDefInfoResponse(struct soap *soap, const struct ns37__queryAppendDefInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons15__RetUserAppendInfo(soap, &a->queryAppendDefInfoReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryAppendDefInfoResponse(struct soap *soap, struct ns37__queryAppendDefInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->queryAppendDefInfoReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryAppendDefInfoResponse(struct soap *soap, const struct ns37__queryAppendDefInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryAppendDefInfoResponse);
	if (soap_out_ns37__queryAppendDefInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryAppendDefInfoResponse(struct soap *soap, const char *tag, int id, const struct ns37__queryAppendDefInfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryAppendDefInfoResponse), type);
	if (a->queryAppendDefInfoReturn)
		soap_element_result(soap, "queryAppendDefInfoReturn");
	soap_out_PointerTons15__RetUserAppendInfo(soap, "queryAppendDefInfoReturn", -1, &a->queryAppendDefInfoReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryAppendDefInfoResponse * SOAP_FMAC4 soap_get_ns37__queryAppendDefInfoResponse(struct soap *soap, struct ns37__queryAppendDefInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryAppendDefInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryAppendDefInfoResponse * SOAP_FMAC4 soap_in_ns37__queryAppendDefInfoResponse(struct soap *soap, const char *tag, struct ns37__queryAppendDefInfoResponse *a, const char *type)
{
	short soap_flag_queryAppendDefInfoReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryAppendDefInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryAppendDefInfoResponse, sizeof(struct ns37__queryAppendDefInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryAppendDefInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_queryAppendDefInfoReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons15__RetUserAppendInfo(soap, "queryAppendDefInfoReturn", &a->queryAppendDefInfoReturn, "ns15:RetUserAppendInfo"))
				{	soap_flag_queryAppendDefInfoReturn--;
					continue;
				}
			soap_check_result(soap, "queryAppendDefInfoReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryAppendDefInfoResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryAppendDefInfoResponse, 0, sizeof(struct ns37__queryAppendDefInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryAppendDefInfoResponse * SOAP_FMAC6 soap_new_ns37__queryAppendDefInfoResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryAppendDefInfoResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryAppendDefInfoResponse(struct soap *soap, struct ns37__queryAppendDefInfoResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryAppendDefInfoResponse * SOAP_FMAC4 soap_instantiate_ns37__queryAppendDefInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryAppendDefInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryAppendDefInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryAppendDefInfoResponse;
		if (size)
			*size = sizeof(struct ns37__queryAppendDefInfoResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryAppendDefInfoResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__queryAppendDefInfoResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryAppendDefInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryAppendDefInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryAppendDefInfoResponse %p -> %p\n", q, p));
	*(struct ns37__queryAppendDefInfoResponse*)p = *(struct ns37__queryAppendDefInfoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryAcctServiceInfo(struct soap *soap, const struct ns37__queryAcctServiceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryAcctServiceInfo(struct soap *soap, struct ns37__queryAcctServiceInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryAcctServiceInfo(struct soap *soap, const struct ns37__queryAcctServiceInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryAcctServiceInfo);
	if (soap_out_ns37__queryAcctServiceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryAcctServiceInfo(struct soap *soap, const char *tag, int id, const struct ns37__queryAcctServiceInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryAcctServiceInfo), type);
	soap_out_string(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryAcctServiceInfo * SOAP_FMAC4 soap_get_ns37__queryAcctServiceInfo(struct soap *soap, struct ns37__queryAcctServiceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryAcctServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryAcctServiceInfo * SOAP_FMAC4 soap_in_ns37__queryAcctServiceInfo(struct soap *soap, const char *tag, struct ns37__queryAcctServiceInfo *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryAcctServiceInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryAcctServiceInfo, sizeof(struct ns37__queryAcctServiceInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryAcctServiceInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryAcctServiceInfo *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryAcctServiceInfo, 0, sizeof(struct ns37__queryAcctServiceInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryAcctServiceInfo * SOAP_FMAC6 soap_new_ns37__queryAcctServiceInfo(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryAcctServiceInfo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryAcctServiceInfo(struct soap *soap, struct ns37__queryAcctServiceInfo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryAcctServiceInfo * SOAP_FMAC4 soap_instantiate_ns37__queryAcctServiceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryAcctServiceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryAcctServiceInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryAcctServiceInfo;
		if (size)
			*size = sizeof(struct ns37__queryAcctServiceInfo);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryAcctServiceInfo[n];
		if (size)
			*size = n * sizeof(struct ns37__queryAcctServiceInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryAcctServiceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryAcctServiceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryAcctServiceInfo %p -> %p\n", q, p));
	*(struct ns37__queryAcctServiceInfo*)p = *(struct ns37__queryAcctServiceInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryAcctServiceInfoResponse(struct soap *soap, const struct ns37__queryAcctServiceInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons13__RetAcctServiceInfo(soap, &a->_queryAcctServiceInfoReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryAcctServiceInfoResponse(struct soap *soap, struct ns37__queryAcctServiceInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_queryAcctServiceInfoReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryAcctServiceInfoResponse(struct soap *soap, const struct ns37__queryAcctServiceInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryAcctServiceInfoResponse);
	if (soap_out_ns37__queryAcctServiceInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryAcctServiceInfoResponse(struct soap *soap, const char *tag, int id, const struct ns37__queryAcctServiceInfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryAcctServiceInfoResponse), type);
	if (a->_queryAcctServiceInfoReturn)
		soap_element_result(soap, "queryAcctServiceInfoReturn");
	soap_out_PointerTons13__RetAcctServiceInfo(soap, "queryAcctServiceInfoReturn", -1, &a->_queryAcctServiceInfoReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryAcctServiceInfoResponse * SOAP_FMAC4 soap_get_ns37__queryAcctServiceInfoResponse(struct soap *soap, struct ns37__queryAcctServiceInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryAcctServiceInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryAcctServiceInfoResponse * SOAP_FMAC4 soap_in_ns37__queryAcctServiceInfoResponse(struct soap *soap, const char *tag, struct ns37__queryAcctServiceInfoResponse *a, const char *type)
{
	short soap_flag__queryAcctServiceInfoReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryAcctServiceInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryAcctServiceInfoResponse, sizeof(struct ns37__queryAcctServiceInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryAcctServiceInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__queryAcctServiceInfoReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons13__RetAcctServiceInfo(soap, NULL, &a->_queryAcctServiceInfoReturn, "ns13:RetAcctServiceInfo"))
				{	soap_flag__queryAcctServiceInfoReturn--;
					continue;
				}
			soap_check_result(soap, "queryAcctServiceInfoReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryAcctServiceInfoResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryAcctServiceInfoResponse, 0, sizeof(struct ns37__queryAcctServiceInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryAcctServiceInfoResponse * SOAP_FMAC6 soap_new_ns37__queryAcctServiceInfoResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryAcctServiceInfoResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryAcctServiceInfoResponse(struct soap *soap, struct ns37__queryAcctServiceInfoResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryAcctServiceInfoResponse * SOAP_FMAC4 soap_instantiate_ns37__queryAcctServiceInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryAcctServiceInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryAcctServiceInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryAcctServiceInfoResponse;
		if (size)
			*size = sizeof(struct ns37__queryAcctServiceInfoResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryAcctServiceInfoResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__queryAcctServiceInfoResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryAcctServiceInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryAcctServiceInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryAcctServiceInfoResponse %p -> %p\n", q, p));
	*(struct ns37__queryAcctServiceInfoResponse*)p = *(struct ns37__queryAcctServiceInfoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__cancelService(struct soap *soap, const struct ns37__cancelService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons31__DelUserServiceParam(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__cancelService(struct soap *soap, struct ns37__cancelService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__cancelService(struct soap *soap, const struct ns37__cancelService *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__cancelService);
	if (soap_out_ns37__cancelService(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__cancelService(struct soap *soap, const char *tag, int id, const struct ns37__cancelService *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__cancelService), type);
	soap_out_PointerTons31__DelUserServiceParam(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__cancelService * SOAP_FMAC4 soap_get_ns37__cancelService(struct soap *soap, struct ns37__cancelService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__cancelService(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__cancelService * SOAP_FMAC4 soap_in_ns37__cancelService(struct soap *soap, const char *tag, struct ns37__cancelService *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__cancelService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__cancelService, sizeof(struct ns37__cancelService), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__cancelService(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons31__DelUserServiceParam(soap, NULL, &a->_in0, "ns31:DelUserServiceParam"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__cancelService *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__cancelService, 0, sizeof(struct ns37__cancelService), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__cancelService * SOAP_FMAC6 soap_new_ns37__cancelService(struct soap *soap, int n)
{	return soap_instantiate_ns37__cancelService(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__cancelService(struct soap *soap, struct ns37__cancelService *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__cancelService * SOAP_FMAC4 soap_instantiate_ns37__cancelService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__cancelService(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__cancelService, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__cancelService;
		if (size)
			*size = sizeof(struct ns37__cancelService);
	}
	else
	{	cp->ptr = (void*)new struct ns37__cancelService[n];
		if (size)
			*size = n * sizeof(struct ns37__cancelService);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__cancelService*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__cancelService(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__cancelService %p -> %p\n", q, p));
	*(struct ns37__cancelService*)p = *(struct ns37__cancelService*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__cancelServiceResponse(struct soap *soap, const struct ns37__cancelServiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons22__ResultBase(soap, &a->_cancelServiceReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__cancelServiceResponse(struct soap *soap, struct ns37__cancelServiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_cancelServiceReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__cancelServiceResponse(struct soap *soap, const struct ns37__cancelServiceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__cancelServiceResponse);
	if (soap_out_ns37__cancelServiceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__cancelServiceResponse(struct soap *soap, const char *tag, int id, const struct ns37__cancelServiceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__cancelServiceResponse), type);
	if (a->_cancelServiceReturn)
		soap_element_result(soap, "cancelServiceReturn");
	soap_out_PointerTons22__ResultBase(soap, "cancelServiceReturn", -1, &a->_cancelServiceReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__cancelServiceResponse * SOAP_FMAC4 soap_get_ns37__cancelServiceResponse(struct soap *soap, struct ns37__cancelServiceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__cancelServiceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__cancelServiceResponse * SOAP_FMAC4 soap_in_ns37__cancelServiceResponse(struct soap *soap, const char *tag, struct ns37__cancelServiceResponse *a, const char *type)
{
	short soap_flag__cancelServiceReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__cancelServiceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__cancelServiceResponse, sizeof(struct ns37__cancelServiceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__cancelServiceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__cancelServiceReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, NULL, &a->_cancelServiceReturn, "ns22:ResultBase"))
				{	soap_flag__cancelServiceReturn--;
					continue;
				}
			soap_check_result(soap, "cancelServiceReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__cancelServiceResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__cancelServiceResponse, 0, sizeof(struct ns37__cancelServiceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__cancelServiceResponse * SOAP_FMAC6 soap_new_ns37__cancelServiceResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__cancelServiceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__cancelServiceResponse(struct soap *soap, struct ns37__cancelServiceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__cancelServiceResponse * SOAP_FMAC4 soap_instantiate_ns37__cancelServiceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__cancelServiceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__cancelServiceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__cancelServiceResponse;
		if (size)
			*size = sizeof(struct ns37__cancelServiceResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__cancelServiceResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__cancelServiceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__cancelServiceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__cancelServiceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__cancelServiceResponse %p -> %p\n", q, p));
	*(struct ns37__cancelServiceResponse*)p = *(struct ns37__cancelServiceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__applyService(struct soap *soap, const struct ns37__applyService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons30__ApplyServiceParam(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__applyService(struct soap *soap, struct ns37__applyService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__applyService(struct soap *soap, const struct ns37__applyService *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__applyService);
	if (soap_out_ns37__applyService(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__applyService(struct soap *soap, const char *tag, int id, const struct ns37__applyService *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__applyService), type);
	soap_out_PointerTons30__ApplyServiceParam(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__applyService * SOAP_FMAC4 soap_get_ns37__applyService(struct soap *soap, struct ns37__applyService *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__applyService(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__applyService * SOAP_FMAC4 soap_in_ns37__applyService(struct soap *soap, const char *tag, struct ns37__applyService *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__applyService *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__applyService, sizeof(struct ns37__applyService), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__applyService(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons30__ApplyServiceParam(soap, NULL, &a->_in0, "ns30:ApplyServiceParam"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__applyService *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__applyService, 0, sizeof(struct ns37__applyService), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__applyService * SOAP_FMAC6 soap_new_ns37__applyService(struct soap *soap, int n)
{	return soap_instantiate_ns37__applyService(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__applyService(struct soap *soap, struct ns37__applyService *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__applyService * SOAP_FMAC4 soap_instantiate_ns37__applyService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__applyService(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__applyService, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__applyService;
		if (size)
			*size = sizeof(struct ns37__applyService);
	}
	else
	{	cp->ptr = (void*)new struct ns37__applyService[n];
		if (size)
			*size = n * sizeof(struct ns37__applyService);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__applyService*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__applyService(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__applyService %p -> %p\n", q, p));
	*(struct ns37__applyService*)p = *(struct ns37__applyService*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__applyServiceResponse(struct soap *soap, const struct ns37__applyServiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons22__ResultBase(soap, &a->_applyServiceReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__applyServiceResponse(struct soap *soap, struct ns37__applyServiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_applyServiceReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__applyServiceResponse(struct soap *soap, const struct ns37__applyServiceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__applyServiceResponse);
	if (soap_out_ns37__applyServiceResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__applyServiceResponse(struct soap *soap, const char *tag, int id, const struct ns37__applyServiceResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__applyServiceResponse), type);
	if (a->_applyServiceReturn)
		soap_element_result(soap, "applyServiceReturn");
	soap_out_PointerTons22__ResultBase(soap, "applyServiceReturn", -1, &a->_applyServiceReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__applyServiceResponse * SOAP_FMAC4 soap_get_ns37__applyServiceResponse(struct soap *soap, struct ns37__applyServiceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__applyServiceResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__applyServiceResponse * SOAP_FMAC4 soap_in_ns37__applyServiceResponse(struct soap *soap, const char *tag, struct ns37__applyServiceResponse *a, const char *type)
{
	short soap_flag__applyServiceReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__applyServiceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__applyServiceResponse, sizeof(struct ns37__applyServiceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__applyServiceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__applyServiceReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, NULL, &a->_applyServiceReturn, "ns22:ResultBase"))
				{	soap_flag__applyServiceReturn--;
					continue;
				}
			soap_check_result(soap, "applyServiceReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__applyServiceResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__applyServiceResponse, 0, sizeof(struct ns37__applyServiceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__applyServiceResponse * SOAP_FMAC6 soap_new_ns37__applyServiceResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__applyServiceResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__applyServiceResponse(struct soap *soap, struct ns37__applyServiceResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__applyServiceResponse * SOAP_FMAC4 soap_instantiate_ns37__applyServiceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__applyServiceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__applyServiceResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__applyServiceResponse;
		if (size)
			*size = sizeof(struct ns37__applyServiceResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__applyServiceResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__applyServiceResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__applyServiceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__applyServiceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__applyServiceResponse %p -> %p\n", q, p));
	*(struct ns37__applyServiceResponse*)p = *(struct ns37__applyServiceResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__changeAcctPassword(struct soap *soap, const struct ns37__changeAcctPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons29__ChgAcctPassParam(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__changeAcctPassword(struct soap *soap, struct ns37__changeAcctPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__changeAcctPassword(struct soap *soap, const struct ns37__changeAcctPassword *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__changeAcctPassword);
	if (soap_out_ns37__changeAcctPassword(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__changeAcctPassword(struct soap *soap, const char *tag, int id, const struct ns37__changeAcctPassword *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__changeAcctPassword), type);
	soap_out_PointerTons29__ChgAcctPassParam(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__changeAcctPassword * SOAP_FMAC4 soap_get_ns37__changeAcctPassword(struct soap *soap, struct ns37__changeAcctPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__changeAcctPassword(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__changeAcctPassword * SOAP_FMAC4 soap_in_ns37__changeAcctPassword(struct soap *soap, const char *tag, struct ns37__changeAcctPassword *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__changeAcctPassword *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__changeAcctPassword, sizeof(struct ns37__changeAcctPassword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__changeAcctPassword(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons29__ChgAcctPassParam(soap, NULL, &a->_in0, "ns29:ChgAcctPassParam"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__changeAcctPassword *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__changeAcctPassword, 0, sizeof(struct ns37__changeAcctPassword), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__changeAcctPassword * SOAP_FMAC6 soap_new_ns37__changeAcctPassword(struct soap *soap, int n)
{	return soap_instantiate_ns37__changeAcctPassword(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__changeAcctPassword(struct soap *soap, struct ns37__changeAcctPassword *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__changeAcctPassword * SOAP_FMAC4 soap_instantiate_ns37__changeAcctPassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__changeAcctPassword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__changeAcctPassword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__changeAcctPassword;
		if (size)
			*size = sizeof(struct ns37__changeAcctPassword);
	}
	else
	{	cp->ptr = (void*)new struct ns37__changeAcctPassword[n];
		if (size)
			*size = n * sizeof(struct ns37__changeAcctPassword);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__changeAcctPassword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__changeAcctPassword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__changeAcctPassword %p -> %p\n", q, p));
	*(struct ns37__changeAcctPassword*)p = *(struct ns37__changeAcctPassword*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__changeAcctPasswordResponse(struct soap *soap, const struct ns37__changeAcctPasswordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons22__ResultBase(soap, &a->_changeAcctPasswordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__changeAcctPasswordResponse(struct soap *soap, struct ns37__changeAcctPasswordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_changeAcctPasswordReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__changeAcctPasswordResponse(struct soap *soap, const struct ns37__changeAcctPasswordResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__changeAcctPasswordResponse);
	if (soap_out_ns37__changeAcctPasswordResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__changeAcctPasswordResponse(struct soap *soap, const char *tag, int id, const struct ns37__changeAcctPasswordResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__changeAcctPasswordResponse), type);
	if (a->_changeAcctPasswordReturn)
		soap_element_result(soap, "changeAcctPasswordReturn");
	soap_out_PointerTons22__ResultBase(soap, "changeAcctPasswordReturn", -1, &a->_changeAcctPasswordReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__changeAcctPasswordResponse * SOAP_FMAC4 soap_get_ns37__changeAcctPasswordResponse(struct soap *soap, struct ns37__changeAcctPasswordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__changeAcctPasswordResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__changeAcctPasswordResponse * SOAP_FMAC4 soap_in_ns37__changeAcctPasswordResponse(struct soap *soap, const char *tag, struct ns37__changeAcctPasswordResponse *a, const char *type)
{
	short soap_flag__changeAcctPasswordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__changeAcctPasswordResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__changeAcctPasswordResponse, sizeof(struct ns37__changeAcctPasswordResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__changeAcctPasswordResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__changeAcctPasswordReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, NULL, &a->_changeAcctPasswordReturn, "ns22:ResultBase"))
				{	soap_flag__changeAcctPasswordReturn--;
					continue;
				}
			soap_check_result(soap, "changeAcctPasswordReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__changeAcctPasswordResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__changeAcctPasswordResponse, 0, sizeof(struct ns37__changeAcctPasswordResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__changeAcctPasswordResponse * SOAP_FMAC6 soap_new_ns37__changeAcctPasswordResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__changeAcctPasswordResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__changeAcctPasswordResponse(struct soap *soap, struct ns37__changeAcctPasswordResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__changeAcctPasswordResponse * SOAP_FMAC4 soap_instantiate_ns37__changeAcctPasswordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__changeAcctPasswordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__changeAcctPasswordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__changeAcctPasswordResponse;
		if (size)
			*size = sizeof(struct ns37__changeAcctPasswordResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__changeAcctPasswordResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__changeAcctPasswordResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__changeAcctPasswordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__changeAcctPasswordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__changeAcctPasswordResponse %p -> %p\n", q, p));
	*(struct ns37__changeAcctPasswordResponse*)p = *(struct ns37__changeAcctPasswordResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryAcctPassword(struct soap *soap, const struct ns37__queryAcctPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryAcctPassword(struct soap *soap, struct ns37__queryAcctPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryAcctPassword(struct soap *soap, const struct ns37__queryAcctPassword *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryAcctPassword);
	if (soap_out_ns37__queryAcctPassword(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryAcctPassword(struct soap *soap, const char *tag, int id, const struct ns37__queryAcctPassword *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryAcctPassword), type);
	soap_out_string(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryAcctPassword * SOAP_FMAC4 soap_get_ns37__queryAcctPassword(struct soap *soap, struct ns37__queryAcctPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryAcctPassword(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryAcctPassword * SOAP_FMAC4 soap_in_ns37__queryAcctPassword(struct soap *soap, const char *tag, struct ns37__queryAcctPassword *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryAcctPassword *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryAcctPassword, sizeof(struct ns37__queryAcctPassword), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryAcctPassword(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryAcctPassword *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryAcctPassword, 0, sizeof(struct ns37__queryAcctPassword), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryAcctPassword * SOAP_FMAC6 soap_new_ns37__queryAcctPassword(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryAcctPassword(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryAcctPassword(struct soap *soap, struct ns37__queryAcctPassword *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryAcctPassword * SOAP_FMAC4 soap_instantiate_ns37__queryAcctPassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryAcctPassword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryAcctPassword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryAcctPassword;
		if (size)
			*size = sizeof(struct ns37__queryAcctPassword);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryAcctPassword[n];
		if (size)
			*size = n * sizeof(struct ns37__queryAcctPassword);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryAcctPassword*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryAcctPassword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryAcctPassword %p -> %p\n", q, p));
	*(struct ns37__queryAcctPassword*)p = *(struct ns37__queryAcctPassword*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryAcctPasswordResponse(struct soap *soap, const struct ns37__queryAcctPasswordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons11__RetPassword(soap, &a->_queryAcctPasswordReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryAcctPasswordResponse(struct soap *soap, struct ns37__queryAcctPasswordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_queryAcctPasswordReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryAcctPasswordResponse(struct soap *soap, const struct ns37__queryAcctPasswordResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryAcctPasswordResponse);
	if (soap_out_ns37__queryAcctPasswordResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryAcctPasswordResponse(struct soap *soap, const char *tag, int id, const struct ns37__queryAcctPasswordResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryAcctPasswordResponse), type);
	if (a->_queryAcctPasswordReturn)
		soap_element_result(soap, "queryAcctPasswordReturn");
	soap_out_PointerTons11__RetPassword(soap, "queryAcctPasswordReturn", -1, &a->_queryAcctPasswordReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryAcctPasswordResponse * SOAP_FMAC4 soap_get_ns37__queryAcctPasswordResponse(struct soap *soap, struct ns37__queryAcctPasswordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryAcctPasswordResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryAcctPasswordResponse * SOAP_FMAC4 soap_in_ns37__queryAcctPasswordResponse(struct soap *soap, const char *tag, struct ns37__queryAcctPasswordResponse *a, const char *type)
{
	short soap_flag__queryAcctPasswordReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryAcctPasswordResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryAcctPasswordResponse, sizeof(struct ns37__queryAcctPasswordResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryAcctPasswordResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__queryAcctPasswordReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons11__RetPassword(soap, NULL, &a->_queryAcctPasswordReturn, "ns11:RetPassword"))
				{	soap_flag__queryAcctPasswordReturn--;
					continue;
				}
			soap_check_result(soap, "queryAcctPasswordReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryAcctPasswordResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryAcctPasswordResponse, 0, sizeof(struct ns37__queryAcctPasswordResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryAcctPasswordResponse * SOAP_FMAC6 soap_new_ns37__queryAcctPasswordResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryAcctPasswordResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryAcctPasswordResponse(struct soap *soap, struct ns37__queryAcctPasswordResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryAcctPasswordResponse * SOAP_FMAC4 soap_instantiate_ns37__queryAcctPasswordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryAcctPasswordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryAcctPasswordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryAcctPasswordResponse;
		if (size)
			*size = sizeof(struct ns37__queryAcctPasswordResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryAcctPasswordResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__queryAcctPasswordResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryAcctPasswordResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryAcctPasswordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryAcctPasswordResponse %p -> %p\n", q, p));
	*(struct ns37__queryAcctPasswordResponse*)p = *(struct ns37__queryAcctPasswordResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryAcctByName(struct soap *soap, const struct ns37__queryAcctByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryAcctByName(struct soap *soap, struct ns37__queryAcctByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryAcctByName(struct soap *soap, const struct ns37__queryAcctByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryAcctByName);
	if (soap_out_ns37__queryAcctByName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryAcctByName(struct soap *soap, const char *tag, int id, const struct ns37__queryAcctByName *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryAcctByName), type);
	soap_out_string(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryAcctByName * SOAP_FMAC4 soap_get_ns37__queryAcctByName(struct soap *soap, struct ns37__queryAcctByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryAcctByName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryAcctByName * SOAP_FMAC4 soap_in_ns37__queryAcctByName(struct soap *soap, const char *tag, struct ns37__queryAcctByName *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryAcctByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryAcctByName, sizeof(struct ns37__queryAcctByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryAcctByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_in0, "xsd:string"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryAcctByName *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryAcctByName, 0, sizeof(struct ns37__queryAcctByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryAcctByName * SOAP_FMAC6 soap_new_ns37__queryAcctByName(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryAcctByName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryAcctByName(struct soap *soap, struct ns37__queryAcctByName *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryAcctByName * SOAP_FMAC4 soap_instantiate_ns37__queryAcctByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryAcctByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryAcctByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryAcctByName;
		if (size)
			*size = sizeof(struct ns37__queryAcctByName);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryAcctByName[n];
		if (size)
			*size = n * sizeof(struct ns37__queryAcctByName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryAcctByName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryAcctByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryAcctByName %p -> %p\n", q, p));
	*(struct ns37__queryAcctByName*)p = *(struct ns37__queryAcctByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__queryAcctByNameResponse(struct soap *soap, const struct ns37__queryAcctByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons8__RetUserInfo(soap, &a->_queryAcctByNameReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__queryAcctByNameResponse(struct soap *soap, struct ns37__queryAcctByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_queryAcctByNameReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__queryAcctByNameResponse(struct soap *soap, const struct ns37__queryAcctByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__queryAcctByNameResponse);
	if (soap_out_ns37__queryAcctByNameResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__queryAcctByNameResponse(struct soap *soap, const char *tag, int id, const struct ns37__queryAcctByNameResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__queryAcctByNameResponse), type);
	if (a->_queryAcctByNameReturn)
		soap_element_result(soap, "queryAcctByNameReturn");
	soap_out_PointerTons8__RetUserInfo(soap, "queryAcctByNameReturn", -1, &a->_queryAcctByNameReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__queryAcctByNameResponse * SOAP_FMAC4 soap_get_ns37__queryAcctByNameResponse(struct soap *soap, struct ns37__queryAcctByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__queryAcctByNameResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__queryAcctByNameResponse * SOAP_FMAC4 soap_in_ns37__queryAcctByNameResponse(struct soap *soap, const char *tag, struct ns37__queryAcctByNameResponse *a, const char *type)
{
	short soap_flag__queryAcctByNameReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__queryAcctByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__queryAcctByNameResponse, sizeof(struct ns37__queryAcctByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__queryAcctByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__queryAcctByNameReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons8__RetUserInfo(soap, NULL, &a->_queryAcctByNameReturn, "ns8:RetUserInfo"))
				{	soap_flag__queryAcctByNameReturn--;
					continue;
				}
			soap_check_result(soap, "queryAcctByNameReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__queryAcctByNameResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__queryAcctByNameResponse, 0, sizeof(struct ns37__queryAcctByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__queryAcctByNameResponse * SOAP_FMAC6 soap_new_ns37__queryAcctByNameResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__queryAcctByNameResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__queryAcctByNameResponse(struct soap *soap, struct ns37__queryAcctByNameResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__queryAcctByNameResponse * SOAP_FMAC4 soap_instantiate_ns37__queryAcctByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__queryAcctByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__queryAcctByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__queryAcctByNameResponse;
		if (size)
			*size = sizeof(struct ns37__queryAcctByNameResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__queryAcctByNameResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__queryAcctByNameResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__queryAcctByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__queryAcctByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__queryAcctByNameResponse %p -> %p\n", q, p));
	*(struct ns37__queryAcctByNameResponse*)p = *(struct ns37__queryAcctByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__deleteAcctUser(struct soap *soap, const struct ns37__deleteAcctUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons28__DelAcctParam(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__deleteAcctUser(struct soap *soap, struct ns37__deleteAcctUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__deleteAcctUser(struct soap *soap, const struct ns37__deleteAcctUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__deleteAcctUser);
	if (soap_out_ns37__deleteAcctUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__deleteAcctUser(struct soap *soap, const char *tag, int id, const struct ns37__deleteAcctUser *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__deleteAcctUser), type);
	soap_out_PointerTons28__DelAcctParam(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__deleteAcctUser * SOAP_FMAC4 soap_get_ns37__deleteAcctUser(struct soap *soap, struct ns37__deleteAcctUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__deleteAcctUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__deleteAcctUser * SOAP_FMAC4 soap_in_ns37__deleteAcctUser(struct soap *soap, const char *tag, struct ns37__deleteAcctUser *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__deleteAcctUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__deleteAcctUser, sizeof(struct ns37__deleteAcctUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__deleteAcctUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons28__DelAcctParam(soap, NULL, &a->_in0, "ns28:DelAcctParam"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__deleteAcctUser *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__deleteAcctUser, 0, sizeof(struct ns37__deleteAcctUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__deleteAcctUser * SOAP_FMAC6 soap_new_ns37__deleteAcctUser(struct soap *soap, int n)
{	return soap_instantiate_ns37__deleteAcctUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__deleteAcctUser(struct soap *soap, struct ns37__deleteAcctUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__deleteAcctUser * SOAP_FMAC4 soap_instantiate_ns37__deleteAcctUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__deleteAcctUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__deleteAcctUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__deleteAcctUser;
		if (size)
			*size = sizeof(struct ns37__deleteAcctUser);
	}
	else
	{	cp->ptr = (void*)new struct ns37__deleteAcctUser[n];
		if (size)
			*size = n * sizeof(struct ns37__deleteAcctUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__deleteAcctUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__deleteAcctUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__deleteAcctUser %p -> %p\n", q, p));
	*(struct ns37__deleteAcctUser*)p = *(struct ns37__deleteAcctUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__deleteAcctUserResponse(struct soap *soap, const struct ns37__deleteAcctUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__RetDelUserInfo(soap, &a->_deleteAcctUserReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__deleteAcctUserResponse(struct soap *soap, struct ns37__deleteAcctUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_deleteAcctUserReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__deleteAcctUserResponse(struct soap *soap, const struct ns37__deleteAcctUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__deleteAcctUserResponse);
	if (soap_out_ns37__deleteAcctUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__deleteAcctUserResponse(struct soap *soap, const char *tag, int id, const struct ns37__deleteAcctUserResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__deleteAcctUserResponse), type);
	if (a->_deleteAcctUserReturn)
		soap_element_result(soap, "deleteAcctUserReturn");
	soap_out_PointerTons3__RetDelUserInfo(soap, "deleteAcctUserReturn", -1, &a->_deleteAcctUserReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__deleteAcctUserResponse * SOAP_FMAC4 soap_get_ns37__deleteAcctUserResponse(struct soap *soap, struct ns37__deleteAcctUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__deleteAcctUserResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__deleteAcctUserResponse * SOAP_FMAC4 soap_in_ns37__deleteAcctUserResponse(struct soap *soap, const char *tag, struct ns37__deleteAcctUserResponse *a, const char *type)
{
	short soap_flag__deleteAcctUserReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__deleteAcctUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__deleteAcctUserResponse, sizeof(struct ns37__deleteAcctUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__deleteAcctUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__deleteAcctUserReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__RetDelUserInfo(soap, NULL, &a->_deleteAcctUserReturn, "ns3:RetDelUserInfo"))
				{	soap_flag__deleteAcctUserReturn--;
					continue;
				}
			soap_check_result(soap, "deleteAcctUserReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__deleteAcctUserResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__deleteAcctUserResponse, 0, sizeof(struct ns37__deleteAcctUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__deleteAcctUserResponse * SOAP_FMAC6 soap_new_ns37__deleteAcctUserResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__deleteAcctUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__deleteAcctUserResponse(struct soap *soap, struct ns37__deleteAcctUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__deleteAcctUserResponse * SOAP_FMAC4 soap_instantiate_ns37__deleteAcctUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__deleteAcctUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__deleteAcctUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__deleteAcctUserResponse;
		if (size)
			*size = sizeof(struct ns37__deleteAcctUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__deleteAcctUserResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__deleteAcctUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__deleteAcctUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__deleteAcctUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__deleteAcctUserResponse %p -> %p\n", q, p));
	*(struct ns37__deleteAcctUserResponse*)p = *(struct ns37__deleteAcctUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__modifyAcctUser(struct soap *soap, const struct ns37__modifyAcctUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons27__ModifyAcctParam(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__modifyAcctUser(struct soap *soap, struct ns37__modifyAcctUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__modifyAcctUser(struct soap *soap, const struct ns37__modifyAcctUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__modifyAcctUser);
	if (soap_out_ns37__modifyAcctUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__modifyAcctUser(struct soap *soap, const char *tag, int id, const struct ns37__modifyAcctUser *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__modifyAcctUser), type);
	soap_out_PointerTons27__ModifyAcctParam(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__modifyAcctUser * SOAP_FMAC4 soap_get_ns37__modifyAcctUser(struct soap *soap, struct ns37__modifyAcctUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__modifyAcctUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__modifyAcctUser * SOAP_FMAC4 soap_in_ns37__modifyAcctUser(struct soap *soap, const char *tag, struct ns37__modifyAcctUser *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__modifyAcctUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__modifyAcctUser, sizeof(struct ns37__modifyAcctUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__modifyAcctUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons27__ModifyAcctParam(soap, NULL, &a->_in0, "ns27:ModifyAcctParam"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__modifyAcctUser *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__modifyAcctUser, 0, sizeof(struct ns37__modifyAcctUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__modifyAcctUser * SOAP_FMAC6 soap_new_ns37__modifyAcctUser(struct soap *soap, int n)
{	return soap_instantiate_ns37__modifyAcctUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__modifyAcctUser(struct soap *soap, struct ns37__modifyAcctUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__modifyAcctUser * SOAP_FMAC4 soap_instantiate_ns37__modifyAcctUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__modifyAcctUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__modifyAcctUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__modifyAcctUser;
		if (size)
			*size = sizeof(struct ns37__modifyAcctUser);
	}
	else
	{	cp->ptr = (void*)new struct ns37__modifyAcctUser[n];
		if (size)
			*size = n * sizeof(struct ns37__modifyAcctUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__modifyAcctUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__modifyAcctUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__modifyAcctUser %p -> %p\n", q, p));
	*(struct ns37__modifyAcctUser*)p = *(struct ns37__modifyAcctUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__modifyAcctUserResponse(struct soap *soap, const struct ns37__modifyAcctUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons22__ResultBase(soap, &a->_modifyAcctUserReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__modifyAcctUserResponse(struct soap *soap, struct ns37__modifyAcctUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_modifyAcctUserReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__modifyAcctUserResponse(struct soap *soap, const struct ns37__modifyAcctUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__modifyAcctUserResponse);
	if (soap_out_ns37__modifyAcctUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__modifyAcctUserResponse(struct soap *soap, const char *tag, int id, const struct ns37__modifyAcctUserResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__modifyAcctUserResponse), type);
	if (a->_modifyAcctUserReturn)
		soap_element_result(soap, "modifyAcctUserReturn");
	soap_out_PointerTons22__ResultBase(soap, "modifyAcctUserReturn", -1, &a->_modifyAcctUserReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__modifyAcctUserResponse * SOAP_FMAC4 soap_get_ns37__modifyAcctUserResponse(struct soap *soap, struct ns37__modifyAcctUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__modifyAcctUserResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__modifyAcctUserResponse * SOAP_FMAC4 soap_in_ns37__modifyAcctUserResponse(struct soap *soap, const char *tag, struct ns37__modifyAcctUserResponse *a, const char *type)
{
	short soap_flag__modifyAcctUserReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__modifyAcctUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__modifyAcctUserResponse, sizeof(struct ns37__modifyAcctUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__modifyAcctUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__modifyAcctUserReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, NULL, &a->_modifyAcctUserReturn, "ns22:ResultBase"))
				{	soap_flag__modifyAcctUserReturn--;
					continue;
				}
			soap_check_result(soap, "modifyAcctUserReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__modifyAcctUserResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__modifyAcctUserResponse, 0, sizeof(struct ns37__modifyAcctUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__modifyAcctUserResponse * SOAP_FMAC6 soap_new_ns37__modifyAcctUserResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__modifyAcctUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__modifyAcctUserResponse(struct soap *soap, struct ns37__modifyAcctUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__modifyAcctUserResponse * SOAP_FMAC4 soap_instantiate_ns37__modifyAcctUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__modifyAcctUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__modifyAcctUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__modifyAcctUserResponse;
		if (size)
			*size = sizeof(struct ns37__modifyAcctUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__modifyAcctUserResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__modifyAcctUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__modifyAcctUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__modifyAcctUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__modifyAcctUserResponse %p -> %p\n", q, p));
	*(struct ns37__modifyAcctUserResponse*)p = *(struct ns37__modifyAcctUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__addAcctUser(struct soap *soap, const struct ns37__addAcctUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons26__AddAcctParam(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__addAcctUser(struct soap *soap, struct ns37__addAcctUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__addAcctUser(struct soap *soap, const struct ns37__addAcctUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__addAcctUser);
	if (soap_out_ns37__addAcctUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__addAcctUser(struct soap *soap, const char *tag, int id, const struct ns37__addAcctUser *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__addAcctUser), type);
	soap_out_PointerTons26__AddAcctParam(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__addAcctUser * SOAP_FMAC4 soap_get_ns37__addAcctUser(struct soap *soap, struct ns37__addAcctUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__addAcctUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__addAcctUser * SOAP_FMAC4 soap_in_ns37__addAcctUser(struct soap *soap, const char *tag, struct ns37__addAcctUser *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__addAcctUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__addAcctUser, sizeof(struct ns37__addAcctUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__addAcctUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons26__AddAcctParam(soap, NULL, &a->_in0, "ns26:AddAcctParam"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__addAcctUser *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__addAcctUser, 0, sizeof(struct ns37__addAcctUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__addAcctUser * SOAP_FMAC6 soap_new_ns37__addAcctUser(struct soap *soap, int n)
{	return soap_instantiate_ns37__addAcctUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__addAcctUser(struct soap *soap, struct ns37__addAcctUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__addAcctUser * SOAP_FMAC4 soap_instantiate_ns37__addAcctUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__addAcctUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__addAcctUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__addAcctUser;
		if (size)
			*size = sizeof(struct ns37__addAcctUser);
	}
	else
	{	cp->ptr = (void*)new struct ns37__addAcctUser[n];
		if (size)
			*size = n * sizeof(struct ns37__addAcctUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__addAcctUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__addAcctUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__addAcctUser %p -> %p\n", q, p));
	*(struct ns37__addAcctUser*)p = *(struct ns37__addAcctUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__addAcctUserResponse(struct soap *soap, const struct ns37__addAcctUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons22__ResultBase(soap, &a->_addAcctUserReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__addAcctUserResponse(struct soap *soap, struct ns37__addAcctUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_addAcctUserReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__addAcctUserResponse(struct soap *soap, const struct ns37__addAcctUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__addAcctUserResponse);
	if (soap_out_ns37__addAcctUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__addAcctUserResponse(struct soap *soap, const char *tag, int id, const struct ns37__addAcctUserResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__addAcctUserResponse), type);
	if (a->_addAcctUserReturn)
		soap_element_result(soap, "addAcctUserReturn");
	soap_out_PointerTons22__ResultBase(soap, "addAcctUserReturn", -1, &a->_addAcctUserReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__addAcctUserResponse * SOAP_FMAC4 soap_get_ns37__addAcctUserResponse(struct soap *soap, struct ns37__addAcctUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__addAcctUserResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__addAcctUserResponse * SOAP_FMAC4 soap_in_ns37__addAcctUserResponse(struct soap *soap, const char *tag, struct ns37__addAcctUserResponse *a, const char *type)
{
	short soap_flag__addAcctUserReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__addAcctUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__addAcctUserResponse, sizeof(struct ns37__addAcctUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__addAcctUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addAcctUserReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, NULL, &a->_addAcctUserReturn, "ns22:ResultBase"))
				{	soap_flag__addAcctUserReturn--;
					continue;
				}
			soap_check_result(soap, "addAcctUserReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__addAcctUserResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__addAcctUserResponse, 0, sizeof(struct ns37__addAcctUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__addAcctUserResponse * SOAP_FMAC6 soap_new_ns37__addAcctUserResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__addAcctUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__addAcctUserResponse(struct soap *soap, struct ns37__addAcctUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__addAcctUserResponse * SOAP_FMAC4 soap_instantiate_ns37__addAcctUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__addAcctUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__addAcctUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__addAcctUserResponse;
		if (size)
			*size = sizeof(struct ns37__addAcctUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__addAcctUserResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__addAcctUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__addAcctUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__addAcctUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__addAcctUserResponse %p -> %p\n", q, p));
	*(struct ns37__addAcctUserResponse*)p = *(struct ns37__addAcctUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__multiQuery(struct soap *soap, const struct ns37__multiQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons24__QueryActionInfo(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__multiQuery(struct soap *soap, struct ns37__multiQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__multiQuery(struct soap *soap, const struct ns37__multiQuery *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__multiQuery);
	if (soap_out_ns37__multiQuery(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__multiQuery(struct soap *soap, const char *tag, int id, const struct ns37__multiQuery *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__multiQuery), type);
	soap_out_PointerTons24__QueryActionInfo(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__multiQuery * SOAP_FMAC4 soap_get_ns37__multiQuery(struct soap *soap, struct ns37__multiQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__multiQuery(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__multiQuery * SOAP_FMAC4 soap_in_ns37__multiQuery(struct soap *soap, const char *tag, struct ns37__multiQuery *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__multiQuery *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__multiQuery, sizeof(struct ns37__multiQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__multiQuery(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons24__QueryActionInfo(soap, NULL, &a->_in0, "ns24:QueryActionInfo"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__multiQuery *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__multiQuery, 0, sizeof(struct ns37__multiQuery), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__multiQuery * SOAP_FMAC6 soap_new_ns37__multiQuery(struct soap *soap, int n)
{	return soap_instantiate_ns37__multiQuery(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__multiQuery(struct soap *soap, struct ns37__multiQuery *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__multiQuery * SOAP_FMAC4 soap_instantiate_ns37__multiQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__multiQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__multiQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__multiQuery;
		if (size)
			*size = sizeof(struct ns37__multiQuery);
	}
	else
	{	cp->ptr = (void*)new struct ns37__multiQuery[n];
		if (size)
			*size = n * sizeof(struct ns37__multiQuery);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__multiQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__multiQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__multiQuery %p -> %p\n", q, p));
	*(struct ns37__multiQuery*)p = *(struct ns37__multiQuery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__multiQueryResponse(struct soap *soap, const struct ns37__multiQueryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons7__MultiResult(soap, &a->_multiQueryReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__multiQueryResponse(struct soap *soap, struct ns37__multiQueryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_multiQueryReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__multiQueryResponse(struct soap *soap, const struct ns37__multiQueryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__multiQueryResponse);
	if (soap_out_ns37__multiQueryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__multiQueryResponse(struct soap *soap, const char *tag, int id, const struct ns37__multiQueryResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__multiQueryResponse), type);
	if (a->_multiQueryReturn)
		soap_element_result(soap, "multiQueryReturn");
	soap_out_PointerTons7__MultiResult(soap, "multiQueryReturn", -1, &a->_multiQueryReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__multiQueryResponse * SOAP_FMAC4 soap_get_ns37__multiQueryResponse(struct soap *soap, struct ns37__multiQueryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__multiQueryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__multiQueryResponse * SOAP_FMAC4 soap_in_ns37__multiQueryResponse(struct soap *soap, const char *tag, struct ns37__multiQueryResponse *a, const char *type)
{
	short soap_flag__multiQueryReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__multiQueryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__multiQueryResponse, sizeof(struct ns37__multiQueryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__multiQueryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__multiQueryReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__MultiResult(soap, NULL, &a->_multiQueryReturn, "ns7:MultiResult"))
				{	soap_flag__multiQueryReturn--;
					continue;
				}
			soap_check_result(soap, "multiQueryReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__multiQueryResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__multiQueryResponse, 0, sizeof(struct ns37__multiQueryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__multiQueryResponse * SOAP_FMAC6 soap_new_ns37__multiQueryResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__multiQueryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__multiQueryResponse(struct soap *soap, struct ns37__multiQueryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__multiQueryResponse * SOAP_FMAC4 soap_instantiate_ns37__multiQueryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__multiQueryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__multiQueryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__multiQueryResponse;
		if (size)
			*size = sizeof(struct ns37__multiQueryResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__multiQueryResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__multiQueryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__multiQueryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__multiQueryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__multiQueryResponse %p -> %p\n", q, p));
	*(struct ns37__multiQueryResponse*)p = *(struct ns37__multiQueryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__singleQuery(struct soap *soap, const struct ns37__singleQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons24__QueryActionInfo(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__singleQuery(struct soap *soap, struct ns37__singleQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__singleQuery(struct soap *soap, const struct ns37__singleQuery *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__singleQuery);
	if (soap_out_ns37__singleQuery(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__singleQuery(struct soap *soap, const char *tag, int id, const struct ns37__singleQuery *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__singleQuery), type);
	soap_out_PointerTons24__QueryActionInfo(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__singleQuery * SOAP_FMAC4 soap_get_ns37__singleQuery(struct soap *soap, struct ns37__singleQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__singleQuery(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__singleQuery * SOAP_FMAC4 soap_in_ns37__singleQuery(struct soap *soap, const char *tag, struct ns37__singleQuery *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__singleQuery *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__singleQuery, sizeof(struct ns37__singleQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__singleQuery(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons24__QueryActionInfo(soap, NULL, &a->_in0, "ns24:QueryActionInfo"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__singleQuery *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__singleQuery, 0, sizeof(struct ns37__singleQuery), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__singleQuery * SOAP_FMAC6 soap_new_ns37__singleQuery(struct soap *soap, int n)
{	return soap_instantiate_ns37__singleQuery(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__singleQuery(struct soap *soap, struct ns37__singleQuery *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__singleQuery * SOAP_FMAC4 soap_instantiate_ns37__singleQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__singleQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__singleQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__singleQuery;
		if (size)
			*size = sizeof(struct ns37__singleQuery);
	}
	else
	{	cp->ptr = (void*)new struct ns37__singleQuery[n];
		if (size)
			*size = n * sizeof(struct ns37__singleQuery);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__singleQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__singleQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__singleQuery %p -> %p\n", q, p));
	*(struct ns37__singleQuery*)p = *(struct ns37__singleQuery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__singleQueryResponse(struct soap *soap, const struct ns37__singleQueryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons20__SingleResult(soap, &a->_singleQueryReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__singleQueryResponse(struct soap *soap, struct ns37__singleQueryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_singleQueryReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__singleQueryResponse(struct soap *soap, const struct ns37__singleQueryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__singleQueryResponse);
	if (soap_out_ns37__singleQueryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__singleQueryResponse(struct soap *soap, const char *tag, int id, const struct ns37__singleQueryResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__singleQueryResponse), type);
	if (a->_singleQueryReturn)
		soap_element_result(soap, "singleQueryReturn");
	soap_out_PointerTons20__SingleResult(soap, "singleQueryReturn", -1, &a->_singleQueryReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__singleQueryResponse * SOAP_FMAC4 soap_get_ns37__singleQueryResponse(struct soap *soap, struct ns37__singleQueryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__singleQueryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__singleQueryResponse * SOAP_FMAC4 soap_in_ns37__singleQueryResponse(struct soap *soap, const char *tag, struct ns37__singleQueryResponse *a, const char *type)
{
	short soap_flag__singleQueryReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__singleQueryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__singleQueryResponse, sizeof(struct ns37__singleQueryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__singleQueryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__singleQueryReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons20__SingleResult(soap, NULL, &a->_singleQueryReturn, "ns20:SingleResult"))
				{	soap_flag__singleQueryReturn--;
					continue;
				}
			soap_check_result(soap, "singleQueryReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__singleQueryResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__singleQueryResponse, 0, sizeof(struct ns37__singleQueryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__singleQueryResponse * SOAP_FMAC6 soap_new_ns37__singleQueryResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__singleQueryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__singleQueryResponse(struct soap *soap, struct ns37__singleQueryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__singleQueryResponse * SOAP_FMAC4 soap_instantiate_ns37__singleQueryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__singleQueryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__singleQueryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__singleQueryResponse;
		if (size)
			*size = sizeof(struct ns37__singleQueryResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__singleQueryResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__singleQueryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__singleQueryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__singleQueryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__singleQueryResponse %p -> %p\n", q, p));
	*(struct ns37__singleQueryResponse*)p = *(struct ns37__singleQueryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__logout(struct soap *soap, const struct ns37__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__logout(struct soap *soap, struct ns37__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__logout(struct soap *soap, const struct ns37__logout *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__logout);
	if (soap_out_ns37__logout(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__logout(struct soap *soap, const char *tag, int id, const struct ns37__logout *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__logout), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__logout * SOAP_FMAC4 soap_get_ns37__logout(struct soap *soap, struct ns37__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__logout(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__logout * SOAP_FMAC4 soap_in_ns37__logout(struct soap *soap, const char *tag, struct ns37__logout *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__logout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__logout, sizeof(struct ns37__logout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__logout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__logout *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__logout, 0, sizeof(struct ns37__logout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__logout * SOAP_FMAC6 soap_new_ns37__logout(struct soap *soap, int n)
{	return soap_instantiate_ns37__logout(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__logout(struct soap *soap, struct ns37__logout *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__logout * SOAP_FMAC4 soap_instantiate_ns37__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__logout;
		if (size)
			*size = sizeof(struct ns37__logout);
	}
	else
	{	cp->ptr = (void*)new struct ns37__logout[n];
		if (size)
			*size = n * sizeof(struct ns37__logout);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__logout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__logout %p -> %p\n", q, p));
	*(struct ns37__logout*)p = *(struct ns37__logout*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__logoutResponse(struct soap *soap, const struct ns37__logoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons22__ResultBase(soap, &a->logoutReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__logoutResponse(struct soap *soap, struct ns37__logoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->logoutReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__logoutResponse(struct soap *soap, const struct ns37__logoutResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__logoutResponse);
	if (soap_out_ns37__logoutResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__logoutResponse(struct soap *soap, const char *tag, int id, const struct ns37__logoutResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__logoutResponse), type);
	if (a->logoutReturn)
		soap_element_result(soap, "logoutReturn");
	soap_out_PointerTons22__ResultBase(soap, "logoutReturn", -1, &a->logoutReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__logoutResponse * SOAP_FMAC4 soap_get_ns37__logoutResponse(struct soap *soap, struct ns37__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__logoutResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__logoutResponse * SOAP_FMAC4 soap_in_ns37__logoutResponse(struct soap *soap, const char *tag, struct ns37__logoutResponse *a, const char *type)
{
	short soap_flag_logoutReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__logoutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__logoutResponse, sizeof(struct ns37__logoutResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__logoutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_logoutReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, "logoutReturn", &a->logoutReturn, "ns22:ResultBase"))
				{	soap_flag_logoutReturn--;
					continue;
				}
			soap_check_result(soap, "logoutReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__logoutResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__logoutResponse, 0, sizeof(struct ns37__logoutResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__logoutResponse * SOAP_FMAC6 soap_new_ns37__logoutResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__logoutResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__logoutResponse(struct soap *soap, struct ns37__logoutResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__logoutResponse * SOAP_FMAC4 soap_instantiate_ns37__logoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__logoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__logoutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__logoutResponse;
		if (size)
			*size = sizeof(struct ns37__logoutResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__logoutResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__logoutResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__logoutResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__logoutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__logoutResponse %p -> %p\n", q, p));
	*(struct ns37__logoutResponse*)p = *(struct ns37__logoutResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__login(struct soap *soap, const struct ns37__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons23__OperatorInfo(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__login(struct soap *soap, struct ns37__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__login(struct soap *soap, const struct ns37__login *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__login);
	if (soap_out_ns37__login(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__login(struct soap *soap, const char *tag, int id, const struct ns37__login *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__login), type);
	soap_out_PointerTons23__OperatorInfo(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__login * SOAP_FMAC4 soap_get_ns37__login(struct soap *soap, struct ns37__login *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__login(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__login * SOAP_FMAC4 soap_in_ns37__login(struct soap *soap, const char *tag, struct ns37__login *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__login, sizeof(struct ns37__login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__login(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons23__OperatorInfo(soap, NULL, &a->_in0, "ns23:OperatorInfo"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__login *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__login, 0, sizeof(struct ns37__login), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__login * SOAP_FMAC6 soap_new_ns37__login(struct soap *soap, int n)
{	return soap_instantiate_ns37__login(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__login(struct soap *soap, struct ns37__login *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__login * SOAP_FMAC4 soap_instantiate_ns37__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__login, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__login;
		if (size)
			*size = sizeof(struct ns37__login);
	}
	else
	{	cp->ptr = (void*)new struct ns37__login[n];
		if (size)
			*size = n * sizeof(struct ns37__login);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__login %p -> %p\n", q, p));
	*(struct ns37__login*)p = *(struct ns37__login*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__loginResponse(struct soap *soap, const struct ns37__loginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons22__ResultBase(soap, &a->_loginReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__loginResponse(struct soap *soap, struct ns37__loginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_loginReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__loginResponse(struct soap *soap, const struct ns37__loginResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__loginResponse);
	if (soap_out_ns37__loginResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__loginResponse(struct soap *soap, const char *tag, int id, const struct ns37__loginResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__loginResponse), type);
	if (a->_loginReturn)
		soap_element_result(soap, "loginReturn");
	soap_out_PointerTons22__ResultBase(soap, "loginReturn", -1, &a->_loginReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__loginResponse * SOAP_FMAC4 soap_get_ns37__loginResponse(struct soap *soap, struct ns37__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__loginResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__loginResponse * SOAP_FMAC4 soap_in_ns37__loginResponse(struct soap *soap, const char *tag, struct ns37__loginResponse *a, const char *type)
{
	short soap_flag__loginReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__loginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__loginResponse, sizeof(struct ns37__loginResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__loginResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__loginReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, NULL, &a->_loginReturn, "ns22:ResultBase"))
				{	soap_flag__loginReturn--;
					continue;
				}
			soap_check_result(soap, "loginReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__loginResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__loginResponse, 0, sizeof(struct ns37__loginResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__loginResponse * SOAP_FMAC6 soap_new_ns37__loginResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__loginResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__loginResponse(struct soap *soap, struct ns37__loginResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__loginResponse * SOAP_FMAC4 soap_instantiate_ns37__loginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__loginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__loginResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__loginResponse;
		if (size)
			*size = sizeof(struct ns37__loginResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__loginResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__loginResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__loginResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__loginResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__loginResponse %p -> %p\n", q, p));
	*(struct ns37__loginResponse*)p = *(struct ns37__loginResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__randomReq(struct soap *soap, const struct ns37__randomReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__randomReq(struct soap *soap, struct ns37__randomReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__randomReq(struct soap *soap, const struct ns37__randomReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__randomReq);
	if (soap_out_ns37__randomReq(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__randomReq(struct soap *soap, const char *tag, int id, const struct ns37__randomReq *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__randomReq), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__randomReq * SOAP_FMAC4 soap_get_ns37__randomReq(struct soap *soap, struct ns37__randomReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__randomReq(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__randomReq * SOAP_FMAC4 soap_in_ns37__randomReq(struct soap *soap, const char *tag, struct ns37__randomReq *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__randomReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__randomReq, sizeof(struct ns37__randomReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__randomReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__randomReq *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__randomReq, 0, sizeof(struct ns37__randomReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__randomReq * SOAP_FMAC6 soap_new_ns37__randomReq(struct soap *soap, int n)
{	return soap_instantiate_ns37__randomReq(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__randomReq(struct soap *soap, struct ns37__randomReq *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__randomReq * SOAP_FMAC4 soap_instantiate_ns37__randomReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__randomReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__randomReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__randomReq;
		if (size)
			*size = sizeof(struct ns37__randomReq);
	}
	else
	{	cp->ptr = (void*)new struct ns37__randomReq[n];
		if (size)
			*size = n * sizeof(struct ns37__randomReq);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__randomReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__randomReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__randomReq %p -> %p\n", q, p));
	*(struct ns37__randomReq*)p = *(struct ns37__randomReq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__randomReqResponse(struct soap *soap, const struct ns37__randomReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__RandomInfo(soap, &a->randomReqReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__randomReqResponse(struct soap *soap, struct ns37__randomReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->randomReqReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__randomReqResponse(struct soap *soap, const struct ns37__randomReqResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__randomReqResponse);
	if (soap_out_ns37__randomReqResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__randomReqResponse(struct soap *soap, const char *tag, int id, const struct ns37__randomReqResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__randomReqResponse), type);
	if (a->randomReqReturn)
		soap_element_result(soap, "randomReqReturn");
	soap_out_PointerTons6__RandomInfo(soap, "randomReqReturn", -1, &a->randomReqReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__randomReqResponse * SOAP_FMAC4 soap_get_ns37__randomReqResponse(struct soap *soap, struct ns37__randomReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__randomReqResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__randomReqResponse * SOAP_FMAC4 soap_in_ns37__randomReqResponse(struct soap *soap, const char *tag, struct ns37__randomReqResponse *a, const char *type)
{
	short soap_flag_randomReqReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__randomReqResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__randomReqResponse, sizeof(struct ns37__randomReqResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__randomReqResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_randomReqReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__RandomInfo(soap, "randomReqReturn", &a->randomReqReturn, "ns6:RandomInfo"))
				{	soap_flag_randomReqReturn--;
					continue;
				}
			soap_check_result(soap, "randomReqReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__randomReqResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__randomReqResponse, 0, sizeof(struct ns37__randomReqResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__randomReqResponse * SOAP_FMAC6 soap_new_ns37__randomReqResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__randomReqResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__randomReqResponse(struct soap *soap, struct ns37__randomReqResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__randomReqResponse * SOAP_FMAC4 soap_instantiate_ns37__randomReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__randomReqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__randomReqResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__randomReqResponse;
		if (size)
			*size = sizeof(struct ns37__randomReqResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__randomReqResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__randomReqResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__randomReqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__randomReqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__randomReqResponse %p -> %p\n", q, p));
	*(struct ns37__randomReqResponse*)p = *(struct ns37__randomReqResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__pay(struct soap *soap, const struct ns37__pay *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__PayParam(soap, &a->_in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__pay(struct soap *soap, struct ns37__pay *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_in0 = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__pay(struct soap *soap, const struct ns37__pay *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__pay);
	if (soap_out_ns37__pay(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__pay(struct soap *soap, const char *tag, int id, const struct ns37__pay *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__pay), type);
	soap_out_PointerTons2__PayParam(soap, "in0", -1, &a->_in0, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__pay * SOAP_FMAC4 soap_get_ns37__pay(struct soap *soap, struct ns37__pay *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__pay(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__pay * SOAP_FMAC4 soap_in_ns37__pay(struct soap *soap, const char *tag, struct ns37__pay *a, const char *type)
{
	short soap_flag__in0 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__pay *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__pay, sizeof(struct ns37__pay), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__pay(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PayParam(soap, NULL, &a->_in0, "ns2:PayParam"))
				{	soap_flag__in0--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__pay *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__pay, 0, sizeof(struct ns37__pay), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__pay * SOAP_FMAC6 soap_new_ns37__pay(struct soap *soap, int n)
{	return soap_instantiate_ns37__pay(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__pay(struct soap *soap, struct ns37__pay *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__pay * SOAP_FMAC4 soap_instantiate_ns37__pay(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__pay(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__pay, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__pay;
		if (size)
			*size = sizeof(struct ns37__pay);
	}
	else
	{	cp->ptr = (void*)new struct ns37__pay[n];
		if (size)
			*size = n * sizeof(struct ns37__pay);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__pay*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__pay(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__pay %p -> %p\n", q, p));
	*(struct ns37__pay*)p = *(struct ns37__pay*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns37__payResponse(struct soap *soap, const struct ns37__payResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons22__ResultBase(soap, &a->_payReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns37__payResponse(struct soap *soap, struct ns37__payResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_payReturn = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns37__payResponse(struct soap *soap, const struct ns37__payResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns37__payResponse);
	if (soap_out_ns37__payResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns37__payResponse(struct soap *soap, const char *tag, int id, const struct ns37__payResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns37__payResponse), type);
	if (a->_payReturn)
		soap_element_result(soap, "payReturn");
	soap_out_PointerTons22__ResultBase(soap, "payReturn", -1, &a->_payReturn, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns37__payResponse * SOAP_FMAC4 soap_get_ns37__payResponse(struct soap *soap, struct ns37__payResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns37__payResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns37__payResponse * SOAP_FMAC4 soap_in_ns37__payResponse(struct soap *soap, const char *tag, struct ns37__payResponse *a, const char *type)
{
	short soap_flag__payReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns37__payResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns37__payResponse, sizeof(struct ns37__payResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns37__payResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__payReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons22__ResultBase(soap, NULL, &a->_payReturn, "ns22:ResultBase"))
				{	soap_flag__payReturn--;
					continue;
				}
			soap_check_result(soap, "payReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns37__payResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_ns37__payResponse, 0, sizeof(struct ns37__payResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns37__payResponse * SOAP_FMAC6 soap_new_ns37__payResponse(struct soap *soap, int n)
{	return soap_instantiate_ns37__payResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns37__payResponse(struct soap *soap, struct ns37__payResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns37__payResponse * SOAP_FMAC4 soap_instantiate_ns37__payResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns37__payResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns37__payResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns37__payResponse;
		if (size)
			*size = sizeof(struct ns37__payResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns37__payResponse[n];
		if (size)
			*size = n * sizeof(struct ns37__payResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns37__payResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns37__payResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns37__payResponse %p -> %p\n", q, p));
	*(struct ns37__payResponse*)p = *(struct ns37__payResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons36__BindParam(struct soap *soap, ns36__BindParam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns36__BindParam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons36__BindParam(struct soap *soap, ns36__BindParam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons36__BindParam);
	if (soap_out_PointerTons36__BindParam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons36__BindParam(struct soap *soap, const char *tag, int id, ns36__BindParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns36__BindParam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns36__BindParam ** SOAP_FMAC4 soap_get_PointerTons36__BindParam(struct soap *soap, ns36__BindParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons36__BindParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns36__BindParam ** SOAP_FMAC4 soap_in_PointerTons36__BindParam(struct soap *soap, const char *tag, ns36__BindParam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns36__BindParam **)soap_malloc(soap, sizeof(ns36__BindParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns36__BindParam *)soap_instantiate_ns36__BindParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns36__BindParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns36__BindParam, sizeof(ns36__BindParam), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons35__AccountListQueryInfo(struct soap *soap, ns35__AccountListQueryInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns35__AccountListQueryInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons35__AccountListQueryInfo(struct soap *soap, ns35__AccountListQueryInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons35__AccountListQueryInfo);
	if (soap_out_PointerTons35__AccountListQueryInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons35__AccountListQueryInfo(struct soap *soap, const char *tag, int id, ns35__AccountListQueryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns35__AccountListQueryInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns35__AccountListQueryInfo ** SOAP_FMAC4 soap_get_PointerTons35__AccountListQueryInfo(struct soap *soap, ns35__AccountListQueryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons35__AccountListQueryInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns35__AccountListQueryInfo ** SOAP_FMAC4 soap_in_PointerTons35__AccountListQueryInfo(struct soap *soap, const char *tag, ns35__AccountListQueryInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns35__AccountListQueryInfo **)soap_malloc(soap, sizeof(ns35__AccountListQueryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns35__AccountListQueryInfo *)soap_instantiate_ns35__AccountListQueryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns35__AccountListQueryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns35__AccountListQueryInfo, sizeof(ns35__AccountListQueryInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons10__RetAccountList(struct soap *soap, ns10__RetAccountList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns10__RetAccountList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons10__RetAccountList(struct soap *soap, ns10__RetAccountList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons10__RetAccountList);
	if (soap_out_PointerTons10__RetAccountList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons10__RetAccountList(struct soap *soap, const char *tag, int id, ns10__RetAccountList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns10__RetAccountList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns10__RetAccountList ** SOAP_FMAC4 soap_get_PointerTons10__RetAccountList(struct soap *soap, ns10__RetAccountList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons10__RetAccountList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns10__RetAccountList ** SOAP_FMAC4 soap_in_PointerTons10__RetAccountList(struct soap *soap, const char *tag, ns10__RetAccountList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns10__RetAccountList **)soap_malloc(soap, sizeof(ns10__RetAccountList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns10__RetAccountList *)soap_instantiate_ns10__RetAccountList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns10__RetAccountList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns10__RetAccountList, sizeof(ns10__RetAccountList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons34__LanAccessDetailQueryInfo(struct soap *soap, ns34__LanAccessDetailQueryInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns34__LanAccessDetailQueryInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons34__LanAccessDetailQueryInfo(struct soap *soap, ns34__LanAccessDetailQueryInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons34__LanAccessDetailQueryInfo);
	if (soap_out_PointerTons34__LanAccessDetailQueryInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons34__LanAccessDetailQueryInfo(struct soap *soap, const char *tag, int id, ns34__LanAccessDetailQueryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns34__LanAccessDetailQueryInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns34__LanAccessDetailQueryInfo ** SOAP_FMAC4 soap_get_PointerTons34__LanAccessDetailQueryInfo(struct soap *soap, ns34__LanAccessDetailQueryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons34__LanAccessDetailQueryInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns34__LanAccessDetailQueryInfo ** SOAP_FMAC4 soap_in_PointerTons34__LanAccessDetailQueryInfo(struct soap *soap, const char *tag, ns34__LanAccessDetailQueryInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns34__LanAccessDetailQueryInfo **)soap_malloc(soap, sizeof(ns34__LanAccessDetailQueryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns34__LanAccessDetailQueryInfo *)soap_instantiate_ns34__LanAccessDetailQueryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns34__LanAccessDetailQueryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns34__LanAccessDetailQueryInfo, sizeof(ns34__LanAccessDetailQueryInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__LanAccessDetailList(struct soap *soap, ns5__LanAccessDetailList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__LanAccessDetailList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__LanAccessDetailList(struct soap *soap, ns5__LanAccessDetailList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__LanAccessDetailList);
	if (soap_out_PointerTons5__LanAccessDetailList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__LanAccessDetailList(struct soap *soap, const char *tag, int id, ns5__LanAccessDetailList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__LanAccessDetailList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__LanAccessDetailList ** SOAP_FMAC4 soap_get_PointerTons5__LanAccessDetailList(struct soap *soap, ns5__LanAccessDetailList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__LanAccessDetailList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns5__LanAccessDetailList ** SOAP_FMAC4 soap_in_PointerTons5__LanAccessDetailList(struct soap *soap, const char *tag, ns5__LanAccessDetailList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__LanAccessDetailList **)soap_malloc(soap, sizeof(ns5__LanAccessDetailList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__LanAccessDetailList *)soap_instantiate_ns5__LanAccessDetailList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns5__LanAccessDetailList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__LanAccessDetailList, sizeof(ns5__LanAccessDetailList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons33__LanQryCondition(struct soap *soap, ns33__LanQryCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns33__LanQryCondition))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons33__LanQryCondition(struct soap *soap, ns33__LanQryCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons33__LanQryCondition);
	if (soap_out_PointerTons33__LanQryCondition(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons33__LanQryCondition(struct soap *soap, const char *tag, int id, ns33__LanQryCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns33__LanQryCondition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns33__LanQryCondition ** SOAP_FMAC4 soap_get_PointerTons33__LanQryCondition(struct soap *soap, ns33__LanQryCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons33__LanQryCondition(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns33__LanQryCondition ** SOAP_FMAC4 soap_in_PointerTons33__LanQryCondition(struct soap *soap, const char *tag, ns33__LanQryCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns33__LanQryCondition **)soap_malloc(soap, sizeof(ns33__LanQryCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns33__LanQryCondition *)soap_instantiate_ns33__LanQryCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns33__LanQryCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns33__LanQryCondition, sizeof(ns33__LanQryCondition), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons19__LanServiceList(struct soap *soap, ns19__LanServiceList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns19__LanServiceList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons19__LanServiceList(struct soap *soap, ns19__LanServiceList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons19__LanServiceList);
	if (soap_out_PointerTons19__LanServiceList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons19__LanServiceList(struct soap *soap, const char *tag, int id, ns19__LanServiceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns19__LanServiceList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns19__LanServiceList ** SOAP_FMAC4 soap_get_PointerTons19__LanServiceList(struct soap *soap, ns19__LanServiceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons19__LanServiceList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns19__LanServiceList ** SOAP_FMAC4 soap_in_PointerTons19__LanServiceList(struct soap *soap, const char *tag, ns19__LanServiceList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns19__LanServiceList **)soap_malloc(soap, sizeof(ns19__LanServiceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns19__LanServiceList *)soap_instantiate_ns19__LanServiceList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns19__LanServiceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns19__LanServiceList, sizeof(ns19__LanServiceList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons21__UserBalance(struct soap *soap, ns21__UserBalance *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns21__UserBalance))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons21__UserBalance(struct soap *soap, ns21__UserBalance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons21__UserBalance);
	if (soap_out_PointerTons21__UserBalance(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons21__UserBalance(struct soap *soap, const char *tag, int id, ns21__UserBalance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns21__UserBalance);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns21__UserBalance ** SOAP_FMAC4 soap_get_PointerTons21__UserBalance(struct soap *soap, ns21__UserBalance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons21__UserBalance(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns21__UserBalance ** SOAP_FMAC4 soap_in_PointerTons21__UserBalance(struct soap *soap, const char *tag, ns21__UserBalance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns21__UserBalance **)soap_malloc(soap, sizeof(ns21__UserBalance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns21__UserBalance *)soap_instantiate_ns21__UserBalance(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns21__UserBalance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns21__UserBalance, sizeof(ns21__UserBalance), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons32__BlackListQueryInfo(struct soap *soap, ns32__BlackListQueryInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns32__BlackListQueryInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons32__BlackListQueryInfo(struct soap *soap, ns32__BlackListQueryInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons32__BlackListQueryInfo);
	if (soap_out_PointerTons32__BlackListQueryInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons32__BlackListQueryInfo(struct soap *soap, const char *tag, int id, ns32__BlackListQueryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns32__BlackListQueryInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns32__BlackListQueryInfo ** SOAP_FMAC4 soap_get_PointerTons32__BlackListQueryInfo(struct soap *soap, ns32__BlackListQueryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons32__BlackListQueryInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns32__BlackListQueryInfo ** SOAP_FMAC4 soap_in_PointerTons32__BlackListQueryInfo(struct soap *soap, const char *tag, ns32__BlackListQueryInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns32__BlackListQueryInfo **)soap_malloc(soap, sizeof(ns32__BlackListQueryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns32__BlackListQueryInfo *)soap_instantiate_ns32__BlackListQueryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns32__BlackListQueryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns32__BlackListQueryInfo, sizeof(ns32__BlackListQueryInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons17__BlackList(struct soap *soap, ns17__BlackList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns17__BlackList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons17__BlackList(struct soap *soap, ns17__BlackList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons17__BlackList);
	if (soap_out_PointerTons17__BlackList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons17__BlackList(struct soap *soap, const char *tag, int id, ns17__BlackList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns17__BlackList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns17__BlackList ** SOAP_FMAC4 soap_get_PointerTons17__BlackList(struct soap *soap, ns17__BlackList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons17__BlackList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns17__BlackList ** SOAP_FMAC4 soap_in_PointerTons17__BlackList(struct soap *soap, const char *tag, ns17__BlackList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns17__BlackList **)soap_malloc(soap, sizeof(ns17__BlackList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns17__BlackList *)soap_instantiate_ns17__BlackList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns17__BlackList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns17__BlackList, sizeof(ns17__BlackList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons15__RetUserAppendInfo(struct soap *soap, ns15__RetUserAppendInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns15__RetUserAppendInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons15__RetUserAppendInfo(struct soap *soap, ns15__RetUserAppendInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons15__RetUserAppendInfo);
	if (soap_out_PointerTons15__RetUserAppendInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons15__RetUserAppendInfo(struct soap *soap, const char *tag, int id, ns15__RetUserAppendInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns15__RetUserAppendInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns15__RetUserAppendInfo ** SOAP_FMAC4 soap_get_PointerTons15__RetUserAppendInfo(struct soap *soap, ns15__RetUserAppendInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons15__RetUserAppendInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns15__RetUserAppendInfo ** SOAP_FMAC4 soap_in_PointerTons15__RetUserAppendInfo(struct soap *soap, const char *tag, ns15__RetUserAppendInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns15__RetUserAppendInfo **)soap_malloc(soap, sizeof(ns15__RetUserAppendInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns15__RetUserAppendInfo *)soap_instantiate_ns15__RetUserAppendInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns15__RetUserAppendInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns15__RetUserAppendInfo, sizeof(ns15__RetUserAppendInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons13__RetAcctServiceInfo(struct soap *soap, ns13__RetAcctServiceInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns13__RetAcctServiceInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons13__RetAcctServiceInfo(struct soap *soap, ns13__RetAcctServiceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons13__RetAcctServiceInfo);
	if (soap_out_PointerTons13__RetAcctServiceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons13__RetAcctServiceInfo(struct soap *soap, const char *tag, int id, ns13__RetAcctServiceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns13__RetAcctServiceInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns13__RetAcctServiceInfo ** SOAP_FMAC4 soap_get_PointerTons13__RetAcctServiceInfo(struct soap *soap, ns13__RetAcctServiceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons13__RetAcctServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns13__RetAcctServiceInfo ** SOAP_FMAC4 soap_in_PointerTons13__RetAcctServiceInfo(struct soap *soap, const char *tag, ns13__RetAcctServiceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns13__RetAcctServiceInfo **)soap_malloc(soap, sizeof(ns13__RetAcctServiceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns13__RetAcctServiceInfo *)soap_instantiate_ns13__RetAcctServiceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns13__RetAcctServiceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns13__RetAcctServiceInfo, sizeof(ns13__RetAcctServiceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons31__DelUserServiceParam(struct soap *soap, ns31__DelUserServiceParam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns31__DelUserServiceParam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons31__DelUserServiceParam(struct soap *soap, ns31__DelUserServiceParam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons31__DelUserServiceParam);
	if (soap_out_PointerTons31__DelUserServiceParam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons31__DelUserServiceParam(struct soap *soap, const char *tag, int id, ns31__DelUserServiceParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns31__DelUserServiceParam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns31__DelUserServiceParam ** SOAP_FMAC4 soap_get_PointerTons31__DelUserServiceParam(struct soap *soap, ns31__DelUserServiceParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons31__DelUserServiceParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns31__DelUserServiceParam ** SOAP_FMAC4 soap_in_PointerTons31__DelUserServiceParam(struct soap *soap, const char *tag, ns31__DelUserServiceParam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns31__DelUserServiceParam **)soap_malloc(soap, sizeof(ns31__DelUserServiceParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns31__DelUserServiceParam *)soap_instantiate_ns31__DelUserServiceParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns31__DelUserServiceParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns31__DelUserServiceParam, sizeof(ns31__DelUserServiceParam), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons30__ApplyServiceParam(struct soap *soap, ns30__ApplyServiceParam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns30__ApplyServiceParam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons30__ApplyServiceParam(struct soap *soap, ns30__ApplyServiceParam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons30__ApplyServiceParam);
	if (soap_out_PointerTons30__ApplyServiceParam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons30__ApplyServiceParam(struct soap *soap, const char *tag, int id, ns30__ApplyServiceParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns30__ApplyServiceParam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns30__ApplyServiceParam ** SOAP_FMAC4 soap_get_PointerTons30__ApplyServiceParam(struct soap *soap, ns30__ApplyServiceParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons30__ApplyServiceParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns30__ApplyServiceParam ** SOAP_FMAC4 soap_in_PointerTons30__ApplyServiceParam(struct soap *soap, const char *tag, ns30__ApplyServiceParam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns30__ApplyServiceParam **)soap_malloc(soap, sizeof(ns30__ApplyServiceParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns30__ApplyServiceParam *)soap_instantiate_ns30__ApplyServiceParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns30__ApplyServiceParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns30__ApplyServiceParam, sizeof(ns30__ApplyServiceParam), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons29__ChgAcctPassParam(struct soap *soap, ns29__ChgAcctPassParam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns29__ChgAcctPassParam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons29__ChgAcctPassParam(struct soap *soap, ns29__ChgAcctPassParam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons29__ChgAcctPassParam);
	if (soap_out_PointerTons29__ChgAcctPassParam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons29__ChgAcctPassParam(struct soap *soap, const char *tag, int id, ns29__ChgAcctPassParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns29__ChgAcctPassParam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns29__ChgAcctPassParam ** SOAP_FMAC4 soap_get_PointerTons29__ChgAcctPassParam(struct soap *soap, ns29__ChgAcctPassParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons29__ChgAcctPassParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns29__ChgAcctPassParam ** SOAP_FMAC4 soap_in_PointerTons29__ChgAcctPassParam(struct soap *soap, const char *tag, ns29__ChgAcctPassParam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns29__ChgAcctPassParam **)soap_malloc(soap, sizeof(ns29__ChgAcctPassParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns29__ChgAcctPassParam *)soap_instantiate_ns29__ChgAcctPassParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns29__ChgAcctPassParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns29__ChgAcctPassParam, sizeof(ns29__ChgAcctPassParam), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons11__RetPassword(struct soap *soap, ns11__RetPassword *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns11__RetPassword))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons11__RetPassword(struct soap *soap, ns11__RetPassword *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons11__RetPassword);
	if (soap_out_PointerTons11__RetPassword(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons11__RetPassword(struct soap *soap, const char *tag, int id, ns11__RetPassword *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns11__RetPassword);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns11__RetPassword ** SOAP_FMAC4 soap_get_PointerTons11__RetPassword(struct soap *soap, ns11__RetPassword **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons11__RetPassword(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns11__RetPassword ** SOAP_FMAC4 soap_in_PointerTons11__RetPassword(struct soap *soap, const char *tag, ns11__RetPassword **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns11__RetPassword **)soap_malloc(soap, sizeof(ns11__RetPassword *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns11__RetPassword *)soap_instantiate_ns11__RetPassword(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns11__RetPassword **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns11__RetPassword, sizeof(ns11__RetPassword), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__RetUserInfo(struct soap *soap, ns8__RetUserInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns8__RetUserInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__RetUserInfo(struct soap *soap, ns8__RetUserInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons8__RetUserInfo);
	if (soap_out_PointerTons8__RetUserInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__RetUserInfo(struct soap *soap, const char *tag, int id, ns8__RetUserInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__RetUserInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns8__RetUserInfo ** SOAP_FMAC4 soap_get_PointerTons8__RetUserInfo(struct soap *soap, ns8__RetUserInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons8__RetUserInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns8__RetUserInfo ** SOAP_FMAC4 soap_in_PointerTons8__RetUserInfo(struct soap *soap, const char *tag, ns8__RetUserInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns8__RetUserInfo **)soap_malloc(soap, sizeof(ns8__RetUserInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns8__RetUserInfo *)soap_instantiate_ns8__RetUserInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns8__RetUserInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__RetUserInfo, sizeof(ns8__RetUserInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons28__DelAcctParam(struct soap *soap, ns28__DelAcctParam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns28__DelAcctParam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons28__DelAcctParam(struct soap *soap, ns28__DelAcctParam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons28__DelAcctParam);
	if (soap_out_PointerTons28__DelAcctParam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons28__DelAcctParam(struct soap *soap, const char *tag, int id, ns28__DelAcctParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns28__DelAcctParam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns28__DelAcctParam ** SOAP_FMAC4 soap_get_PointerTons28__DelAcctParam(struct soap *soap, ns28__DelAcctParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons28__DelAcctParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns28__DelAcctParam ** SOAP_FMAC4 soap_in_PointerTons28__DelAcctParam(struct soap *soap, const char *tag, ns28__DelAcctParam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns28__DelAcctParam **)soap_malloc(soap, sizeof(ns28__DelAcctParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns28__DelAcctParam *)soap_instantiate_ns28__DelAcctParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns28__DelAcctParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns28__DelAcctParam, sizeof(ns28__DelAcctParam), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__RetDelUserInfo(struct soap *soap, ns3__RetDelUserInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__RetDelUserInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__RetDelUserInfo(struct soap *soap, ns3__RetDelUserInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__RetDelUserInfo);
	if (soap_out_PointerTons3__RetDelUserInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__RetDelUserInfo(struct soap *soap, const char *tag, int id, ns3__RetDelUserInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__RetDelUserInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__RetDelUserInfo ** SOAP_FMAC4 soap_get_PointerTons3__RetDelUserInfo(struct soap *soap, ns3__RetDelUserInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__RetDelUserInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns3__RetDelUserInfo ** SOAP_FMAC4 soap_in_PointerTons3__RetDelUserInfo(struct soap *soap, const char *tag, ns3__RetDelUserInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__RetDelUserInfo **)soap_malloc(soap, sizeof(ns3__RetDelUserInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__RetDelUserInfo *)soap_instantiate_ns3__RetDelUserInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns3__RetDelUserInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__RetDelUserInfo, sizeof(ns3__RetDelUserInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons27__ModifyAcctParam(struct soap *soap, ns27__ModifyAcctParam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns27__ModifyAcctParam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons27__ModifyAcctParam(struct soap *soap, ns27__ModifyAcctParam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons27__ModifyAcctParam);
	if (soap_out_PointerTons27__ModifyAcctParam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons27__ModifyAcctParam(struct soap *soap, const char *tag, int id, ns27__ModifyAcctParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns27__ModifyAcctParam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns27__ModifyAcctParam ** SOAP_FMAC4 soap_get_PointerTons27__ModifyAcctParam(struct soap *soap, ns27__ModifyAcctParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons27__ModifyAcctParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns27__ModifyAcctParam ** SOAP_FMAC4 soap_in_PointerTons27__ModifyAcctParam(struct soap *soap, const char *tag, ns27__ModifyAcctParam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns27__ModifyAcctParam **)soap_malloc(soap, sizeof(ns27__ModifyAcctParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns27__ModifyAcctParam *)soap_instantiate_ns27__ModifyAcctParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns27__ModifyAcctParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns27__ModifyAcctParam, sizeof(ns27__ModifyAcctParam), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons26__AddAcctParam(struct soap *soap, ns26__AddAcctParam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns26__AddAcctParam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons26__AddAcctParam(struct soap *soap, ns26__AddAcctParam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons26__AddAcctParam);
	if (soap_out_PointerTons26__AddAcctParam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons26__AddAcctParam(struct soap *soap, const char *tag, int id, ns26__AddAcctParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns26__AddAcctParam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns26__AddAcctParam ** SOAP_FMAC4 soap_get_PointerTons26__AddAcctParam(struct soap *soap, ns26__AddAcctParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons26__AddAcctParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns26__AddAcctParam ** SOAP_FMAC4 soap_in_PointerTons26__AddAcctParam(struct soap *soap, const char *tag, ns26__AddAcctParam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns26__AddAcctParam **)soap_malloc(soap, sizeof(ns26__AddAcctParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns26__AddAcctParam *)soap_instantiate_ns26__AddAcctParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns26__AddAcctParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns26__AddAcctParam, sizeof(ns26__AddAcctParam), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons7__MultiResult(struct soap *soap, ns7__MultiResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns7__MultiResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons7__MultiResult(struct soap *soap, ns7__MultiResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons7__MultiResult);
	if (soap_out_PointerTons7__MultiResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons7__MultiResult(struct soap *soap, const char *tag, int id, ns7__MultiResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns7__MultiResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns7__MultiResult ** SOAP_FMAC4 soap_get_PointerTons7__MultiResult(struct soap *soap, ns7__MultiResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons7__MultiResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns7__MultiResult ** SOAP_FMAC4 soap_in_PointerTons7__MultiResult(struct soap *soap, const char *tag, ns7__MultiResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns7__MultiResult **)soap_malloc(soap, sizeof(ns7__MultiResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns7__MultiResult *)soap_instantiate_ns7__MultiResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns7__MultiResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns7__MultiResult, sizeof(ns7__MultiResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons24__QueryActionInfo(struct soap *soap, ns24__QueryActionInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns24__QueryActionInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons24__QueryActionInfo(struct soap *soap, ns24__QueryActionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons24__QueryActionInfo);
	if (soap_out_PointerTons24__QueryActionInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons24__QueryActionInfo(struct soap *soap, const char *tag, int id, ns24__QueryActionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns24__QueryActionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns24__QueryActionInfo ** SOAP_FMAC4 soap_get_PointerTons24__QueryActionInfo(struct soap *soap, ns24__QueryActionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons24__QueryActionInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns24__QueryActionInfo ** SOAP_FMAC4 soap_in_PointerTons24__QueryActionInfo(struct soap *soap, const char *tag, ns24__QueryActionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns24__QueryActionInfo **)soap_malloc(soap, sizeof(ns24__QueryActionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns24__QueryActionInfo *)soap_instantiate_ns24__QueryActionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns24__QueryActionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns24__QueryActionInfo, sizeof(ns24__QueryActionInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons20__SingleResult(struct soap *soap, ns20__SingleResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns20__SingleResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons20__SingleResult(struct soap *soap, ns20__SingleResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons20__SingleResult);
	if (soap_out_PointerTons20__SingleResult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons20__SingleResult(struct soap *soap, const char *tag, int id, ns20__SingleResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns20__SingleResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns20__SingleResult ** SOAP_FMAC4 soap_get_PointerTons20__SingleResult(struct soap *soap, ns20__SingleResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons20__SingleResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns20__SingleResult ** SOAP_FMAC4 soap_in_PointerTons20__SingleResult(struct soap *soap, const char *tag, ns20__SingleResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns20__SingleResult **)soap_malloc(soap, sizeof(ns20__SingleResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns20__SingleResult *)soap_instantiate_ns20__SingleResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns20__SingleResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns20__SingleResult, sizeof(ns20__SingleResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons23__OperatorInfo(struct soap *soap, ns23__OperatorInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns23__OperatorInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons23__OperatorInfo(struct soap *soap, ns23__OperatorInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons23__OperatorInfo);
	if (soap_out_PointerTons23__OperatorInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons23__OperatorInfo(struct soap *soap, const char *tag, int id, ns23__OperatorInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns23__OperatorInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns23__OperatorInfo ** SOAP_FMAC4 soap_get_PointerTons23__OperatorInfo(struct soap *soap, ns23__OperatorInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons23__OperatorInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns23__OperatorInfo ** SOAP_FMAC4 soap_in_PointerTons23__OperatorInfo(struct soap *soap, const char *tag, ns23__OperatorInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns23__OperatorInfo **)soap_malloc(soap, sizeof(ns23__OperatorInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns23__OperatorInfo *)soap_instantiate_ns23__OperatorInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns23__OperatorInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns23__OperatorInfo, sizeof(ns23__OperatorInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__RandomInfo(struct soap *soap, ns6__RandomInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__RandomInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__RandomInfo(struct soap *soap, ns6__RandomInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__RandomInfo);
	if (soap_out_PointerTons6__RandomInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__RandomInfo(struct soap *soap, const char *tag, int id, ns6__RandomInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__RandomInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__RandomInfo ** SOAP_FMAC4 soap_get_PointerTons6__RandomInfo(struct soap *soap, ns6__RandomInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__RandomInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns6__RandomInfo ** SOAP_FMAC4 soap_in_PointerTons6__RandomInfo(struct soap *soap, const char *tag, ns6__RandomInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__RandomInfo **)soap_malloc(soap, sizeof(ns6__RandomInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__RandomInfo *)soap_instantiate_ns6__RandomInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns6__RandomInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__RandomInfo, sizeof(ns6__RandomInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PayParam(struct soap *soap, ns2__PayParam *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PayParam))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PayParam(struct soap *soap, ns2__PayParam *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PayParam);
	if (soap_out_PointerTons2__PayParam(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PayParam(struct soap *soap, const char *tag, int id, ns2__PayParam *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PayParam);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PayParam ** SOAP_FMAC4 soap_get_PointerTons2__PayParam(struct soap *soap, ns2__PayParam **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PayParam(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns2__PayParam ** SOAP_FMAC4 soap_in_PointerTons2__PayParam(struct soap *soap, const char *tag, ns2__PayParam **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PayParam **)soap_malloc(soap, sizeof(ns2__PayParam *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PayParam *)soap_instantiate_ns2__PayParam(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns2__PayParam **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PayParam, sizeof(ns2__PayParam), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(struct soap *soap, ArrayOf_USCOREtns19_USCORELanServiceInfo *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(struct soap *soap, ArrayOf_USCOREtns19_USCORELanServiceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo);
	if (soap_out_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns19_USCORELanServiceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns19_USCORELanServiceInfo ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(struct soap *soap, ArrayOf_USCOREtns19_USCORELanServiceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns19_USCORELanServiceInfo ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns19_USCORELanServiceInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns19_USCORELanServiceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns19_USCORELanServiceInfo **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns19_USCORELanServiceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns19_USCORELanServiceInfo *)soap_instantiate_ArrayOf_USCOREtns19_USCORELanServiceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns19_USCORELanServiceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns19_USCORELanServiceInfo, sizeof(ArrayOf_USCOREtns19_USCORELanServiceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(struct soap *soap, ArrayOf_USCOREtns17_USCOREBlackListInfo *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(struct soap *soap, ArrayOf_USCOREtns17_USCOREBlackListInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo);
	if (soap_out_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns17_USCOREBlackListInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns17_USCOREBlackListInfo ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(struct soap *soap, ArrayOf_USCOREtns17_USCOREBlackListInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns17_USCOREBlackListInfo ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns17_USCOREBlackListInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns17_USCOREBlackListInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns17_USCOREBlackListInfo **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns17_USCOREBlackListInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns17_USCOREBlackListInfo *)soap_instantiate_ArrayOf_USCOREtns17_USCOREBlackListInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns17_USCOREBlackListInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns17_USCOREBlackListInfo, sizeof(ArrayOf_USCOREtns17_USCOREBlackListInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(struct soap *soap, ArrayOf_USCOREtns15_USCOREUserAppendInfo *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(struct soap *soap, ArrayOf_USCOREtns15_USCOREUserAppendInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo);
	if (soap_out_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns15_USCOREUserAppendInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns15_USCOREUserAppendInfo ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(struct soap *soap, ArrayOf_USCOREtns15_USCOREUserAppendInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns15_USCOREUserAppendInfo ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns15_USCOREUserAppendInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns15_USCOREUserAppendInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns15_USCOREUserAppendInfo **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns15_USCOREUserAppendInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns15_USCOREUserAppendInfo *)soap_instantiate_ArrayOf_USCOREtns15_USCOREUserAppendInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns15_USCOREUserAppendInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns15_USCOREUserAppendInfo, sizeof(ArrayOf_USCOREtns15_USCOREUserAppendInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(struct soap *soap, ArrayOf_USCOREtns13_USCOREAcctServiceInfo *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(struct soap *soap, ArrayOf_USCOREtns13_USCOREAcctServiceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo);
	if (soap_out_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns13_USCOREAcctServiceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns13_USCOREAcctServiceInfo ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(struct soap *soap, ArrayOf_USCOREtns13_USCOREAcctServiceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns13_USCOREAcctServiceInfo ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns13_USCOREAcctServiceInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns13_USCOREAcctServiceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns13_USCOREAcctServiceInfo **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns13_USCOREAcctServiceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns13_USCOREAcctServiceInfo *)soap_instantiate_ArrayOf_USCOREtns13_USCOREAcctServiceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns13_USCOREAcctServiceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns13_USCOREAcctServiceInfo, sizeof(ArrayOf_USCOREtns13_USCOREAcctServiceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(struct soap *soap, ArrayOf_USCOREtns10_USCOREAcctBasicInfo *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(struct soap *soap, ArrayOf_USCOREtns10_USCOREAcctBasicInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo);
	if (soap_out_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns10_USCOREAcctBasicInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns10_USCOREAcctBasicInfo ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(struct soap *soap, ArrayOf_USCOREtns10_USCOREAcctBasicInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns10_USCOREAcctBasicInfo ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns10_USCOREAcctBasicInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns10_USCOREAcctBasicInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns10_USCOREAcctBasicInfo **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns10_USCOREAcctBasicInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns10_USCOREAcctBasicInfo *)soap_instantiate_ArrayOf_USCOREtns10_USCOREAcctBasicInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns10_USCOREAcctBasicInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns10_USCOREAcctBasicInfo, sizeof(ArrayOf_USCOREtns10_USCOREAcctBasicInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOfArrayOf_USCORExsd_USCOREstring *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOfArrayOf_USCORExsd_USCOREstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfArrayOf_USCORExsd_USCOREstring);
	if (soap_out_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, int id, ArrayOfArrayOf_USCORExsd_USCOREstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfArrayOf_USCORExsd_USCOREstring ** SOAP_FMAC4 soap_get_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOfArrayOf_USCORExsd_USCOREstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfArrayOf_USCORExsd_USCOREstring ** SOAP_FMAC4 soap_in_PointerToArrayOfArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, ArrayOfArrayOf_USCORExsd_USCOREstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfArrayOf_USCORExsd_USCOREstring **)soap_malloc(soap, sizeof(ArrayOfArrayOf_USCORExsd_USCOREstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfArrayOf_USCORExsd_USCOREstring *)soap_instantiate_ArrayOfArrayOf_USCORExsd_USCOREstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfArrayOf_USCORExsd_USCOREstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfArrayOf_USCORExsd_USCOREstring, sizeof(ArrayOfArrayOf_USCORExsd_USCOREstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(struct soap *soap, ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(struct soap *soap, ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo);
	if (soap_out_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns5_USCORELanAccessDetailInfo ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(struct soap *soap, ArrayOf_USCOREtns5_USCORELanAccessDetailInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns5_USCORELanAccessDetailInfo ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns5_USCORELanAccessDetailInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns5_USCORELanAccessDetailInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns5_USCORELanAccessDetailInfo **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns5_USCORELanAccessDetailInfo *)soap_instantiate_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns5_USCORELanAccessDetailInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns5_USCORELanAccessDetailInfo, sizeof(ArrayOf_USCOREtns5_USCORELanAccessDetailInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons25__ApplyServiceInfo(struct soap *soap, ns25__ApplyServiceInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons25__ApplyServiceInfo))
		soap_serialize_PointerTons25__ApplyServiceInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons25__ApplyServiceInfo(struct soap *soap, ns25__ApplyServiceInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons25__ApplyServiceInfo);
	if (soap_out_PointerToPointerTons25__ApplyServiceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons25__ApplyServiceInfo(struct soap *soap, const char *tag, int id, ns25__ApplyServiceInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons25__ApplyServiceInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons25__ApplyServiceInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns25__ApplyServiceInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons25__ApplyServiceInfo(struct soap *soap, ns25__ApplyServiceInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons25__ApplyServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns25__ApplyServiceInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons25__ApplyServiceInfo(struct soap *soap, const char *tag, ns25__ApplyServiceInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns25__ApplyServiceInfo ***)soap_malloc(soap, sizeof(ns25__ApplyServiceInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons25__ApplyServiceInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns25__ApplyServiceInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons25__ApplyServiceInfo, sizeof(ns25__ApplyServiceInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons25__ApplyServiceInfo(struct soap *soap, ns25__ApplyServiceInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns25__ApplyServiceInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons25__ApplyServiceInfo(struct soap *soap, ns25__ApplyServiceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons25__ApplyServiceInfo);
	if (soap_out_PointerTons25__ApplyServiceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons25__ApplyServiceInfo(struct soap *soap, const char *tag, int id, ns25__ApplyServiceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns25__ApplyServiceInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns25__ApplyServiceInfo ** SOAP_FMAC4 soap_get_PointerTons25__ApplyServiceInfo(struct soap *soap, ns25__ApplyServiceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons25__ApplyServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns25__ApplyServiceInfo ** SOAP_FMAC4 soap_in_PointerTons25__ApplyServiceInfo(struct soap *soap, const char *tag, ns25__ApplyServiceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns25__ApplyServiceInfo **)soap_malloc(soap, sizeof(ns25__ApplyServiceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns25__ApplyServiceInfo *)soap_instantiate_ns25__ApplyServiceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns25__ApplyServiceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns25__ApplyServiceInfo, sizeof(ns25__ApplyServiceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons18__LanServiceInfo(struct soap *soap, ns18__LanServiceInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons18__LanServiceInfo))
		soap_serialize_PointerTons18__LanServiceInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons18__LanServiceInfo(struct soap *soap, ns18__LanServiceInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons18__LanServiceInfo);
	if (soap_out_PointerToPointerTons18__LanServiceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons18__LanServiceInfo(struct soap *soap, const char *tag, int id, ns18__LanServiceInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons18__LanServiceInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons18__LanServiceInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns18__LanServiceInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons18__LanServiceInfo(struct soap *soap, ns18__LanServiceInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons18__LanServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns18__LanServiceInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons18__LanServiceInfo(struct soap *soap, const char *tag, ns18__LanServiceInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns18__LanServiceInfo ***)soap_malloc(soap, sizeof(ns18__LanServiceInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons18__LanServiceInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns18__LanServiceInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons18__LanServiceInfo, sizeof(ns18__LanServiceInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons18__LanServiceInfo(struct soap *soap, ns18__LanServiceInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns18__LanServiceInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons18__LanServiceInfo(struct soap *soap, ns18__LanServiceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons18__LanServiceInfo);
	if (soap_out_PointerTons18__LanServiceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons18__LanServiceInfo(struct soap *soap, const char *tag, int id, ns18__LanServiceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns18__LanServiceInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns18__LanServiceInfo ** SOAP_FMAC4 soap_get_PointerTons18__LanServiceInfo(struct soap *soap, ns18__LanServiceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons18__LanServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns18__LanServiceInfo ** SOAP_FMAC4 soap_in_PointerTons18__LanServiceInfo(struct soap *soap, const char *tag, ns18__LanServiceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns18__LanServiceInfo **)soap_malloc(soap, sizeof(ns18__LanServiceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns18__LanServiceInfo *)soap_instantiate_ns18__LanServiceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns18__LanServiceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns18__LanServiceInfo, sizeof(ns18__LanServiceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons16__BlackListInfo(struct soap *soap, ns16__BlackListInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons16__BlackListInfo))
		soap_serialize_PointerTons16__BlackListInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons16__BlackListInfo(struct soap *soap, ns16__BlackListInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons16__BlackListInfo);
	if (soap_out_PointerToPointerTons16__BlackListInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons16__BlackListInfo(struct soap *soap, const char *tag, int id, ns16__BlackListInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons16__BlackListInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons16__BlackListInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns16__BlackListInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons16__BlackListInfo(struct soap *soap, ns16__BlackListInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons16__BlackListInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns16__BlackListInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons16__BlackListInfo(struct soap *soap, const char *tag, ns16__BlackListInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__BlackListInfo ***)soap_malloc(soap, sizeof(ns16__BlackListInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons16__BlackListInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns16__BlackListInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons16__BlackListInfo, sizeof(ns16__BlackListInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons16__BlackListInfo(struct soap *soap, ns16__BlackListInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns16__BlackListInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons16__BlackListInfo(struct soap *soap, ns16__BlackListInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons16__BlackListInfo);
	if (soap_out_PointerTons16__BlackListInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons16__BlackListInfo(struct soap *soap, const char *tag, int id, ns16__BlackListInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns16__BlackListInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns16__BlackListInfo ** SOAP_FMAC4 soap_get_PointerTons16__BlackListInfo(struct soap *soap, ns16__BlackListInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons16__BlackListInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns16__BlackListInfo ** SOAP_FMAC4 soap_in_PointerTons16__BlackListInfo(struct soap *soap, const char *tag, ns16__BlackListInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns16__BlackListInfo **)soap_malloc(soap, sizeof(ns16__BlackListInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns16__BlackListInfo *)soap_instantiate_ns16__BlackListInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns16__BlackListInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns16__BlackListInfo, sizeof(ns16__BlackListInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons14__UserAppendInfo(struct soap *soap, ns14__UserAppendInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons14__UserAppendInfo))
		soap_serialize_PointerTons14__UserAppendInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons14__UserAppendInfo(struct soap *soap, ns14__UserAppendInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons14__UserAppendInfo);
	if (soap_out_PointerToPointerTons14__UserAppendInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons14__UserAppendInfo(struct soap *soap, const char *tag, int id, ns14__UserAppendInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons14__UserAppendInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons14__UserAppendInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns14__UserAppendInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons14__UserAppendInfo(struct soap *soap, ns14__UserAppendInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons14__UserAppendInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns14__UserAppendInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons14__UserAppendInfo(struct soap *soap, const char *tag, ns14__UserAppendInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns14__UserAppendInfo ***)soap_malloc(soap, sizeof(ns14__UserAppendInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons14__UserAppendInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns14__UserAppendInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons14__UserAppendInfo, sizeof(ns14__UserAppendInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons14__UserAppendInfo(struct soap *soap, ns14__UserAppendInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns14__UserAppendInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons14__UserAppendInfo(struct soap *soap, ns14__UserAppendInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons14__UserAppendInfo);
	if (soap_out_PointerTons14__UserAppendInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons14__UserAppendInfo(struct soap *soap, const char *tag, int id, ns14__UserAppendInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns14__UserAppendInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns14__UserAppendInfo ** SOAP_FMAC4 soap_get_PointerTons14__UserAppendInfo(struct soap *soap, ns14__UserAppendInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons14__UserAppendInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns14__UserAppendInfo ** SOAP_FMAC4 soap_in_PointerTons14__UserAppendInfo(struct soap *soap, const char *tag, ns14__UserAppendInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns14__UserAppendInfo **)soap_malloc(soap, sizeof(ns14__UserAppendInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns14__UserAppendInfo *)soap_instantiate_ns14__UserAppendInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns14__UserAppendInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns14__UserAppendInfo, sizeof(ns14__UserAppendInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons12__AcctServiceInfo(struct soap *soap, ns12__AcctServiceInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons12__AcctServiceInfo))
		soap_serialize_PointerTons12__AcctServiceInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons12__AcctServiceInfo(struct soap *soap, ns12__AcctServiceInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons12__AcctServiceInfo);
	if (soap_out_PointerToPointerTons12__AcctServiceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons12__AcctServiceInfo(struct soap *soap, const char *tag, int id, ns12__AcctServiceInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons12__AcctServiceInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons12__AcctServiceInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns12__AcctServiceInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons12__AcctServiceInfo(struct soap *soap, ns12__AcctServiceInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons12__AcctServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns12__AcctServiceInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons12__AcctServiceInfo(struct soap *soap, const char *tag, ns12__AcctServiceInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns12__AcctServiceInfo ***)soap_malloc(soap, sizeof(ns12__AcctServiceInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons12__AcctServiceInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns12__AcctServiceInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons12__AcctServiceInfo, sizeof(ns12__AcctServiceInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons12__AcctServiceInfo(struct soap *soap, ns12__AcctServiceInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns12__AcctServiceInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons12__AcctServiceInfo(struct soap *soap, ns12__AcctServiceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons12__AcctServiceInfo);
	if (soap_out_PointerTons12__AcctServiceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons12__AcctServiceInfo(struct soap *soap, const char *tag, int id, ns12__AcctServiceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns12__AcctServiceInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns12__AcctServiceInfo ** SOAP_FMAC4 soap_get_PointerTons12__AcctServiceInfo(struct soap *soap, ns12__AcctServiceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons12__AcctServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns12__AcctServiceInfo ** SOAP_FMAC4 soap_in_PointerTons12__AcctServiceInfo(struct soap *soap, const char *tag, ns12__AcctServiceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns12__AcctServiceInfo **)soap_malloc(soap, sizeof(ns12__AcctServiceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns12__AcctServiceInfo *)soap_instantiate_ns12__AcctServiceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns12__AcctServiceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns12__AcctServiceInfo, sizeof(ns12__AcctServiceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons9__AcctBasicInfo(struct soap *soap, ns9__AcctBasicInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons9__AcctBasicInfo))
		soap_serialize_PointerTons9__AcctBasicInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons9__AcctBasicInfo(struct soap *soap, ns9__AcctBasicInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons9__AcctBasicInfo);
	if (soap_out_PointerToPointerTons9__AcctBasicInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons9__AcctBasicInfo(struct soap *soap, const char *tag, int id, ns9__AcctBasicInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons9__AcctBasicInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons9__AcctBasicInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns9__AcctBasicInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons9__AcctBasicInfo(struct soap *soap, ns9__AcctBasicInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons9__AcctBasicInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns9__AcctBasicInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons9__AcctBasicInfo(struct soap *soap, const char *tag, ns9__AcctBasicInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns9__AcctBasicInfo ***)soap_malloc(soap, sizeof(ns9__AcctBasicInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons9__AcctBasicInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns9__AcctBasicInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons9__AcctBasicInfo, sizeof(ns9__AcctBasicInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons9__AcctBasicInfo(struct soap *soap, ns9__AcctBasicInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns9__AcctBasicInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons9__AcctBasicInfo(struct soap *soap, ns9__AcctBasicInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons9__AcctBasicInfo);
	if (soap_out_PointerTons9__AcctBasicInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons9__AcctBasicInfo(struct soap *soap, const char *tag, int id, ns9__AcctBasicInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns9__AcctBasicInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns9__AcctBasicInfo ** SOAP_FMAC4 soap_get_PointerTons9__AcctBasicInfo(struct soap *soap, ns9__AcctBasicInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons9__AcctBasicInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns9__AcctBasicInfo ** SOAP_FMAC4 soap_in_PointerTons9__AcctBasicInfo(struct soap *soap, const char *tag, ns9__AcctBasicInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns9__AcctBasicInfo **)soap_malloc(soap, sizeof(ns9__AcctBasicInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns9__AcctBasicInfo *)soap_instantiate_ns9__AcctBasicInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns9__AcctBasicInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns9__AcctBasicInfo, sizeof(ns9__AcctBasicInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Struct_1(struct soap *soap, _Struct_1 *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Struct_1(struct soap *soap, _Struct_1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_Struct_1);
	if (soap_out_PointerTo_Struct_1(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Struct_1(struct soap *soap, const char *tag, int id, _Struct_1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE__Struct_1);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Struct_1 ** SOAP_FMAC4 soap_get_PointerTo_Struct_1(struct soap *soap, _Struct_1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Struct_1(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _Struct_1 ** SOAP_FMAC4 soap_in_PointerTo_Struct_1(struct soap *soap, const char *tag, _Struct_1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Struct_1 **)soap_malloc(soap, sizeof(_Struct_1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Struct_1 *)soap_instantiate__Struct_1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_Struct_1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__Struct_1, sizeof(_Struct_1), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__LanAccessDetailInfo(struct soap *soap, ns4__LanAccessDetailInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__LanAccessDetailInfo))
		soap_serialize_PointerTons4__LanAccessDetailInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__LanAccessDetailInfo(struct soap *soap, ns4__LanAccessDetailInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__LanAccessDetailInfo);
	if (soap_out_PointerToPointerTons4__LanAccessDetailInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__LanAccessDetailInfo(struct soap *soap, const char *tag, int id, ns4__LanAccessDetailInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__LanAccessDetailInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__LanAccessDetailInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__LanAccessDetailInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons4__LanAccessDetailInfo(struct soap *soap, ns4__LanAccessDetailInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__LanAccessDetailInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__LanAccessDetailInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons4__LanAccessDetailInfo(struct soap *soap, const char *tag, ns4__LanAccessDetailInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__LanAccessDetailInfo ***)soap_malloc(soap, sizeof(ns4__LanAccessDetailInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__LanAccessDetailInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__LanAccessDetailInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__LanAccessDetailInfo, sizeof(ns4__LanAccessDetailInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__LanAccessDetailInfo(struct soap *soap, ns4__LanAccessDetailInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__LanAccessDetailInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__LanAccessDetailInfo(struct soap *soap, ns4__LanAccessDetailInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__LanAccessDetailInfo);
	if (soap_out_PointerTons4__LanAccessDetailInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__LanAccessDetailInfo(struct soap *soap, const char *tag, int id, ns4__LanAccessDetailInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__LanAccessDetailInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__LanAccessDetailInfo ** SOAP_FMAC4 soap_get_PointerTons4__LanAccessDetailInfo(struct soap *soap, ns4__LanAccessDetailInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__LanAccessDetailInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns4__LanAccessDetailInfo ** SOAP_FMAC4 soap_in_PointerTons4__LanAccessDetailInfo(struct soap *soap, const char *tag, ns4__LanAccessDetailInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__LanAccessDetailInfo **)soap_malloc(soap, sizeof(ns4__LanAccessDetailInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__LanAccessDetailInfo *)soap_instantiate_ns4__LanAccessDetailInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns4__LanAccessDetailInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__LanAccessDetailInfo, sizeof(ns4__LanAccessDetailInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(struct soap *soap, ArrayOf_USCOREtns25_USCOREApplyServiceInfo *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(struct soap *soap, ArrayOf_USCOREtns25_USCOREApplyServiceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo);
	if (soap_out_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns25_USCOREApplyServiceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns25_USCOREApplyServiceInfo ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(struct soap *soap, ArrayOf_USCOREtns25_USCOREApplyServiceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns25_USCOREApplyServiceInfo ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns25_USCOREApplyServiceInfo(struct soap *soap, const char *tag, ArrayOf_USCOREtns25_USCOREApplyServiceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns25_USCOREApplyServiceInfo **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns25_USCOREApplyServiceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns25_USCOREApplyServiceInfo *)soap_instantiate_ArrayOf_USCOREtns25_USCOREApplyServiceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns25_USCOREApplyServiceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns25_USCOREApplyServiceInfo, sizeof(ArrayOf_USCOREtns25_USCOREApplyServiceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons22__ResultBase(struct soap *soap, ns22__ResultBase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns22__ResultBase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons22__ResultBase(struct soap *soap, ns22__ResultBase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons22__ResultBase);
	if (soap_out_PointerTons22__ResultBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons22__ResultBase(struct soap *soap, const char *tag, int id, ns22__ResultBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns22__ResultBase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns22__ResultBase ** SOAP_FMAC4 soap_get_PointerTons22__ResultBase(struct soap *soap, ns22__ResultBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons22__ResultBase(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns22__ResultBase ** SOAP_FMAC4 soap_in_PointerTons22__ResultBase(struct soap *soap, const char *tag, ns22__ResultBase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns22__ResultBase **)soap_malloc(soap, sizeof(ns22__ResultBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns22__ResultBase *)soap_instantiate_ns22__ResultBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns22__ResultBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns22__ResultBase, sizeof(ns22__ResultBase), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCORExsd_USCOREstring);
	if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, int id, ArrayOf_USCORExsd_USCOREstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, ArrayOf_USCORExsd_USCOREstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCORExsd_USCOREstring **)soap_malloc(soap, sizeof(ArrayOf_USCORExsd_USCOREstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCORExsd_USCOREstring *)soap_instantiate_ArrayOf_USCORExsd_USCOREstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCORExsd_USCOREstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring, sizeof(ArrayOf_USCORExsd_USCOREstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__SOAP_ENC__arrayType(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__SOAP_ENC__arrayType(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__SOAP_ENC__arrayType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__SOAP_ENC__arrayType);
	if (soap_out__SOAP_ENC__arrayType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__SOAP_ENC__arrayType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__SOAP_ENC__arrayType);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__SOAP_ENC__arrayType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__SOAP_ENC__arrayType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__SOAP_ENC__arrayType(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__SOAP_ENC__arrayType, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of soapC.cpp */

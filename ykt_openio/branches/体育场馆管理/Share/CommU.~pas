unit CommU;

interface

uses SysUtils, Messages, StdCtrls, Classes, Controls, Forms, Windows, ADODB, DB, IniFIles;

const
  WM_RELEASEDLL = WM_USER + 101;
  SP = '~~';
  //ORACLE连接字符串

  CONFIGFILE = 'config.ini';
  LOGINFILE = 'picture\Login.bmp';
  USERCODEFILE = 'usercode.ini';

type
  LOOPPURSEINFO = packed record
    RemainMoney: DWORD; // 电子钱包余额
    DealTimes: WORD; // 用户卡交易流水号
    DealYear: BYTE; // 交易日期
    DealMonth: BYTE;
    DealDay: BYTE;
    DealHour: BYTE;
    DealMin: BYTE;
    DealTimes_CurTime: BYTE; // 累计交易次数(当前时间段内)
    DealTimes_CurDay: BYTE; // 累计交易次数(当日内)
  end;

type
  TCardInfo = packed record
    DeadLineDate: array[1..9] of char; //用户卡使用截止日期
    CardRightType: longint; //用户卡使用权限类型（1--254）
    ucName: array[1..9] of Char; //姓名
    ucDutyNo: array[1..9] of Char; //职务代码
    ucCertificateNo: array[1..21] of Char; //证件号码
    ucDepartmentNo: array[1..11] of Char; //部门编号
    ucIdentifyNo: array[1..21] of Char; //身份代码
    ucSexNo: array[1..2] of Char; //性别代码
    ucCardNo: array[1..21] of Char; //卡号（工号或学号）
  end;

type
  TRunDllFun = function(AFile, AStr: PChar; i, x, y, mode: integer): integer; stdcall;
  TProductZS = record
    ID: string; //产品代码
    Name: string; //产品名称
    Count: Double; //送货数量
  end;
  Tmedicaldtl = record
    REFNO: string; //编号
    CUSTID: integer; //客户号
    CUSTNAME: string; //姓名
    STUEMPNO: string; //学工号
    sex: string; //性别
    CUSTTYPENAME: string; //客户类别
    VOUCHERNO: string; //处方号
    MEDICINES: string; //药品
    MEDICALINFO: string; //病情信息
    CARDNO: integer; //卡号
    TRANSDATE: string; //交易日期
    TRANSTIME: string; //缴费时间
    TRANSTYPE: integer; //缴费类型
    money: double; //余额
    DEVPHYID: string; //终端号
    OPERCODE: string; //操作员
    STATUS: string; //状态
    REMARK: string; //标记
  end;
  TPeople = record
    sOperatorCode: string;
    sOperatorName: string;
    sBusinessCode: string;
    sBusinessName: string;
    sManagerCode: string;
    sManagerName: string;
    sCheckerCode: string;
    sCheckerName: string;
    sSenderCode: string;
    sSenderName: string;
    sTesterCode: string;
    sTesterName: string;
  end;
  PDBConn = ^TADOConnection;
  PUser = ^TUserInfo;
  //子模块信息定义
  TSubMenu = record
    Caption: string; //子模块名称
    ID: string; //子模块ID
    DLL: string; //子模块DLL名
    isVisble: boolean; //是否显示，默认FALSE，即不显示
    isWeb: boolean; //是否WEB方式
  end;
  //父模块信息定义
  TMenu = record
    Caption: string; //父模块名
    ID: string; //父模块ID
    isValid: boolean; //子模块是否有效,默认FALSE即无效
    isWeb: boolean; //父模块是否为WEB方式
    SubMenu: array of TSubMenu; //对应的子模块
  end;
  //用户信息定义
  TUserInfo = class(TObject)
  private
    UserName: string; //用户名
    Password: string; //密码
    CNName: string; //中文姓名
  protected

  public
    //用户对应的模块列表
    MenuList: array of TMenu;
    //返回-1：其他错误; 返回0：登陆成功；
    //返回1：用户不存在；返回2：密码错误
    function funcLogin: integer;
    //组织用户对应的功能
    function funcGetMenuList: boolean;
    //获取用户名
    function GetUserName(): string;
    //获取密码
    function GetPassword(): string;
    //获取中文名
    function GetCNName(): string;
    constructor Create(AName, APwd: string);

  end;
var
   //  OraSession1: TOraSession;
  //  OraQuery1: TOraQuery;
  //数据库相关变量
  DBConn: TADOConnection;
  PtConn: PDBConn; //DLL模块中使用
  DBQuery, DBQueryTmp, DBQueryBaK: TADOQuery;
  DEVPHYID, dllstr, DBSOURCE, DBUser, DBPASS, DBIP, port, DBCONNSTR: string;
  baud, posport: integer;
  dllnamelist: Tstringlist;
  menunamelist: Tstringlist;
  //CurrUserName:string;
  //用户信息
  User: TUserInfo;
  PtUser: PUser; //DLL模块中使用
  usename: string;
  debug: string;
  //打印相关
  PrintName: string; //打印机名称
  PrintIndex: integer; //当前打印机序号
  Orient: integer; //打印方向
  X, Y: integer; //X方向调整值，Y方向调整值
  ORA_CONNECT_STRING: string;



//加密 dll
function adddlllist(dllstr: string): boolean;
function calc_oper_pwd(oper_code: pchar; pwd: pchar; text: pchar): longint; stdcall; far; external 'desdll.dll' name 'calc_oper_pwd';
function SMT_ControlBuzzer: longint; stdcall; external 'KS_ThirdInterface.dll' name 'SMT_ControlBuzzer';
//读学工号  *
function SMT_ReadCardNo(cardno: pchar): longint; stdcall; external 'KS_ThirdInterface.dll' name 'SMT_ReadCardNo';
//读取金额
function SMT_ReadBalance(var Balance: integer): longint; stdcall; external 'KS_ThirdInterface.dll' name 'SMT_ReadBalance';
 //交易
function SMT_PacketDelMomey(nMoney: integer; var nFlowNo: integer): longint; stdcall; external 'KS_ThirdInterface.dll' name 'SMT_PacketDelMomey';
//打开串口
function SMT_ConnectMF280(port: integer; baud: integer): longint; stdcall; external 'KS_ThirdInterface.dll' name 'SMT_ConnectMF280';
//关闭串口
function SMT_CloseMF280: longint; stdcall; external 'KS_ThirdInterface.dll' name 'SMT_CloseMF280';
  //加密函数
function encOperPwd(operCode, operPwd: string): string;
function FuncShowMessage(hdl: HWND; StrMsg: string; IntMsgType: integer): integer;
//获取应用程序路径
function GetAppPath: string;
//连接数据库
function funcConnectDB(): boolean; overload;
function funcConnectDB(Pt: PDBConn): boolean; overload;
//查询SQL
function funcSelectSql(ASql: string; AQuery: TADOQuery; PtEnable: boolean = true): boolean;

//执行SQL
function funcExcuteSql(ASql: string; AQuery: TADOQuery; PtEnable: boolean = true): boolean;

//利用param来执行SQL
//function funcExcuteSqlForChinese(AQuery: TOraQuery; PtEnable: boolean = true): boolean;
function writelog(strmessage: string): boolean;
//读取INI文件
procedure procGetIniInfo;
//写入INI文件
procedure procWriteIniInfo();
//获取系统目录
function funcGetSystemDir: string;
//获取子字符串
function FuncGetSubStr(Str, AStart, AEnd: string): string;
//由字符串得到数值
function Fun_CurrGetValue(SrcStr: string): Double;
//由数值得到千分位字符串
function Fun_StrFormatEditValue(Curr: Double): string;
//由输入框得到数值
function Fun_CurrGetEditValue(SrcObj: TEdit): Double;
//输入框千分位得到标准字符串
function Fun_StrGetFloatStr(SrcStr: string): string;
//返回转化日期
function funcConvertDate(ADate: string): TDate;
function funcFillZero(AID: string; len: integer = 10): string;
//加1后，在字符串前填充0
function funcGetNewID(AID: string; Len: Integer = 10): string;
//去除字符串中空格
function funcEraseStringSpace(AStr: string): string;

function GetNextStr(var SrcStr: string; ASPLIT: string = ','): string;
//释放分配的数据集内存
procedure procDestroyDBSET;

procedure saveUserCode(userCode: string);
function readUserCode(): string;


implementation

function writelog(strmessage: string): boolean;
var
  myfile: TextFile;
  size, FileHandle: Integer;
  filename: string;
  patch: string;
begin
  result := true;
  patch := ExtractFilePath(ParamStr(0));
  filename := patch + 'log.txt';
  AssignFile(myfile, filename);
  try
    if FileExists(filename) then
    begin
      Append(myfile);
    end
    else
      ReWrite(myfile);
    Writeln(myfile, strmessage);
  finally
    CloseFile(myfile);
  end;
  result := false;
end;


function readUserCode(): string;
var
  iniFile: TiniFile;
  sFile: string;
begin
  sFile := GetAppPath + USERCODEFILE;
  iniFile := TIniFile.Create(sFile);
  result := '';
  try
    result := iniFile.ReadString('usercode', 'usename', '');

  finally
    iniFile.Free;
  end;

end;

procedure saveUserCode(userCode: string);
var
  INI: TIniFile;
  sFile: string;
begin
  sFile := GetAppPath + USERCODEFILE;
  INI := TIniFile.Create(sFile);
  try
    ini.Writestring('usercode', 'usename', userCode);
  finally
    Ini.Free;
  end;
end;


procedure procDestroyDBSET;
begin
  DBQuery.Close;
  DBQueryTmp.Close;
  DBQueryBak.Close;
  dllnamelist.Free;
  menunamelist.Free;
end;

function GetNextStr(var SrcStr: string; ASPLIT: string = ','): string;
var
  i: integer;
begin
  result := '';
  if SrcStr = '' then exit;
  i := pos(ASPLIT, SrcStr);
  if i <> 0 then
  begin
    result := copy(SrcStr, 1, i - 1);
    SrcStr := copy(SrcStr, i + Length(ASPLIT), Length(SrcStr));
  end
  else
  begin
    result := SrcStr;
    SrcStr := '';
  end;
end;

function adddlllist(dllstr: string): boolean;
var
  getstr: string;
  outwhile: boolean;
begin
  dllnamelist := Tstringlist.Create;
  menunamelist := Tstringlist.Create;
  while outwhile do
  begin
    getstr := GetNextStr(dllstr);
    if getstr = '' then
    begin
      outwhile := false;
    end
    else
    begin
      dllnamelist.Add(getstr);
      getstr := GetNextStr(dllstr);
      menunamelist.Add(getstr);
    end


  end;
end;

function funcEraseStringSpace(AStr: string): string;
var
  i: integer;
begin
  AStr := UpperCase(Trim(AStr));
  i := pos('OR', AStr);
  if i <> 0 then
    AStr := copy(AStr, 1, i - 1) + copy(AStr, i + 2, maxint);
  result := AStr;
end;



function funcFillZero(AID: string; len: integer = 10): string;
var
  i, p: integer;
begin
  if AID = '' then
    AID := '1';
  p := length(AID);
  if (p >= Len) then
    AID := copy(AID, 1, Len);
  for i := 1 to (Len - p) do
    AID := '0' + AID;
  result := AID;
end;

function funcGetNewID(AID: string; Len: Integer): string;
var
  i, p: integer;
  temp: LONGINT;
begin
  if AID = '' then
    AID := '1';
  temp := StrToInt(AID);
  inc(temp);
  AID := IntToStr(temp);
  result := funcFillZero(AID, Len);
end;

function funcConvertDate(ADate: string): TDate;
var
  tmp: char;
begin
  result := Date();
  if length(ADate) <> 8 then exit;
  ADate := copy(ADate, 1, 4) + '-' + copy(ADate, 5, 2) + '-' + copy(ADate, 7, 2);
  tmp := DateSeparator;
  try
    DateSeparator := '-';
    try
      result := StrToDate(ADate);
    except
      exit;
    end;
  finally
    DateSeparator := tmp;
  end;
end;

function Fun_StrGetFloatStr(SrcStr: string): string;
begin
  result := SysUtils.FormatFloat('0.00', Fun_CurrGetValue(SrcStr));
end;

function Fun_CurrGetEditValue(SrcObj: TEdit): Double;
begin
  try
    result := Fun_CurrGetValue(SrcObj.Text);
  except
    on e: exception do begin
      SrcObj.SetFocus();
      SrcObj.SelectAll();
      raise Exception.Create(e.message);
    end;
  end;
end;

function Fun_StrFormatEditValue(Curr: Double): string;
var
  str: string;
begin
  str := SysUtils.FloatToStrF(Curr, ffFixed, 18, 4);
  result := SysUtils.FormatFloat('#,##0.00', Fun_CurrGetValue(str));
end;

function Fun_CurrGetValue(SrcStr: string): Double; //由输入框得到数值
var str: string;
  i: integer;
  c, d: char;
begin
  result := 0;
  for i := 1 to Length(SrcStr) do
    if SrcStr[i] in ['0'..'9', '.', '-'] then str := str + SrcStr[i];
  if str = '' then exit;
  try
    c := #0;
    i := pos('.', Str);
    if (i > 14) or ((i = 0) and (Length(str) > 14)) then raise Exception.Create('');
    if (i > 0) and (Length(Str) >= i + 3) then begin
      c := Str[i + 3];
      Str := copy(Str, 1, i + 2);
    end;
    d := sysutils.DecimalSeparator;
    sysutils.DecimalSeparator := '.';
    result := SysUtils.StrToFloat(str);
    if c in ['5'..'9'] then result := result + 0.01;
    sysutils.DecimalSeparator := d;
  except
    on e: Exception do begin
      raise Exception.Create('值过大或无效!' + str + #13 + e.Message);
    end;
  end;
end;

function FuncGetSubStr(Str, AStart, AEnd: string): string;
var
  iStart, iEnd: integer;
begin
  iStart := pos(AStart, Str);
  iEnd := pos(AEnd, Str);
  Result := copy(Str, iStart + 1, iEnd - iStart - 1);
end;

function funcGetSystemDir: string;
var
  dir: array[0..255] of char;
begin
  GetWindowsDirectory(dir, 255);
  result := dir;
end;

procedure procWriteIniInfo();
var
  INI: TIniFile;
  sFile: string;
begin
  sFile := GetAppPath + CONFIGFILE;
  INI := TIniFile.Create(sFile);
  try
  {
    Ini.WriteString('DB', 'DBIP', DBIP);
    Ini.WriteString('DB', 'PORT', port);
    Ini.WriteString('DB', 'SOURCE', DBSOURCE);
    Ini.WriteString('DB', 'USER', DBUSER);
    Ini.WriteString('DB', 'PASS', DBPASS);
    Ini.WriteString('dll', 'dllname', DBPASS);
    Ini.Writeinteger('pos', 'port', posport);
    Ini.Writeinteger('pos', 'baud', baud);
    ini.Writestring('device', 'DEVPHYID', DEVPHYID);
   }
    ini.Writestring('use', 'usename', usename);
  finally
    Ini.Free;
  end;
end;

procedure procGetIniInfo;
var
  INI: TIniFile;
  sFile: string;
begin
  sFile := GetAppPath + CONFIGFILE;
  INI := TIniFile.Create(sFile);
  try
    DBIP := INI.ReadString('DB', 'DBIP', '');
    port := INI.ReadString('DB', 'PORT', '');
    DBSOURCE := INI.ReadString('DB', 'DBSOURCE', '');
    DBUSER := INI.ReadString('DB', 'USER', '');
    DBPASS := INI.ReadString('DB', 'PASS', '');
    dllstr := INI.ReadString('dll', 'dllname', '');
    posport := INI.Readinteger('pos', 'posport', 1);
    baud := INI.Readinteger('pos', 'baud', 19200);
    DEVPHYID := INI.Readstring('device', 'TERMID', '');
    dllstr := INI.ReadString('dll', 'dllname', '');
    usename := INI.ReadString('use', 'usename', '');
    debug := INI.readstring('use', 'debug', 'false');

  //  ORA_CONNECT_STRING := '' + DBUSER + '' + '/' + '' + DBPASS + '' + '@' + '' + DBIP + '' + ':' + '' + port + '' + ':' + '' + DBSOURCE + '';
  ORA_CONNECT_STRING := 'Provider=IBMDADB2.DB2COPY1;Password=' + DBPASS + ';Persist Security Info=True;User ID=' + DBUSER + ';Data Source=' + DBSOURCE + ';Location=' + DBIP + ';Extended Properties=""';
finally
    INI.Free;
  end;
end;

{$WARNINGS OFF}

function FuncShowMessage(hdl: HWND; StrMsg: string; IntMsgType: integer): integer;
begin
  result := 0;
  case IntMsgType of
    0: MessageBox(HDL, Pchar(StrMsg), '提示', MB_OK + MB_ICONINFORMATION);
    1: MessageBox(HDL, Pchar(StrMsg), '警告', MB_OK + MB_ICONWARNING);
    2: MessageBox(HDL, Pchar(StrMsg), '错误', MB_OK + MB_ICONERROR);
    3: result := MessageBox(HDL, Pchar(StrMsg), '提示', MB_YESNO + MB_ICONQUESTION);
    4: result := MessageBox(HDL, Pchar(StrMsg), '提示', MB_YESNOCANCEL + MB_ICONQUESTION);
  end;
end;
{$WARNINGS ON}

function GetAppPath: string;
begin
  result := ExtractFilePath(Application.ExeName);
end;

function funcConnectDB(Pt: PDBConn): boolean;
begin
  result := false;

  if DBConn = nil then begin
    DBConn := TADOConnection.Create(nil);
  end;
  if DBQuery = nil then
    DBQuery := TADOQuery.Create(nil);
  if DBQueryTmp = nil then
    DBQueryTmp := TADOQuery.Create(nil);
  if DBQueryBak = nil then
    DBQueryBak := TADOQuery.Create(nil);
 // DBCONNSTR := format(ORA_CONNECT_STRING, [DBPASS, DBUSER, DBSOURCE]);
  if Pt^.Connected then
  begin
    result := true;
    DBQuery.Connection := Pt^;
    DBQueryTmp.Connection := Pt^;
    DBQueryBak.Connection := Pt^;
    result := true;
    exit;
  end;
  try
    Pt^.ConnectionString := ORA_CONNECT_STRING;
    Pt^.LoginPrompt := false;
    DBQuery.Connection := Pt^;
    DBQueryTmp.Connection := Pt^;
    DBQueryBak.Connection := Pt^;
    Pt^.Connected := true;
  except
    on e: exception do
      writelog('连接错误:' + e.Message);
  //    FuncShowMessage(Application.Handle, '连接错误:' + e.Message, 2);
  end;
  result := true;
end;

function funcConnectDB(): boolean;
begin
  result := false;
  if DBConn = nil then begin
    DBConn := TADOConnection.Create(nil);
  end;
  if DBQuery = nil then
    DBQuery := TADOQuery.Create(nil);
  if DBQueryTmp = nil then
    DBQueryTmp := TADOQuery.Create(nil);
  if DBQueryBaK = nil then
    DBQueryBaK := TADOQuery.Create(nil);
  if DBConn.Connected then
  begin
    result := true;
    DBQuery.Connection := DBConn;
    DBQueryTmp.Connection := DBConn;
    DBQueryBaK.Connection := DBConn;
    result := true;
    exit;
  end;
  try

    DBConn.ConnectionString := ORA_CONNECT_STRING;
    DBConn.LoginPrompt := false;
    DBQuery.Connection := DBConn;
    DBQueryTmp.Connection := DBConn;
    DBQueryBaK.Connection := DBConn;
    DBConn.Open();
  except
    on e: exception do
    begin
      writelog('连接错误:' + e.Message);
    //  FuncShowMessage(Application.Handle, '连接错误:' + e.Message, 2);
      exit;
    end;
  end;
  result := true;
end;
 {
function funcSelectSqlWithParams(AQuery: TOraQuery; PtEnable: boolean = true): boolean;
begin
  if PtEnable then
  begin
    result := PtConn^.Connected;
    if not PtConn^.Connected then
    begin
      if not funcConnectDB(PtConn) then exit;
    end;
  end
  else
  begin
    result := DBConn.Connected;
    if not DBConn.Connected then
    begin
      if not funcConnectDB() then exit;
    end;
  end;
    AQuery.Open;
  AQuery.First;
  result := true;
end;

 }
function funcSelectSql(ASql: string; AQuery: TADOQuery; PtEnable: boolean = true): boolean;
begin

  try
    if not DBConn.Connected then
    begin
      if not funcConnectDB() then exit;
    end;
  AQuery.Close;
  AQuery.SQL.Clear;
  AQuery.SQL.Text := ASql;
  AQuery.Open;
  AQuery.First;
  result := true;
  except
  end;
end;

function encOperPwd(operCode, operPwd: string): string;
var
  outOperPwd: array[0..16] of Char;
  st: Integer;
begin
  st := calc_oper_pwd(PChar(operCode), PChar(Trim(operPwd)), @outOperPwd);
  if st <> 0 then
  begin
    FuncShowMessage(Application.Handle, '加密失败！', 2);
    Result := '';
    Exit;
  end;
  Result := outOperPwd;
end;

function funcExcuteSql(ASql: string; AQuery: TADOQuery; PtEnable: boolean = true): boolean;
begin
  result := false;
  if PtEnable then
  begin

    result := DBConn.Connected;
    if not DBConn.Connected then
    begin
      if not funcConnectDB() then exit;
    end;
  end;
  AQuery.Close;
  AQuery.SQL.Clear;
  AQuery.SQL.Text := ASql;
  AQuery.ExecSQL;
  result := true;
end;
 {
function funcExcuteSqlForChinese(AQuery: TOraQuery; PtEnable: boolean = true): boolean;
begin
  result := false;
  if PtEnable then
  begin
    result := PtConn^.Connected;
    if not PtConn^.Connected then
    begin
      if not funcConnectDB(PtConn) then exit;
    end;
  end
  else
  begin
    result := DBConn.Connected;
    if not DBConn.Connected then
    begin
      if not funcConnectDB() then exit;
    end;
  end;

  AQuery.ExecSQL;
  result := true;
end;
}
{ TUserInfo }



constructor TUserInfo.Create(AName, APwd: string);
begin
  self.UserName := AName;
  self.Password := APwd;
end;

function TUserInfo.funcGetMenuList: boolean;
var
  i, j, k: integer;
  sSql, ParentID, ChildID: string;
begin
  SetLength(MenuList, i + 1);
  MenuList[i].Caption := '体育场馆管理收费';
  MenuList[i].ID := '1';
  MenuList[i].isValid := true;
  for j := 1 to dllnamelist.Count do
  begin
    SetLength(MenuList[i].SubMenu, j + 1);
    MenuList[i].SubMenu[j].Caption := menunamelist[j - 1];
    MenuList[i].SubMenu[j].ID := inttostr(j);
    MenuList[i].SubMenu[j].DLL := dllnamelist[j - 1];
    MenuList[i].SubMenu[j].isVisble := true;
  end;
  result := true;
end;

function TUserInfo.funcLogin: integer;
var
  sSql: string;
  input: string;
  status: string;
  opertype: string;
begin
  result := -1;
  sSql := 'select * from YKT_CUR.T_PIF_OPERATOR where oper_code= '''+self.UserName+'''';
  DBQuery.close;
  DBQuery.SQL.Clear;
  if funcSelectSql(sSql,DBQuery, false) then
  begin
    if DBQuery.RecordCount <> 1 then
    begin
      result := 1;
      exit;
    end
    else
    try
      input := encOperPwd(self.UserName, Self.Password);
    except
    end;
    if UpperCase(DBQuery.FieldByName('pwd').AsString) <> input then
    begin
      result := 2;
      exit;
    end
    else
    begin
      opertype := DBQuery.FieldByName('if_access').AsString;
      if opertype <> '1' then
      begin
        result := 5;
        exit;
      end;
      status := DBQuery.FieldByName('STATUS').AsString;
      if status <> '1' then
      begin
        if status = '0' then
          result := 3;
        if status = '2' then
          result := 4;
      end
      else
        result := 0;
    end;
  end;
end;

function TUserInfo.GetCNName: string;
begin
  result := self.CNName;
end;

function TUserInfo.GetPassword: string;
begin
  result := self.Password;
end;

function TUserInfo.GetUserName: string;
begin
  result := self.UserName;
end;


end.


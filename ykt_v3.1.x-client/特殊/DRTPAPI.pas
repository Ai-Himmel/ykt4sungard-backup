unit DRTPAPI;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 1999 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      FINAL DELPHI-JEDI COMMANDLINE EDITION                               }
{                                                                          }
{    Generated Date:  2001-5-15                                            }
{    Generated Time: 17:19:19                                              }
{                                                                          }
{**************************************************************************}

// modified by Huang Yanlai

interface

uses Windows;

{=> DRTPAPI.H <=}

{///////////////////网络事件掩码//////////////////////////// }

const
  DRTP_READ = 1;
const
  DRTP_WRITE = 2;
const
  DRTP_EXCEPT = 4;
{/////////////////////////////////////////////////////////// }

var
  DRTPInitialize: function:  BOOL    stdcall ;
{+// }
{-功能：初始化。 }
{-参数：无。 }
{-返回值：如果初始化成功，返回TRUE，否则返回FALSE。 }
{-修改者：吴舸 20010404 }
{-修改原因：规范编码 }
{= }
var
  DRTPUninitialize: function:  BOOL    stdcall ;
{+// }
{-功能：释放资源 }
{-参数：无。 }
{-返回值：如果取消初始化成功，返回TRUE，否则返回FALSE }
{-修改者：吴舸 20010404 }
{-修改原因：规范编码 }
{= }
var
  DRTPGetHost: function(strIP: PChar;
                        var pwPort: Word;
                        wGatewayNo: Word=0;
                        wBroadcastPort: Word=1976;
                        dwTimeout: LongInt=5000):  Integer    stdcall ;
{+// }
{-功能：查找相应编号的路由通讯服务器的IP和端口号 }
{-参数： }
{-strIP[OUT]:保存路由通讯服务器的IP,由用户分配该空间 }
{-pwPort[OUT]:保存路由通讯服务器的端口号,由用户分配该空间 }
{-wGatewayNo[IN]:被查询的路由通讯服务器的编号 }
{-wBroadcastPort[IN]:广播端口号 }
{-dwTimeout[IN]:超时 }
{-返回值：找到则返回相应的路由通讯服务器编码，否则返回-1 }
{-修改者：吴舸 20010404 }
{-修改原因：规范编码 }
{= }
var
  DRTPConnect: function(strIP: PChar;
                        wPort: Word;
                        Encode: Word):  THANDLE    stdcall ;
{+// }
{-功能：建立与路由通讯服务器的连接 }
{-参数： }
{-strIP[IN]:路由通讯服务器的IP地址 }
{-wpPort[IN]:路由通讯服务器的端口号 }
{-Encode[IN]:加密方式 }
{-返回值：如果连接成功，返回新建连接的句柄，否则返回NULL。 }
{-修改者：吴舸 20010404 }
{-修改原因：规范编码 }
{= }
var
  DRTPClose: function(hConnection: THandle):  BOOL    stdcall ;
{+// }
{-功能：关闭与路由通讯服务器的连接 }
{-参数： }
{-hConnection[IN]:由DRTPConnect返回的HANDLE }
{-返回值：如果关闭成功，返回TRUE，否则返回FALSE。 }
{-修改者：吴舸 20010404 }
{-修改原因：规范编码 }
{= }
var
  DRTPSend: function(hConnection: THandle;
                     wDestNo: Word;
                     wFunction: Word;
                     pSendData: PChar;
                     iLen: Integer;
                     byFunctionPriority: BYTE;
                     Designed: BOOL=false):  BOOL    stdcall ;
{+// }
{-功能：发送请求\应答数据 }
{-参数： }
{-hConnection[in]：连接句柄。调用DRTPConnect时返回。 }
{-dwDestNo [in]：接收方代码。如果调用者为服务端则忽略本参数。 }
{-dwMainFunction [in]：接收方主功能号。如果调用者为服务端则忽略本参数。 }
{-pSendData [in]：发送缓冲区。 }
{-iLen[in]：待发送的字节数。 }
{-ByFunctionPriority[in]：功能号优先级。 }
{///1为优先级高于标准 }
{///2为标准优先级 }
{///3为优先级低于标准 }
{-Designed[IN]:指定路由标记 }
{///true为指定路由 }
{///false为非指定路由 }
{-返回值：如果发送成功，返回TRUE，否则返回FALSE。 }
{-修改者：吴舸 20010404 }
{-修改原因：规范编码 }
{= }
var
  DRTPReceive: function(hConnection: THandle;
                        recvBuffer: PChar;
                        iBufferSize: Integer;
                        dwTIMEOUT: DWORD =0):  Integer    stdcall ;
{+// }
{-功能：接收数据。 }
{-参数： }
{-hConnection[in]：连接句柄。调用DRTPConnect时返回。 }
{-recvBuffer [out]：接收缓冲区，最小4096字节。 }
{-iBufferSize[in]：接收缓冲区字节数。 }
{-dwTimeout [in]：接收超时。如果为0，则为阻塞方式。 }
{-返回值： }
// 黄燕来订正 ：接收成功，返回1
{-接收成功，返回接收到的字节数； }
{-接收超时，否则0； }
{-接收失败，返回-1 }
{-路由通讯服务器返回信息，返回值为 -4，可以用DRTPGetLastError()来取得 }
{-相应的信息（字符串） }

{-修改者：吴舸 20010404 }
{-修改原因：规范编码 }
{= }
var
  DRTPCheckNetState: function(hConnection: THandle;
                              dwTimeout: DWORD=2000):  BOOL    stdcall ;
{+// }
{-功能：检查网络连接状态。 }
{-参数： }
{-hConnection[in]：连接句柄。调用DRTPConnect时返回。 }
{-dwTimeout[in]：检测超时（毫秒）。0为Block方式。 }
{-返回值：如果连接正常，返回值大于0，否则值小于0，如果检测超时，返回0。 }
{-修改者：吴舸 20010404 }
{-修改原因：规范编码 }
{= }
var
  DRTPCheckDataArrived: function(hConnection: THandle;
                                 dwTimeout: DWORD=0):  BOOL    stdcall ;
{+// }
{-功能：检查特定连接上是否有数据尚未接收。 }
{-参数： }
{-hConnection[in]：连接句柄。调用DRTPConnect时返回。 }
{-dwTimeout[in]：检测时间（毫秒）。0为Block方式。 }
{-返回值：如果有未接收数据，返回TRUE，否则返回FALSE。 }
{-修改者：吴舸 20010404 }
{-修改原因：规范编码 }
{= }
var
  DRTPGetLastError: function(hConnection: THandle; 
                             ErrorMsgBuffer: PChar; 
                             iMsgBufferSize: Integer):  Integer    stdcall ;
{+// }
{-功能：返回特定连接上的错误信息。 }
{-参数： }
{-hConnection[in]：连接句柄。调用DRTPConnect时返回。 }
{-ErrorMsgBuffer[in]:保存错误信息的缓冲区 }
{-iMsgBufferSize[in]:缓冲区的长度 }
{-返回值：成功返回1，失败返回0 }
{-修改者：吴舸 20010404 }
{-修改原因：规范编码 }
{= }


var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
     = False;

implementation

var
  //SaveExit: pointer;
  DLLHandle: THandle;
  ErrorMode: Integer;

  (*
  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};
  *)

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});

  DLLHandle := LoadLibrary('DRTPAPI.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    (*
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    *)
    @DRTPInitialize := GetProcAddress(DLLHandle,'DRTPInitialize');

    Assert(@DRTPInitialize <> nil);

    @DRTPUninitialize := GetProcAddress(DLLHandle,'DRTPUninitialize');

    Assert(@DRTPUninitialize <> nil);

    @DRTPGetHost := GetProcAddress(DLLHandle,'DRTPGetHost');

    Assert(@DRTPGetHost <> nil);

    @DRTPConnect := GetProcAddress(DLLHandle,'DRTPConnect');

    Assert(@DRTPConnect <> nil);

    @DRTPClose := GetProcAddress(DLLHandle,'DRTPClose');

    Assert(@DRTPClose <> nil);

    @DRTPSend := GetProcAddress(DLLHandle,'DRTPSend');

    Assert(@DRTPSend <> nil);

    @DRTPReceive := GetProcAddress(DLLHandle,'DRTPReceive');

    Assert(@DRTPReceive <> nil);

    @DRTPCheckNetState := GetProcAddress(DLLHandle,'DRTPCheckNetState');

    Assert(@DRTPCheckNetState <> nil);

    @DRTPCheckDataArrived := GetProcAddress(DLLHandle,'DRTPCheckDataArrived');

    Assert(@DRTPCheckDataArrived <> nil);

    @DRTPGetLastError := GetProcAddress(DLLHandle,'DRTPGetLastError');

    Assert(@DRTPGetLastError <> nil);

  end
  else
  begin
    DLLLoaded := False;
    { Error: DRTPAPI.DLL could not be loaded !! }
  end;
  SetErrorMode(ErrorMode)

end {LoadDLL};

begin
  LoadDLL;
end.

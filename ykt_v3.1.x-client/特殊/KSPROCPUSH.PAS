unit KSPROCPUSH;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date:   2004-3-1                                            }
{    Generated Time: 14:59:46                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> d:\期货新版030522\4编码\交易部分\include\KSPROCPUSH.H <=}

{///功能：推送数据处理函数 }
{///参数说明： }
{///recvpack[输入]:接收到的数据缓冲(ST_CPACK格式) }
{///ackpack[输出]:如果需要应答包的话，应答数据的缓冲(ST_CPACK格式) }
{///pAckFlag[输出]:需要应答包标记， 0：不需要应答包 }
{/// 1：需要应答包 }
{///pCtlFlag[输出]:控制消息标记， 0：不是控制消息 }
{/// 1：是控制消息 }
{///szMsg[输出]:信息输出 }
{///返回值： }
{///0 成功 }
{///-1 失败，接收到的数据非推送类数据 }
{///其他 失败，可以通过szMsg知道失败原因 }
var
  ProcPush_ProcPushData: function(recvpack: PChar; 
                                  ackpack: PChar; 
                                  var pAckFlag: Integer; 
                                  var pCtlFlag: Integer; 
                                  szMsg: PChar): Integer {$IFDEF WIN32} stdcall {$ENDIF}; 

{///功能：初始化数据函数 }
{///参数说明： }
{///nBatch[输入]:会话批次号 }
{///返回值： }
{///0 成功 }
{///其他 失败 }
var
  ProcPush_Init: function(nBatch: Integer): Integer {$IFDEF WIN32} stdcall {$ENDIF}; 

{///功能：初始化资源函数 }
{///参数说明： }
{///返回值： }
{///0 成功 }
{///其他 失败 }
var
  ProcPush_InitRes: function: Integer {$IFDEF WIN32} stdcall {$ENDIF}; 

{///功能：释放资源函数 }
{///参数说明： }
{///返回值： }
{///0 成功 }
{///其他 失败 }
var
  ProcPush_FreeRes: procedure {$IFDEF WIN32} stdcall {$ENDIF}; 

{///功能：设置控制消息函数 }
{///参数说明： }
{///nCount[输入]:控制消息个数 }
{///ControlReq[输入]:控制消息数组 }
{///返回值： }
{///0 成功 }
{///其他 失败 }
var
  ProcPush_SetControlReqTypes: function(nCount: Integer; 
                                        ControlReq: Pointer): Integer {$IFDEF WIN32} stdcall {$ENDIF};

var
//功能：判断是否为有效推送数据函数
//参数说明：
//recvpack[输入]:接收到的数据缓冲(ST_CPACK格式)
//返回值：
//0 有效数据 
//其他 无效数据
  ProcPush_CheckValidPushData: function(recvpack: PChar) : Integer {$IFDEF WIN32} stdcall {$ENDIF};

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('KSPROCPUSH.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @ProcPush_ProcPushData := GetProcAddress(DLLHandle,'_ProcPush_ProcPushData@20');
  {$IFDEF WIN32}
    Assert(@ProcPush_ProcPushData <> nil);
  {$ENDIF}
    @ProcPush_Init := GetProcAddress(DLLHandle,'_ProcPush_Init@4');
  {$IFDEF WIN32}
    Assert(@ProcPush_Init <> nil);
  {$ENDIF}
    @ProcPush_InitRes := GetProcAddress(DLLHandle,'_ProcPush_InitRes@0');
  {$IFDEF WIN32}
    Assert(@ProcPush_InitRes <> nil);
  {$ENDIF}
    @ProcPush_FreeRes := GetProcAddress(DLLHandle,'_ProcPush_FreeRes@0');
  {$IFDEF WIN32}
    Assert(@ProcPush_FreeRes <> nil);
  {$ENDIF}
    @ProcPush_SetControlReqTypes := GetProcAddress(DLLHandle,'_ProcPush_SetControlReqTypes@8');
  {$IFDEF WIN32}
    Assert(@ProcPush_SetControlReqTypes <> nil);
  {$ENDIF}
    @ProcPush_CheckValidPushData := GetProcAddress(DLLHandle,'_ProcPush_CheckValidPushData@4');
  {$IFDEF WIN32}
    Assert(@ProcPush_CheckValidPushData <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: KSPROCPUSH.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.

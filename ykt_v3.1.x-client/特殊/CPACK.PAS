unit CPACK;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 2003-11-18                                            }
{    Generated Time: 20:28:59                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> d:\demos\hqclient\CPACK.H <=}


{/// The following ifdef block is the standard way of creating macros which make exporting }
{/// from a DLL simpler. All files within this DLL are compiled with the CPACK_EXPORTS }
{/// symbol defined on the command line. this symbol should not be defined on any project }
{/// that uses this DLL. This way any other project whose source files include this file see }
{/// CPACK_API functions as being imported from a DLL, wheras this DLL sees symbols }
{/// defined with this macro as being exported. }
{$IFNDEF CPACK_H}
{$DEFINE CPACK_H}

{$IFDEF CPACK_EXPORTS}
const
  CPACK_API = __declspec(dllexport);
{$ELSE}
const
  CPACK_API = __declspec(dllimport);
{$IFDEF _DEBUG}
{ #pragma comment(lib,"..\\lib\\cpackd.lib") }
{ #pragma message("Automatically linking with cpackd.dll") }
{$ELSE}
{ #pragma comment(lib,"..\\lib\\cpack.lib") }
{ #pragma message("Automatically linking with cpack.dll") }
{$ENDIF}
{$ENDIF}

{$IFDEF __cplusplus}
{$ENDIF}
{+// 以下代码是用来字节对齐使用的*/ }
{$IFNDEF WIN32}
{$IFNDEF __GNUC__}
{$DEFINE __PACKED__}
{ #pragma options align=packed }
{$ELSE}
const
  __PACKED__ = __attribute__ ((packed));
{ #pragma pack(push,1) }
{$ENDIF}
{$ELSE}
{$DEFINE __PACKED__}
{ #pragma pack(push,1) }
{$ENDIF}

{+// 定义了PARMBITS的最大大小了每字节的BITS数*/ }
const
  PARMBITS = (256);
const
  BITSPERBYTE = (8);

{+// }
{-地址资料 }
{= }
type
  st_addr = record
    addr: Array[0..6-1] of Byte;
  end {st_addr};

type
  st_hook = record
    UserID: Word;
{= 请求者的ID号码 }
    hostname: Array[0..33-1] of Char;
{= 主机名 }
    queuename: Array[0..33-1] of Char;
{= 队列名 }
    queuetype: Word;
{= 队列类型 }
  end {st_hook};

{+// }
{-包头结构 }
{= }
type
  st_packhead = record
    RequestType: Word;
    firstflag: Byte;
{= 是否第一个请求（首包请求） }
    nextflag: Byte;
{= 是否后续包请求 }
    recCount: Word;
{= 本包的记录数 }
    retCode: Word;
{= 返回代码 }

    addr: ST_ADDR;
{= 请求着的地址（6个子节） }
    hook: ST_HOOK;
{= }
    userdata: Word;
{= }

    ParmBits: Array[0..PARMBITS/BITSPERBYTE-1] of Byte;
  end {st_packhead};

{+// }
{-定义了每一个pack成员的设置值，格式如下： }
{-0xAABB }
{-AA: 成员在PARMBITS中的字节号(0开始) }
{-BB: 成员在这个字节的位图 }
{= }
const
  F_SCUST_NO = $0001;
const
  F_SCUST_NO2 = $0002;
const
  F_SHOLDER_AC_NO = $0004;
const
  F_SHOLDER_AC_NO2 = $0008;
const
  F_SHOLDER_TYPE = $0010;
const
  F_SHOLDER_TYPE2 = $0020;
const
  F_SNAME = $0040;
const
  F_SNAME2 = $0080;

const
  F_SALL_NAME = $0101;
const
  F_SMARKET_CODE = $0102;
const
  F_SMARKET_CODE2 = $0104;
const
  F_SDATE0 = $0108;
const
  F_SDATE1 = $0110;
const
  F_SDATE2 = $0120;
const
  F_SDATE3 = $0140;
const
  F_STIME0 = $0180;

const
  F_STIME1 = $0201;
const
  F_STIME2 = $0202;
const
  F_STIME3 = $0204;
const
  F_LVOL0 = $0208;
const
  F_LVOL1 = $0210;
const
  F_LVOL2 = $0220;
const
  F_LVOL3 = $0240;
const
  F_LVOL4 = $0280;

const
  F_LVOL5 = $0301;
const
  F_LVOL6 = $0302;
const
  F_LVOL7 = $0304;
const
  F_LVOL8 = $0308;
const
  F_LVOL9 = $0310;
const
  F_LVOL10 = $0320;
const
  F_LVOL11 = $0340;
const
  F_LVOL12 = $0380;

const
  F_DAMT0 = $0401;
const
  F_DAMT1 = $0402;
const
  F_DAMT2 = $0404;
const
  F_DAMT3 = $0408;
const
  F_DAMT4 = $0410;
const
  F_DAMT5 = $0420;
const
  F_DAMT6 = $0440;
const
  F_DAMT7 = $0480;

const
  F_DAMT8 = $0501;
const
  F_DAMT9 = $0502;
const
  F_DAMT10 = $0504;
const
  F_DAMT11 = $0508;
const
  F_DAMT12 = $0510;
const
  F_DAMT13 = $0520;
const
  F_DAMT14 = $0540;
const
  F_DAMT15 = $0580;

const
  F_DAMT16 = $0601;
const
  F_DAMT17 = $0602;
const
  F_DAMT18 = $0604;
const
  F_DAMT19 = $0608;
const
  F_DAMT20 = $0610;
const
  F_DAMT21 = $0620;
const
  F_DAMT22 = $0640;
const
  F_DAMT23 = $0680;

const
  F_DAMT24 = $0701;
const
  F_DAMT25 = $0702;
const
  F_DAMT26 = $0704;
const
  F_DAMT27 = $0708;
const
  F_DAMT28 = $0710;
const
  F_DAMT29 = $0720;
const
  F_DAMT30 = $0740;
const
  F_DAMT31 = $0780;

const
  F_DAMT32 = $0801;
const
  F_DAMT33 = $0802;
const
  F_SSTOCK_CODE = $0804;
const
  F_SSTOCK_CODE2 = $0808;
const
  F_SCUST_TYPE = $0810;
const
  F_SCUST_TYPE2 = $0820;
const
  F_SSTAT_TYPE = $0840;
const
  F_SSTAT_TYPE2 = $0880;

const
  F_SROOM_NO = $0901;
const
  F_SROOM_NO2 = $0902;
const
  F_SOPEN_EMP = $0904;
const
  F_SCLOSE_EMP = $0908;
const
  F_SCHANGE_EMP = $0910;
const
  F_SCHECK_EMP = $0920;
const
  F_SEMP = $0940;
const
  F_SNATION_CODE = $0980;

const
  F_LCERT_CODE = $0A01;
const
  F_STX_PWD = $0A02;
const
  F_STX_PWD2 = $0A04;
const
  F_SWITHDRAW_PWD = $0A08;
const
  F_SWITHDRAW_PWD2 = $0A10;
const
  F_SEMP_PWD = $0A20;
const
  F_SEMP_PWD2 = $0A40;
const
  F_SBANK_PWD = $0A80;

const
  F_SBANK_PWD2 = $0B01;
const
  F_SCUST_AUTH = $0B02;
const
  F_SCUST_AUTH2 = $0B04;
const
  F_SCUST_LIMIT = $0B08;
const
  F_SCUST_LIMIT2 = $0B10;
const
  F_LSAFE_LEVEL = $0B20;
const
  F_LSAFE_LEVEL2 = $0B40;
const
  F_SPOST_CODE = $0B80;

const
  F_SPOST_CODE2 = $0C01;
const
  F_SPHONE = $0C02;
const
  F_SPHONE2 = $0C04;
const
  F_SPHONE3 = $0C08;
const
  F_SPAGER = $0C10;
const
  F_SEMAIL = $0C20;
const
  F_SEMAIL2 = $0C40;
const
  F_SNOTE = $0C80;

const
  F_SNOTE2 = $0D01;
const
  F_SCERT_NO = $0D02;
const
  F_SCERT_NO2 = $0D04;
const
  F_SCERT_ADDR = $0D08;
const
  F_SSTATUS0 = $0D10;
const
  F_SSTATUS1 = $0D20;
const
  F_SSTATUS2 = $0D40;
const
  F_SSTATUS3 = $0D80;

const
  F_SSTATUS4 = $0E01;
const
  F_LWITHDRAW_FLAG = $0E02;
const
  F_SADDR = $0E04;
const
  F_SADDR2 = $0E08;
const
  F_SSERIAL0 = $0E10;
const
  F_SSERIAL1 = $0E20;
const
  F_SSERIAL2 = $0E40;
const
  F_SSERIAL3 = $0E80;

const
  F_SSERIAL4 = $0F01;
const
  F_SCURRENCY_TYPE = $0F02;
const
  F_SCURRENCY_TYPE2 = $0F04;
const
  F_SBRANCH_CODE0 = $0F08;
const
  F_SBRANCH_CODE1 = $0F10;
const
  F_SBRANCH_CODE2 = $0F20;
const
  F_USSET0 = $0F40;
const
  F_USSET1 = $0F80;

const
  F_USSET2 = $1001;
const
  F_USSET3 = $1002;
const
  F_USSET4 = $1004;
const
  F_USSET5 = $1008;
const
  F_USSET6 = $1010;
const
  F_SSTATION0 = $1020;
const
  F_SSTATION1 = $1040;
const
  F_SBANK_ACC = $1080;

const
  F_SBANK_ACC2 = $1101;
const
  F_LBANK_ACC_TYPE = $1102;
const
  F_LBANK_ACC_TYPE2 = $1104;
const
  F_SMAIN_FLAG = $1108;
const
  F_SMAIN_FLAG2 = $1110;
const
  F_SBANK_CODE = $1120;
const
  F_SBANK_CODE2 = $1140;
const
  F_SEMP_NO = $1180;
const
  F_SEMP_NO2 = $1201;
const
  F_DRATE0 = $1202;
const
  F_DRATE1 = $1204;
const
  F_LSERIAL0 = $1208;
const
  F_LSERIAL1 = $1210;
const
  F_SBANKNAME = $1220;
const
  F_SBANKNAME2 = $1240;
const
  F_SCARD0 = $1280;

const
  F_SCARD1 = $1301;
const
  F_SORDER0 = $1302;
const
  F_SORDER1 = $1304;
const
  F_SORDER2 = $1308;
const
  F_SCUSTTYPES = $1310;
const
  F_SSECTYPES = $1320;

const
  F_VSMESS = $1601;
const
  F_VSVARSTR0 = $1602;
const
  F_VSVARSTR1 = $1604;
const
  F_VSVARSTR2 = $1608;
const
  F_VSVARSTR3 = $1610;

type
  __PACKED__ = record
    scust_no: Array[0..11-1] of Char;
{=1 客户号 }
    scust_no2: Array[0..11-1] of Char;
{= 第二客户号 }
    sholder_ac_no: Array[0..16-1] of Char;
{= 股东代码 }
    sholder_ac_no2: Array[0..16-1] of Char;
{= 第二股东代码 }
    sholder_type: Array[0..3-1] of Char;
{= 股东代码类别 }
    sholder_type2: Array[0..3-1] of Char;
{= 第二股东代码类别 }
    sname: Array[0..21-1] of Char;
{= 姓名 }
    sname2: Array[0..21-1] of Char;
{= 第二姓名 }

    sall_name: Array[0..81-1] of Char;
{=2 全名 }
    smarket_code: Array[0..2-1] of Char;
{= 市场代码 }
    smarket_code2: Array[0..2-1] of Char;
{= 市场代码2 }
    sdate0: Array[0..9-1] of Char;
{= 日期 委托日期 }
    sdate1: Array[0..9-1] of Char;
{= 日期 成交日期 }
    sdate2: Array[0..9-1] of Char;
{= 日期 报盘日期 }
    sdate3: Array[0..9-1] of Char;
{= 日期 发生日期 }
    stime0: Array[0..9-1] of Char;
{= 时间 委托时间 }

    stime1: Array[0..9-1] of Char;
{=3 时间 成交时间 }
    stime2: Array[0..9-1] of Char;
{= 时间 包盘时间 }
    stime3: Array[0..9-1] of Char;
{= 时间 发生时间 }
    lvol0: LongInt;
{= 数量0 委托数量 买量1 }
    lvol1: LongInt;
{= 数量1 成交数量 买量2 }
    lvol2: LongInt;
{= 数量2 可用数量 买量3 }
    lvol3: LongInt;
{= 数量3 手工冻结数量 买量4 }
    lvol4: LongInt;
{= 数量4 委托冻结数量 卖量1 }

    lvol5: LongInt;
{=4 数量5 买入成交数量 卖量2 }
    lvol6: LongInt;
{= 数量6 卖出成交数量 卖量3 }
    lvol7: LongInt;
{= 数量7 清算后余额 卖量4 }
    lvol8: LongInt;
{= 数量8 手工解冻数量 }
    lvol9: LongInt;
{= 数量9 存入数量 }
    lvol10: LongInt;
{= 数量10 取出数量 }
    lvol11: LongInt;
{= 数量11 买入未过户数量 }
    lvol12: LongInt;
{= 数量12 卖出未过户数量 }

    damt0: Double;
{=5 金额0 委托价格 }
    damt1: Double;
{= 金额1 委托金额 }
    damt2: Double;
{= 金额2 成交价格 }
    damt3: Double;
{= 金额3 成交金额 }
    damt4: Double;
{= 金额4 清算后余额 }
    damt5: Double;
{= 金额5 存入金额 }
    damt6: Double;
{= 金额6 取出金额 }
    damt7: Double;
{= 金额7 现金金额 }

    damt8: Double;
{=6 金额8 支汇票金额 }
    damt9: Double;
{= 金额9 异常冻结金额 }
    damt10: Double;
{= 金额10 买入冻结金额 }
    damt11: Double;
{= 金额11 卖出冻结金额 }
    damt12: Double;
{= 金额12 买入成交金额 }
    damt13: Double;
{= 金额13 卖出成交金额 }
    damt14: Double;
{= 金额14 手工冻结金额 }
    damt15: Double;
{= 金额15 手工解冻金额 }

    damt16: Double;
{=7 金额16 贷款金额 }
    damt17: Double;
{= 金额17 发生金额 }
    damt18: Double;
{= 金额18 买入未过户金额 }
    damt19: Double;
{= 金额19 卖出未过户金额 }
    damt20: Double;
{= 金额20 利息积数 }
    damt21: Double;
{= 金额21 罚息积数 }
    damt22: Double;
{= 金额22 贷款利息9积数 }
    damt23: Double;
{= 金额23 信用金额 }

    damt24: Double;
{=8 金额24 禁用资金 }
    damt25: Double;
{= 金额25 禁取资金 }
    damt26: Double;
{= 金额26 利息 }
    damt27: Double;
{= 金额27 罚息 }
    damt28: Double;
{= 金额28 贷款利息 }
    damt29: Double;
{= 金额29 市值 }
    damt30: Double;
{= 金额30 虚增保证金 }
    damt31: Double;
{= 金额31 手续费 }

    damt32: Double;
{=9 金额32 印花税 }
    damt33: Double;
{= 金额33 过户费 }
    sstock_code: Array[0..9-1] of Char;
{= 证券代码 }
    sstock_code2: Array[0..9-1] of Char;
{= 证券代码2 }
    scust_type: Array[0..3-1] of Char;
{= 客户类别 }
    scust_type2: Array[0..3-1] of Char;
{= 客户类别2 }
    sstat_type: Array[0..3-1] of Char;
{= 统计类别 }
    sstat_type2: Array[0..3-1] of Char;
{= 统计类别2 }

    sroom_no: Array[0..4-1] of Char;
{=10 客户组号 }
    sroom_no2: Array[0..4-1] of Char;
{= 客户组号2 }
    sopen_emp: Array[0..7-1] of Char;
{= 职工 }
    sclose_emp: Array[0..7-1] of Char;
{= 职工 }
    schange_emp: Array[0..7-1] of Char;
{= 职工 }
    scheck_emp: Array[0..7-1] of Char;
{= 复核职工 }
    semp: Array[0..7-1] of Char;
{= 职工 }
    snation_code: Array[0..4-1] of Char;
{= 国籍代码 }

    lcert_code: LongInt;
{=11 证件类别 }
    stx_pwd: Array[0..9-1] of Char;
{= 交易密码 }
    stx_pwd2: Array[0..9-1] of Char;
{= 交易密码2 }
    swithdraw_pwd: Array[0..9-1] of Char;
{= 取款密码 }
    swithdraw_pwd2: Array[0..9-1] of Char;
{= 取款密码2 }
    semp_pwd: Array[0..9-1] of Char;
{= 柜员密码 }
    semp_pwd2: Array[0..9-1] of Char;
{= 柜员密码2 }
    sbank_pwd: Array[0..9-1] of Char;
{= 银行密码 }

    sbank_pwd2: Array[0..9-1] of Char;
{=12 银行密码2 }
    scust_auth: Array[0..21-1] of Char;
{= 客户权限 }
    scust_auth2: Array[0..21-1] of Char;
{= 客户权限2 }
    scust_limit: Array[0..33-1] of Char;
{= 客户限制 }
    scust_limit2: Array[0..33-1] of Char;
{= 客户限制2 }
    lsafe_level: LongInt;
{= 安全级别 }
    lsafe_level2: LongInt;
{= 安全级别2 }
    spost_code: Array[0..7-1] of Char;
{= 邮政编码 }

    spost_code2: Array[0..7-1] of Char;
{=13 邮政编码2 }
    sphone: Array[0..31-1] of Char;
{= 联系电话 }
    sphone2: Array[0..31-1] of Char;
{= fax }
    sphone3: Array[0..31-1] of Char;
{= 移动电话 }
    spager: Array[0..31-1] of Char;
{= 传呼 }
    semail: Array[0..61-1] of Char;
{= email }
    semail2: Array[0..61-1] of Char;
{= email2 }
    snote: Array[0..81-1] of Char;
{= 备注 }

    snote2: Array[0..81-1] of Char;
{=14 备注2 }
    scert_no: Array[0..51-1] of Char;
{= 身份证号码 }
    scert_no2: Array[0..51-1] of Char;
{= 身份证号码2 }
    scert_addr: Array[0..81-1] of Char;
{= 身份证地址 }
    sstatus0: Array[0..2-1] of Char;
{= 状态，客户状态 }
    sstatus1: Array[0..2-1] of Char;
{= 状态1 }
    sstatus2: Array[0..2-1] of Char;
{= 状态2 }
    sstatus3: Array[0..2-1] of Char;
{= 状态3 }

    sstatus4: Array[0..2-1] of Char;
{=15 状态4 }
    lwithdraw_flag: LongInt;
{= 提款方式 }
    saddr: Array[0..81-1] of Char;
{= 联系地址 }
    saddr2: Array[0..81-1] of Char;
{= 联系地址2 }
    sserial0: Array[0..13-1] of Char;
{= 序号0 }
    sserial1: Array[0..13-1] of Char;
{= 序号1 }
    sserial2: Array[0..13-1] of Char;
{= 序号2 }
    sserial3: Array[0..13-1] of Char;
{= 序号3 }

    sserial4: Array[0..13-1] of Char;
{=16 序号4 }
    scurrency_type: Array[0..3-1] of Char;
{= 货币类型 }
    scurrency_type2: Array[0..3-1] of Char;
{= 货币类型2 }
    sbranch_code0: Array[0..4-1] of Char;
{= 开户营业部号码 }
    sbranch_code1: Array[0..4-1] of Char;
{= 发生营业部号码 }
    sbranch_code2: Array[0..4-1] of Char;
{= 营业部号码2 }
    usset0: Array[0..100-1] of Byte;
{= 管理权限集合 }
    usset1: Array[0..100-1] of Byte;
{= 授权权限集合 }

    usset2: Array[0..100-1] of Byte;
{=17 操作权限集合 }
    usset3: Array[0..100-1] of Byte;
{= 菜单权限集合 }
    usset4: Array[0..100-1] of Byte;
{= 岗位集合 }
    usset5: Array[0..100-1] of Byte;
{= 市场集合 }
    usset6: Array[0..100-1] of Byte;
{= 货币集合 }
    sstation0: Array[0..17-1] of Char;
{= 工作站地址 }
    sstation1: Array[0..17-1] of Char;
{= 工作站地址2 }
    sbank_acc: Array[0..41-1] of Char;
{= 银行账号 }

    sbank_acc2: Array[0..41-1] of Char;
{=18 银行账号2 }
    lbank_acc_type: LongInt;
{= 银行账号类别 }
    lbank_acc_type2: LongInt;
{= 银行账号类别2 }
    smain_flag: Array[0..2-1] of Char;
{= 主副标志 }
    smain_flag2: Array[0..2-1] of Char;
{= 主副标志 }
    sbank_code: Array[0..7-1] of Char;
{= 银行代码 }
    sbank_code2: Array[0..7-1] of Char;
{= 银行代码2 }
    semp_no: Array[0..9-1] of Char;
{= 工号 }

    semp_no2: Array[0..9-1] of Char;
{=19 工号2 }
    drate0: Double;
{= 比率 }
    drate1: Double;
{= 比率1 }
    lserial0: LongInt;
{= 序列号 0 }
    lserial1: LongInt;
{= 序列号 1 }
    sbankname: Array[0..81-1] of Char;
{= 银行名称 }
    sbankname2: Array[0..81-1] of Char;
{= 银行名称2 }
    scard0: Array[0..51-1] of Char;
{= 磁卡号码 }

    scard1: Array[0..51-1] of Char;
{=20 磁卡号码 }
    sorder0: Array[0..11-1] of Char;
{= 合同序号 }
    sorder1: Array[0..11-1] of Char;
{= 合同序号 }
    sorder2: Array[0..11-1] of Char;
{= 合同序号 }
    scusttypes: Array[0..201-1] of Char;
{= 客户类别集合 }
    ssectypes: Array[0..201-1] of Char;
{= 证券类别集合 }

    vsmess: Array[0..256-1] of Char;
{= 23 信息 }
    vsvarstr0: Array[0..256-1] of Char;
{= 变长的字符串 }
    vsvarstr1: Array[0..256-1] of Char;
{= 变长的字符串 }
    vsvarstr2: Array[0..256-1] of Char;
{= 变长的字符串 }
    vsvarstr3: Array[0..256-1] of Char;
{= 变长的字符串 }
  end {__PACKED__};
  ST_PACK = __PACKED__;


type
  st_cpack = record
    head: ST_PACKHEAD;
    pack: ST_PACK;
  end {st_cpack};

{$IFNDEF WIN32}
{$IFNDEF __GNUC__}
{ #pragma options align=reset }
{$ELSE}
{ #pragma pack(pop) }
{$ENDIF}
{$ELSE}
{ #pragma pack(pop) }
{$ENDIF}

var
  Reserve: function(buf: PByte; 
                    len: Integer) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  Reverse: function(var buf: Byte; 
                    len: Integer) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  _DecodeSingleItem: function(idx: Integer; 
                              var pPack: ST_PACK; 
                              var pSrc: PChar) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  DecodeBufHead: function(var buf: Byte; 
                          len: Integer; 
                          var pPack: ST_CPACK; 
                          eMsg: PChar): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  DecodeBuf: function(var buf: Byte; 
                      len: Integer; 
                      var pPack: ST_CPACK; 
                      eMsg: PChar): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  DecodeBufWithArray: function(var buf: Byte; 
                               len: Integer; 
                               var pPack: ST_CPACK; 
                               var packArray: ST_PACK; 
                               var recCount: Integer; 
                               eMsg: PChar): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  _EncodeSingleItem: function(idx: Integer; 
                              var pPack: ST_PACK; 
                              var pDst: PChar; 
                              var len: Integer) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  ModifyHead: function(var pHeadPack: ST_PACKHEAD; 
                       var buf: Byte): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  EncodeRow: function(var pHeadPack: ST_PACKHEAD; 
                      var pRowPack: ST_PACK; 
                      var buf: Byte; 
                      var len: Integer; 
                      eMsg: PChar): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  EncodeBuf: function(var pPack: ST_CPACK; 
                      var buf: Byte; 
                      var len: Integer; 
                      eMsg: PChar): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  EncodeBufArray: function(var pPack: ST_CPACK; 
                           var pArray: ST_PACK; 
                           var buf: Byte; 
                           var len: Integer; 
                           eMsg: PChar): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  SetParmBit: function(var ph: ST_PACKHEAD; 
                       bit: Integer): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  SetErrorPack: function(var inPack: ST_CPACK; 
                         var outPack: ST_CPACK; 
                         emsg: PChar; 
                         eCode: Integer): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  SetErrorPack2: function(var outPack: ST_CPACK; 
                          emsg: PChar; 
                          eCode: Integer): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  SetErrorPackNew: function(var inPack: ST_CPACK; 
                            var outPack: ST_CPACK; 
                            emsg: PChar; 
                            emsg2: PChar; 
                            eCode: Integer): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  SetErrorPack2New: function(var outPack: ST_CPACK; 
                             emsg: PChar; 
                             emsg2: PChar; 
                             eCode: Integer): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  SetNormalPack: function(var inPack: ST_CPACK; 
                          var outPack: ST_CPACK; 
                          nextflag: Integer; 
                          recCount: Integer): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  ShowPack: function(var pack: ST_CPACK; 
                     buf: PChar) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  ShowHex: function(var p: Byte; 
                    len: Integer; 
                    buf: PChar) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  ShowPackItem: function(idx: Integer; 
                         var pack: ST_PACK; 
                         buf: PChar) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  ShowHex: function(var p: Byte; 
                    len: Integer; 
                    buf: PChar) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  ShowPackNext: function(var pPack: ST_CPACK; 
                         var pack: ST_PACK; 
                         buf: PChar) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  GetPatitionKey: function(patitionmap: Integer; 
                           pack: ST_PACK; 
                           key: PChar) cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  ClearParmBit: function(var ph: ST_PACKHEAD; 
                         bit: Integer): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  IsInParmBits: function(head: ST_PACKHEAD; 
                         bit: Integer): CPACK_API cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{$IFDEF __cplusplus}
{$ENDIF}

{$ENDIF}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('CPACK.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @Reserve := GetProcAddress(DLLHandle,'Reserve');
  {$IFDEF WIN32}
    Assert(@Reserve <> nil);
  {$ENDIF}
    @Reverse := GetProcAddress(DLLHandle,'Reverse');
  {$IFDEF WIN32}
    Assert(@Reverse <> nil);
  {$ENDIF}
    @_DecodeSingleItem := GetProcAddress(DLLHandle,'_DecodeSingleItem');
  {$IFDEF WIN32}
    Assert(@_DecodeSingleItem <> nil);
  {$ENDIF}
    @DecodeBufHead := GetProcAddress(DLLHandle,'DecodeBufHead');
  {$IFDEF WIN32}
    Assert(@DecodeBufHead <> nil);
  {$ENDIF}
    @DecodeBuf := GetProcAddress(DLLHandle,'DecodeBuf');
  {$IFDEF WIN32}
    Assert(@DecodeBuf <> nil);
  {$ENDIF}
    @DecodeBufWithArray := GetProcAddress(DLLHandle,'DecodeBufWithArray');
  {$IFDEF WIN32}
    Assert(@DecodeBufWithArray <> nil);
  {$ENDIF}
    @_EncodeSingleItem := GetProcAddress(DLLHandle,'_EncodeSingleItem');
  {$IFDEF WIN32}
    Assert(@_EncodeSingleItem <> nil);
  {$ENDIF}
    @ModifyHead := GetProcAddress(DLLHandle,'ModifyHead');
  {$IFDEF WIN32}
    Assert(@ModifyHead <> nil);
  {$ENDIF}
    @EncodeRow := GetProcAddress(DLLHandle,'EncodeRow');
  {$IFDEF WIN32}
    Assert(@EncodeRow <> nil);
  {$ENDIF}
    @EncodeBuf := GetProcAddress(DLLHandle,'EncodeBuf');
  {$IFDEF WIN32}
    Assert(@EncodeBuf <> nil);
  {$ENDIF}
    @EncodeBufArray := GetProcAddress(DLLHandle,'EncodeBufArray');
  {$IFDEF WIN32}
    Assert(@EncodeBufArray <> nil);
  {$ENDIF}
    @SetParmBit := GetProcAddress(DLLHandle,'SetParmBit');
  {$IFDEF WIN32}
    Assert(@SetParmBit <> nil);
  {$ENDIF}
    @SetErrorPack := GetProcAddress(DLLHandle,'SetErrorPack');
  {$IFDEF WIN32}
    Assert(@SetErrorPack <> nil);
  {$ENDIF}
    @SetErrorPack2 := GetProcAddress(DLLHandle,'SetErrorPack2');
  {$IFDEF WIN32}
    Assert(@SetErrorPack2 <> nil);
  {$ENDIF}
    @SetErrorPackNew := GetProcAddress(DLLHandle,'SetErrorPackNew');
  {$IFDEF WIN32}
    Assert(@SetErrorPackNew <> nil);
  {$ENDIF}
    @SetErrorPack2New := GetProcAddress(DLLHandle,'SetErrorPack2New');
  {$IFDEF WIN32}
    Assert(@SetErrorPack2New <> nil);
  {$ENDIF}
    @SetNormalPack := GetProcAddress(DLLHandle,'SetNormalPack');
  {$IFDEF WIN32}
    Assert(@SetNormalPack <> nil);
  {$ENDIF}
    @ShowPack := GetProcAddress(DLLHandle,'ShowPack');
  {$IFDEF WIN32}
    Assert(@ShowPack <> nil);
  {$ENDIF}
    @ShowHex := GetProcAddress(DLLHandle,'ShowHex');
  {$IFDEF WIN32}
    Assert(@ShowHex <> nil);
  {$ENDIF}
    @ShowPackItem := GetProcAddress(DLLHandle,'ShowPackItem');
  {$IFDEF WIN32}
    Assert(@ShowPackItem <> nil);
  {$ENDIF}
    @ShowHex := GetProcAddress(DLLHandle,'ShowHex');
  {$IFDEF WIN32}
    Assert(@ShowHex <> nil);
  {$ENDIF}
    @ShowPackNext := GetProcAddress(DLLHandle,'ShowPackNext');
  {$IFDEF WIN32}
    Assert(@ShowPackNext <> nil);
  {$ENDIF}
    @GetPatitionKey := GetProcAddress(DLLHandle,'GetPatitionKey');
  {$IFDEF WIN32}
    Assert(@GetPatitionKey <> nil);
  {$ENDIF}
    @ClearParmBit := GetProcAddress(DLLHandle,'ClearParmBit');
  {$IFDEF WIN32}
    Assert(@ClearParmBit <> nil);
  {$ENDIF}
    @IsInParmBits := GetProcAddress(DLLHandle,'IsInParmBits');
  {$IFDEF WIN32}
    Assert(@IsInParmBits <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: CPACK.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.

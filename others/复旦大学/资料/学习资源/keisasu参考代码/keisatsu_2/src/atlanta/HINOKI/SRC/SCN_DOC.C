/*
 *	@(#)%W%
 *	FileName:	/home2/prj/Eva/Src/scn/scn_doc.c
 *	Create:	Tue Jan  6 11:15:20 1998	by	ishiyama
 *	Description:
 *		Feeder Document Class
 *	Change Log:
 *		\prj\eva\src\scn\scn_doc.cからコピーし、HINOKI用にメンテしました
 */
#include "\src\atlanta\define\product.h"
#include "\src\atlanta\define\std.h"
#include "\src\atlanta\define\mon_pro.h"
#include "\src\atlanta\define\sysdoc.h"
#include "\src\atlanta\define\mntsw_c.h"
#include "\src\atlanta\ext_v\bkupram.h"
#include "\src\atlanta\ext_v\sys_data.h"
#include "\src\atlanta\hinoki\define\scn_def.h"
#include "\src\atlanta\hinoki\define\scn_pro.h"
#include "\src\atlanta\hinoki\ext_v\scn_dath.h"
#include "\src\atlanta\hinoki\ext_v\scn_tbl.h"
#include "\src\cpu\sh7043_a\irom\define\sh_port.h"
#include "\src\atlanta\prt\iu_therm\define\prt_drv.h"
#include "\src\atlanta\prt\iu_therm\define\prt_pro.h"
#if (PRO_CLASS1 == ENABLE)
#include "\src\atlanta\ext_v\cl1_data.h" /* by H.Hirao 1999/01/26 */
#endif
#include "\src\atlanta\prt\iu_therm\ext_v\prt_data.h"
#include "\src\atlanta\prt\iu_therm\define\prt_def.h"
#include "\src\atlanta\define\mntsw_h.h"

/*
 *	Name:	Query Feeder Document Width
 *	Create:	Tue Jan  6 11:16:38 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		BYTE	QueryFeederDocSize(void);
 *	Description:
 *		Feeder の原稿幅を返す。
 *	Return Value:
 *		SYS_DOCUMENT_A4_SIZE		0	A4 Document
 *		SYS_DOCUMENT_B4_SIZE		1   B4 Document
 *		SYS_DOCUMENT_A3_SIZE		2	A3 Document //未使用
 *	Change Log:
 *		
 */
BYTE	QueryFeederDocSize(void)
{
	BYTE	Size;

	Size = SYS_DOCUMENT_A4_SIZE;
#if (PRO_SCAN_WIDTH == B4WIDTH)
	/* 最大原稿読み取り幅 */
	/* B4 センサがあれば、以下を生かす */
	if (QueryDsB4On()) {
		Size = SYS_DOCUMENT_B4_SIZE;
	}
#endif
	return	Size;
}

/*
 *	Name:	Query Current Document Size
 *	Create:	Mon Feb  23 13:56:38 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		BYTE	QueryCurrentDocSize(void);
 *	Description:
 *		Feeder の原稿幅を返す。
 *	Return Value:
 *		SYS_DOCUMENT_A4_SIZE		0	A4 Document
 *		SYS_DOCUMENT_B4_SIZE		1   B4 Document
 *		SYS_DOCUMENT_A3_SIZE		2	A3 Document //未使用
 *	Change Log:
 *		
 */
BYTE	QueryCurrentDocSize(void)
{
	return	CurrentPage->Size;
}


/*
 *	Name:	Query Current Document Resolution(Norm/Fine/Sfine)
 *	Create:	Fri Feb 13 14:44:38 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		BYTE	QueryDocMode(void);	
 *	Description:
 *		現在の原稿の送信(or COPY)モードを返す
 *	Return Value:
 *		(doc.h 参照)
 *		SYS_NORMAL
 *		SYS_FINE
 *		SYS_SFINE
 *		SYS_GRAY64
 *	Change Log:
 *		
 */
BYTE	QueryDocMode(void)
{
	BYTE	rtn;

	if (CurrentPage == NULL) {
		rtn = SYS_NORMAL;				/* for fail safe */
	} else {
		rtn = CurrentPage->Mode;
	}
	return	rtn;
}

/*
 *	Name:	Query More Document
 *	Create:	Mon Feb  2 16:56:37 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		BOOL	QueryMoreDoc(void);
 *	Description:
 *		
 *	Return Value:
 *		TRUE:	Exist Next Page
 *		FALSE:	No more Pages
 *	Change Log:
 *		
 */
BOOL	QueryMoreDoc(void)
{
	if (NextPage != NULL) {
		return	TRUE;
	} else {
		return	FALSE;
	}
}


/*
 *	Name:	Query Document Current Position
 *	Create:	Mon Feb  2 17:00:49 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		BYTE	QueryDocPosition(void);
 *	Description:
 *		Current Document の位置を返す
 *	Return Value:
 *		DOC_POS_*	(feeder.h)
 *	Change Log:
 *		
 */
BYTE	QueryDocPosition(void)
{
	if (CurrentPage == NULL) {
		return	DOC_POS_NO_DOCUMENT;
	} else {
		return	CurrentPage->Position;
	}
}

/*
 *	Name:	Query Document Scannable
 *	Create:	Mon Feb  9 16:10:31 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		BOOL	QueryDocScannable(void);
 *	Description:
 *		原稿が読取り可能な位置にあるか。
 *	Return Value:
 *		TRUE:	読取り可能
 *		FALSE：	読取り不可
 *	Change Log:
 *		
 */
BOOL	QueryDocScannable(void)
{
	BOOL	Rslt;
	BYTE	Pos;
	UBYTE	debug;
	
	Rslt = FALSE;

	Pos = QueryDocPosition();
	if (Pos == DOC_POS_SCANNING || Pos == DOC_POS_SCAN_FEEDOUT) {
		/*
		 * 次ページがすでに読取り位置にきてる場合
		 * 一旦、読取りを停止する
		 */
		if (!SCN_DocumentChanged) {
			Rslt = TRUE;
		}
	}
	return	Rslt;
}

/*
 *	Name:	Query Store Coding Mode
 *	Create:	Wed Jan  7 16:21:36 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		UBYTE	QueryStoreCode(void);
 *	Description:
 *		蓄積するコーディングモードを返す
 *	Return Value:
 *		doc.h 参照
 *		IMAGE_DATA	0	// 未使用
 *		MH_CODE		1	// 未使用
 *		MR_CODE		2
 *		MMR_CODE	3
 *	Change Log:
 *		
 */
UBYTE	QueryStoreCode(void)
{
#if (PRO_CLASS1 == ENABLE) /* by H.Hirao 1999/01/26 */
	if (QueryClass1Tx()) {
		CL1_Code = CL1_PCDocumentCode;
		return (CL1_Code);
	}
	else {
		switch (QueryStoreMode()) {
		case	SYS_NORMAL:
		case	SYS_FINE:
		case	SYS_SFINE:
		case	SYS_HFINE:
		case	SYS_EFINE:
			return((UBYTE)(SYB_MaintenanceSwitch[MNT_SW_C3] & DOC_STORE_CODING_METHOD));
			break;
		default:			/* その他(中間調) */
			return((UBYTE)((SYB_MaintenanceSwitch[MNT_SW_C3] & DOC_STORE_CODING_METHOD_GRAY)>>3));
		}
	}
#else
	switch (QueryStoreMode()) {
	case	SYS_NORMAL:
	case	SYS_FINE:
	case	SYS_SFINE:
	case	SYS_HFINE:
	case	SYS_EFINE:
		return((UBYTE)(SYB_MaintenanceSwitch[MNT_SW_C3] & DOC_STORE_CODING_METHOD));
		break;
	default:			/* その他(中間調) */
		return((UBYTE)((SYB_MaintenanceSwitch[MNT_SW_C3] & DOC_STORE_CODING_METHOD_GRAY)>>3));
	}
#endif
}



/*
 *	Name:	Query Stored Mode
 *	Create:	Wed Jan  7 16:29:24 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		BYTE	QueryStoreMode(void);
 *	Description:
 *		原稿読取りモードを返す
 *	Return Value:
 *		doc.h 参照
 *		SYS_NORMAL		0  // 普通	   200dpi:8 dot/m  100dpi:3.85本/l
 *		SYS_FINE		1  // 高画質   200dpi:8 dot/m  200dpi:7.7 本/l
 *		SYS_SFINE		2  // 超高画質 200dpi:8 dot/m  400dpi:15.5本/l
 *		SYS_GRAY64		3  // 64階調   200dpi:8 dot/m  200dpi:7.7 本/l
 *	Change Log:
 *		
 */
BYTE	QueryStoreMode(void)
{
	BYTE	Mode;

	Mode = SYB_ModeSw;
	/*
	 *	Real Time Copy は、Normalはない
	 */
	if (ScannerMode == SCANNER_COPY_MODE) {
		if (Mode == SYS_NORMAL) {
			Mode = SYS_FINE;
		}

		/* 京セラＴＰＨ不具合対応
		** ＴＰＨサーミスタ検出が一定温度以下（値Ｔ以上）の時は、ＳＦＩＮＥモードで実行する
		** ＝強制的にプリヒート（時間ｔ）を挿入する
		** Ｔ および ｔ はメモリスイッチにより可変として下さい．
		** デフォルト値は、以下の値として下さい
		** Ｔ＝４６（２Ｅｈ）　　　２０℃（判定値４６以上で２０℃以下です）
		** ｔ＝５０（３２ｈ）　　　０．５ｍｓ
		** 1999/03/15 追加 by T.Soneoka
		*/
		if (Mode == SYS_FINE) {
			if (HeadMaker == HEAD_KYOCERA) {
				ThermistorValue = AD_Thermistor();
				if (ThermistorValue >= (SYB_MaintenanceSwitch[MNT_SW_H2]*4)) {
					Mode = SYS_SFINE;
				}
			}
		}
		/** ここまで */
	}
#if (PRO_CLASS1 == ENABLE) /* by H.Hirao 1999/01/26 */
	if (QueryClass1Tx()) {
		CL1_Mode = CL1_PCDocumentMode;
		if (CL1_Mode < SYS_FINE) {
			Mode = CL1_Mode;
		}
		else if (CL1_Mode == SYS_FINE) {
			if ((Mode == SYS_GRAY64)
			 || (Mode == SYS_NORMAL)
			 || (Mode == SYS_FINE)) {
				CL1_Mode = Mode;
			}
			else {
				Mode = CL1_Mode;
			}
		}
		else {
			if ((Mode == SYS_GRAY64)
			 || (Mode == SYS_NORMAL)
			 || (Mode == SYS_FINE)) {
				CL1_Mode = Mode;
			}
			else {
				Mode = CL1_Mode;
			}
		}
	}
#endif
	return	Mode;
}


/*
 *	Name:	Query Class1 Tx
 *	Create:	Wed Feb  23 15:55:18 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		BOOL	QueryClass1Tx(void);
 *	Description:
 *		クラス1か否かを返す
 *	Return Value:
 *		TRUE:	Class 1
 *		FALSE:	Not Class 1
 *	Change Log:
 *		
 */
BOOL	QueryClass1Tx(void)
{
	/* TBD */
#if (PRO_CLASS1 == ENABLE) /* by H.Hirao 1999/01/26 */
	if (SYS_DocumentStoreItem == SYS_MEM_CLASS1_TX_FILE) {
		return TRUE;
	}
	else {
		return FALSE;
	}
#else
	return	FALSE;
#endif
}


/*
 *	Name:	Query Adjuct Document Size
 *	Create:	Wed Jan  7 16:36:18 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		BYTE	QueryAdjustDocSize(void);
 *	Description:
 *		クラス１も加味したドキュメントサイズを返す。
 *		クラス1か否か,PC 側の能力が設定済であること。
 *	Return Value:
 *		doc.h 参照
 *		SYS_DOCUMENT_A4_SIZE
 *		SYS_DOCUMENT_B4_SIZE
 *		SYS_DOCUMENT_A3_SIZE
 *	Change Log:
 *		
 */
BYTE	QueryAdjustDocSize(void)
{
	BYTE	Size;
	BYTE	FeederDocSize;

	FeederDocSize = QueryFeederDocSize();
#if (PRO_CLASS1 == ENABLE)
	if (QueryClass1Tx()) {				/* TBD */
		if (FeederDocSize == SYS_DOCUMENT_A4_SIZE
			|| PcDocumentSize == SYS_DOCUMENT_A4_SIZE) {	
			Size = SYS_DOCUMENT_A4_SIZE;
		} else if (FeederDocSize == SYS_DOCUMENT_B4_SIZE
				   || PcDocumentSize == SYS_DOCUMENT_B4_SIZE) {
			Size = SYS_DOCUMENT_B4_SIZE;
		} else {
			Size = SYS_DOCUMENT_A3_SIZE;
		}
	} else {
		Size = FeederDocSize;
	}
#else
	Size = QueryFeederDocSize();
#endif	/* PRO_CLASS1 == ENABLE */

	return	Size;
}



/*
 *	Name:	Query Stored Document Density
 *	Create:	Wed Jan  7 16:58:34 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		BYTE	QueryStoreDensity(void);	
 *	Description:
 *		蓄積原稿の濃度を返す
 *	Return Value:
 *		SYS_LIGHT_DENSITY			0	// 薄く
 *		SYS_NORMAL_DENSITY			2	// 普通
 *		SYS_DARK_DENSITY			4	// 濃く
 *	Change Log:
 *		
 */
BYTE	QueryStoreDensity(void)
{
	return	SYB_DensitySw;
}


/*
 *	Name:	Query 1/2 Scan
 *	Create:	Thu Mar 05 15:25:40 1998	by	ishiyama
 *	Synopsis:
 *		#inlucde	"feeder.h"
 *		BOOL	Query1_2Scan(void);
 *	Description:
 *		1/2 Scan or not
 *	Return Value:
 *		TURE:	1/2 Scan
 *		FALSE:	Normal Scan
 *	Change Log:
 *		
 */
BOOL	Query1_2Scan(void)
{
	if (CurrentPage == NULL) {
		return	FALSE;					/* for Fail safe */
	}

	if (CurrentPage->VerticalMode == TX_MOTOR_FINE1_2_SCAN
		|| CurrentPage->VerticalMode == TX_MOTOR_SFINE1_2_SCAN) {
		return	TRUE;
	} else {
		return	FALSE;
	}
}



BOOL	QueryDocumentChanged(void)
{
	return	SCN_DocumentChanged;
}

	
/*
 *	method
 */
/*
 *	Name:	Initialize Document Objects
 *	Create:	Fri Jan 30 16:35:20 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		void	InzDocObj(void);
 *	Description:
 *		原稿オブジェクトを初期化
 *	Return Value:
 *		void
 *	Change Log:
 *		
 */
void	InzDocObj(void)
{
	ScanPage[0].Object = FALSE;
	ScanPage[1].Object = FALSE;
	CurrentPage = NULL;
	NextPage = NULL;
}

/*
 *	Name:	Create Document Object
 *	Create:	Fri Jan 30 16:19:17 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		struct ScanPageAtr *	CreateDocObj(void);
 *	Description:
 *		Document Object を作成し,そのポインタを返す
 *	Return Value:
 *		struct ScanPageAtr *
 *	Change Log:
 *		
 */
struct ScanPageAtr *CreateDocObj(void)
{
	struct ScanPageAtr	*Page;
	BOOL	CurrentInt;

	CurrentInt = CheckInterruptEnable();	/* 現在の割り込み状態を保存 */
	CMN_DisableInterrupt();	/* 割り込み禁止 */
	Page = NULL;
	if (!ScanPage[0].Object) {
		Page = &ScanPage[0];
	} else if (!ScanPage[1].Object) {
		Page = &ScanPage[1];
	}
	if (Page != NULL) {
		Page->Object = TRUE;
		Page->Position = DOC_POS_MOVE_TO_DS2;
		Page->StepsFromDs1On = 0;
		Page->StepsFromDs2On = 0;
		Page->StepsFromDs2Off = 0;
		Page->Ds2ToScanSteps = Ds2ToScanSteps; /* default Value */
		Page->Ds2ToScanEndSteps = Ds2ToScanEndSteps; /* default Value */
	}
	if (CurrentInt) {
		CMN_EnableInterrupt();	/* 割り込み許可 */
	}

	return	Page;
}

/*
 *	Name:	Delete Document Object
 *	Create:	Fri Jan 30 16:27:44 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		void	DeleteDoc(struct ScanPageAtr **Page);
 *	Description:
 *		原稿オブジェクトを削除
 *	Return Value:
 *		void
 *	Change Log:
 *		
 */
void	DeleteDocObj(
	struct ScanPageAtr	**Page)
{
	if (*Page != NULL) {
		(*Page)->Object = FALSE;
		*Page = NULL;
	}
}


/*
 *	Name:	Save Scanning Mode
 *	Create:	Mon Jun 29 13:41:15 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		void	SaveScanningMode(UBYTE Mode)
 *	Description:
 *		読取りモードを指定する。
 *		SetScanPageAttribute() の前にコールすること。
 *	Return Value:
 *		void
 *	Change Log:
 *		
 */
void	SaveScanningMode(
	UBYTE	Mode)						/* SYS_* see doc.h */
{
	UBYTE	Work;

	/* 念のため、モードをチェックしセーブする */
	switch (Mode) {
	case SYS_NORMAL:
		Work = SYS_NORMAL;
		break;
	case SYS_FINE:
		Work = SYS_FINE;
		break;
	case SYS_SFINE:
		Work = SYS_SFINE;
		break;
	case SYS_GRAY64:
		Work = SYS_GRAY64;
		break;
	default:
		/* not reached */
		Work = SYS_FINE;				/* for fail safe */
		break;
	}
	ScannerSavedMode = Work;
}

/*
 *	Name:	Query Scanning Mode
 *	Create:	Mon Jun 29 13:52:58 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		UBYTE	QueryScanningMode(void);
 *	Description:
 *		セーブしたモードを獲る
 *	Return Value:
 *		SYS_* (see doc.h)
 *	Change Log:
 *		
 */
UBYTE	QueryScanningMode(void)
{
	return	ScannerSavedMode;
}

/*
 *	Name:	Set Scan Page Attributes
 *	Create:	Wed Jan  7 16:04:24 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		void	SetScanPageAttribute(struct ScanPageAtr *PageAtr);
 *	Description:
 *		原稿属性を設定する
 *	Return Value:
 *		void
 *	Change Log:
 *		
 */
void	SetScanPageAttribute(			/* 原稿属性設定 */
	struct ScanPageAtr *Page)			/* 原稿属性へのポインタ */
{
	Page->Code = QueryStoreCode();
	Page->Mode = QueryStoreMode();
	Page->Size = SYS_DocumentScanSize;
	Page->Density = QueryStoreDensity();

	ScanReduction = REDUCTION_NO; /* 1999/03/04 by T.Soneoka */

	if (ScannerMode == SCANNER_COPY_MODE) {
		/*
		** １ページの先頭で縮小率を取り込んでおきます
		** この後は、取り込んだ値を使用します
		** マルチコピーの後のＢ４−＞Ａ４送信不具合
		** 1999/03/04 by T.Soneoka
		*/
		if ((SYS_DocumentScanSize == SYS_DOCUMENT_B4_SIZE)
		&& (!PB4())) {
			ScanReduction = REDUCTION_B4_A4;
		}
#if (0) /* マルチコピーの後のＢ４−＞Ａ４送信不具合 1999/03/04 by T.Soneoka */
**		switch (QueryReduction()) {
#else
		switch (ScanReduction) {
#endif
		case REDUCTION_B4_A4:
			/* 
			** 1728/2048=0.84375%で設定
			** (RC+1)/256 = 縮小率より (RC+1)/256 = 0.84375 -> RC = 215
			*/
			Page->HolzReduction = 215;			/* 主走査縮小あり */
#if defined(HINOKI2) || defined(HINOKI3)	/* LC821033仕様対応 Y.Kano 2003/12/01 */
			if (SYB_LC821033_Flg) {					/* LC821033対応フラグ Y.Kano 2003/12/01 */
				Page->VertReduction = IP_SUBM_NON_LC33;	/* 副操作縮小無し */
			}
			else {	/* LC82103仕様 */
				Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
			}
#else	/* HINOKI2旧ﾊﾞｰｼﾞｮﾝ */
			Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
#endif	/* End of defined(HINOKI2) */
			break;
		case REDUCTION_NO:
		default:
			Page->HolzReduction = 255;			/* 主走査縮小無し */
#if defined(HINOKI2) || defined(HINOKI3)	/* LC821033仕様対応 Y.Kano 2003/12/01 */
			if (SYB_LC821033_Flg) {					/* LC821033対応フラグ Y.Kano 2003/12/01 */
				Page->VertReduction = IP_SUBM_NON_LC33;	/* 副操作縮小無し */
			}
			else {	/* LC82103仕様 */
				Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
			}
#else	/* HINOKI2旧ﾊﾞｰｼﾞｮﾝ */
			Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
#endif	/* End of defined(HINOKI2) */
			break;
		}
	} else {
#if (PRO_CLASS1 == ENABLE)	/* by H.Hirao 1999/01/26 */
		if (QueryClass1Tx()) {
			switch (Page->Size) {
			case SYS_DOCUMENT_B4_SIZE:
				switch (CL1_PCDocumentSize) {	/* PCの記録幅能力 */
				case SYS_DOCUMENT_A3_SIZE:
				case SYS_DOCUMENT_B4_SIZE:
					Page->HolzReduction = 255;	/* 主走査縮小無し */
					break;
				case SYS_DOCUMENT_A4_SIZE:
					ScanReduction = REDUCTION_B4_A4;	/* 1999/03/23 by H.Hirao */
					Page->HolzReduction = 215;	/* 主走査縮小あり */
					break;
				}
				Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
				break;
			case SYS_DOCUMENT_A4_SIZE:
				Page->HolzReduction = 255;			/* 主走査縮小無し */
				Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
				break;
			}
		}
		else {
			/*
			** メモリコピー、Ｂ４−＞Ａ４蓄積処理追加
			** 1999/02/17 by T.Soneoka
			*/
			if ((!CHK_UNI_ReductionPrint())
			&& (SYS_DocumentStoreItem == SYS_MEM_MULTI_COPY_FILE)) {
				/*
				** １ページの先頭で縮小率を取り込んでおきます
				** この後は、取り込んだ値を使用します
				** マルチコピーの後のＢ４−＞Ａ４送信不具合
				** 1999/03/04 by T.Soneoka
				*/
				if ((SYS_DocumentScanSize == SYS_DOCUMENT_B4_SIZE)
				&& (!PB4())) {
					ScanReduction = REDUCTION_B4_A4;
				}

#if (0) /* マルチコピーの後のＢ４−＞Ａ４送信不具合 1999/03/04 by T.Soneoka */
**				switch (QueryReduction()) {
#else
				switch (ScanReduction) {
#endif
				case REDUCTION_B4_A4:
					/* 
					** 1728/2048=0.84375%で設定
					** (RC+1)/256 = 縮小率より (RC+1)/256 = 0.84375 -> RC = 215
					*/
					Page->HolzReduction = 215;			/* 主走査縮小あり */
					Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
					break;
				case REDUCTION_NO:
				default:
					Page->HolzReduction = 255;			/* 主走査縮小無し */
					Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
					break;
				}
			} else {
				Page->HolzReduction = 255;			/* 主走査縮小無し */
				Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
			}
		}
#else
		/*
		** メモリコピー、Ｂ４−＞Ａ４蓄積処理追加
		** 1999/02/17 by T.Soneoka
		*/
		if ((!CHK_UNI_ReductionPrint())
		&& (SYS_DocumentStoreItem == SYS_MEM_MULTI_COPY_FILE)) {
			/*
			** １ページの先頭で縮小率を取り込んでおきます
			** この後は、取り込んだ値を使用します
			** マルチコピーの後のＢ４−＞Ａ４送信不具合
			** 1999/03/04 by T.Soneoka
			*/
#if defined(KEISATSU) /* B4を2枚の1枚目読み取り中に本体オープンで2枚目が縮小されてゴミが印字される件。O.Oshima 2005/12/12 */
			if ((SYS_DocumentScanSize == SYS_DOCUMENT_B4_SIZE)
			&& (!PB4())
			&& (!RXIL())) { /* (SYS_DocumentStorePage == 1) で見るとB4->A4縮小の2枚目が正しく行われない。 */
#else
			if ((SYS_DocumentScanSize == SYS_DOCUMENT_B4_SIZE)
			&& (!PB4())) {
#endif
				ScanReduction = REDUCTION_B4_A4;
			}

#if (0) /* マルチコピーの後のＢ４−＞Ａ４送信不具合 1999/03/04 by T.Soneoka */
**			switch (QueryReduction()) {
#else
			switch (ScanReduction) {
#endif
			case REDUCTION_B4_A4:
				/* 
				** 1728/2048=0.84375%で設定
				** (RC+1)/256 = 縮小率より (RC+1)/256 = 0.84375 -> RC = 215
				*/
				Page->HolzReduction = 215;			/* 主走査縮小あり */
#if defined(HINOKI2) || defined(HINOKI3)	/* LC821033仕様対応 Y.Kano 2003/12/01 */
				if (SYB_LC821033_Flg) {					/* LC821033対応フラグ Y.Kano 2003/12/01 */
					Page->VertReduction = IP_SUBM_NON_LC33;	/* 副操作縮小無し */
				}
				else {	/* LC82103仕様 */
					Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
				}
#else	/* HINOKI2旧ﾊﾞｰｼﾞｮﾝ */
				Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
#endif	/* End of defined(HINOKI2) */
				break;
			case REDUCTION_NO:
			default:
				Page->HolzReduction = 255;			/* 主走査縮小無し */
#if defined(HINOKI2) || defined(HINOKI3)	/* LC821033仕様対応 Y.Kano 2003/12/01 */
				if (SYB_LC821033_Flg) {					/* LC821033対応フラグ Y.Kano 2003/12/01 */
					Page->VertReduction = IP_SUBM_NON_LC33;	/* 副操作縮小無し */
				}
				else {	/* LC82103仕様 */
					Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
				}
#else	/* HINOPKI2旧ﾊﾞｰｼﾞｮﾝ */
				Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
#endif	/* End of defined(HINOKI2) */
				break;
			}
		} else {
			Page->HolzReduction = 255;			/* 主走査縮小無し */
#if defined(HINOKI2) || defined(HINOKI3)	/* LC821033仕様対応 Y.Kano 2003/12/01 */
			if (SYB_LC821033_Flg) {					/* LC821033対応フラグ Y.Kano 2003/12/01 */
				Page->VertReduction = IP_SUBM_NON_LC33;	/* 副操作縮小無し */
			}
			else {	/* LC82103仕様 */
				Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
			}
#else	/* HINOKI2旧ﾊﾞｰｼﾞｮﾝ */
			Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
#endif	/* End of defined(HINOKI2) */
		}
#endif
	}
#if (0) /* 1998/10/31 by T.Soneoka */
**	if (CHK_QueryScanTopAdjust() & 0x80) {
**		Page->Ds2ToScanSteps = (Ds2ToScanSteps - (CHK_QueryScanTopAdjust() & 0x7f));
**	} else {
**		Page->Ds2ToScanSteps = (Ds2ToScanSteps + (CHK_QueryScanTopAdjust() & 0x7f));
**	}
#else
#if (0) /* 1999/02/22 by T.Soneoka */
**	if ((Ds2ToScanSteps + CHK_QueryScanTopAdjust()) < 0) {
**		Page->Ds2ToScanSteps = (UWORD)Ds2ToScanSteps;
**	} else {
**		Page->Ds2ToScanSteps = (UWORD)(Ds2ToScanSteps + CHK_QueryScanTopAdjust());
**	}
#else
	if (CHK_QueryScanTopAdjust() & 0x80) {
		Page->Ds2ToScanSteps = (UWORD)(Ds2ToScanSteps + (CHK_QueryScanTopAdjust() & 0x7f));
	} else {
		if ((Ds2ToScanSteps - (CHK_QueryScanTopAdjust() & 0x7f)) < 0) {
#if (0) /* 1999/02/24 by T.Soneoka */
**			Page->Ds2ToScanSteps = (UWORD)Ds2ToScanSteps;
#else
			Page->Ds2ToScanSteps = (UWORD)0;
#endif
		} else {
			Page->Ds2ToScanSteps = (UWORD)(Ds2ToScanSteps - (CHK_QueryScanTopAdjust() & 0x7f));
		}
	}
#endif
#endif

#if (0) /* 1998/10/31 by T.Soneoka */
**	if (CHK_QueryScanEndAdjust() & 0x80) {
**		Page->Ds2ToScanEndSteps = (Ds2ToScanEndSteps - (CHK_QueryScanEndAdjust() & 0x7f));
**	} else {
**		Page->Ds2ToScanEndSteps = (Ds2ToScanEndSteps + (CHK_QueryScanEndAdjust() & 0x7f));
**	}
#else
#if (0) /* 1999/02/22 by T.Soneoka */
**	if ((Ds2ToScanEndSteps + CHK_QueryScanEndAdjust()) < 0) {
**		Page->Ds2ToScanEndSteps = (UWORD)Ds2ToScanEndSteps;
**	} else {
**		Page->Ds2ToScanEndSteps = (UWORD)(Ds2ToScanEndSteps + CHK_QueryScanEndAdjust());
**	}
#else
	if (CHK_QueryScanEndAdjust() & 0x80) {
		Page->Ds2ToScanEndSteps = (UWORD)(Ds2ToScanEndSteps + (CHK_QueryScanEndAdjust() & 0x7f));
	} else {
		if ((Ds2ToScanEndSteps - (CHK_QueryScanEndAdjust() & 0x7f)) < 0) {
#if (0) /* 1999/02/24 by T.Soneoka */
**			Page->Ds2ToScanEndSteps = (UWORD)Ds2ToScanEndSteps;
#else
			Page->Ds2ToScanEndSteps = (UWORD)0;
#endif
		} else {
			Page->Ds2ToScanEndSteps = (UWORD)(Ds2ToScanEndSteps - (CHK_QueryScanEndAdjust() & 0x7f));
		}
	}
#endif
#endif
	switch (Page->Mode) {
	case SYS_NORMAL:					/* 普通	   200dpi:8 dot/m  100dpi:3.85本/l */
		if (CHK_UNI_NormFineScan()) {
			Page->VerticalMode = TX_MOTOR_FINE1_2_SCAN;
#if defined(HINOKI2) || defined(HINOKI3)	/* LC821033仕様対応 Y.Kano 2003/12/01 */
			if (SYB_LC821033_Flg) {					/* LC821033対応フラグ Y.Kano 2003/12/01 */
				Page->VertReduction = IP_SUBM_1_2_LC33; /* 副操作1/2縮小 */
			}
			else {	/* LC82103仕様 */
				Page->VertReduction = IP_SUBM_1_2; /* 副操作1/2縮小 */
			}
#else	/* HINOKI2旧ﾊﾞｰｼﾞｮﾝ */
			Page->VertReduction = IP_SUBM_1_2; /* 副操作1/2縮小 */
#endif	/* End of defined(HINOKI2) */
		} else {
			Page->VerticalMode = TX_MOTOR_NORMAL_SCAN;
		}
		break;
	case SYS_FINE:						/* 高画質   200dpi:8 dot/m  200dpi:7.7 本/l */
	case SYS_GRAY16:					/* 16階調   200dpi:8 dot/m  200dpi:7.7 本/l */
	case SYS_GRAY32:					/* 32階調   200dpi:8 dot/m  200dpi:7.7 本/l */
	case SYS_GRAY64:					/* 64階調   200dpi:8 dot/m  200dpi:7.7 本/l */
		Page->VerticalMode = TX_MOTOR_FINE_SCAN;
		break;
	case SYS_SFINE:						/* 超高画質 200dpi:8 dot/m  400dpi:15.5本/l */
	case SYS_HFINE:						/* 超高画質 400dpi:16dot/m  400dpi:15.5本/l */
		Page->VerticalMode = TX_MOTOR_SFINE_SCAN;
		break;
	default:
		/* not reached */
		break;
	}
}


/*
 *	Name:	Set Scan Page Attributes (for scanner transmit)
 *	Create:	Wed Jan  7 16:04:24 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		void	SetScanPageAttribute2(struct ScanPageAtr *PageAtr);
 *	Description:
 *		原稿属性を設定する
 *	Return Value:
 *		void
 *	Change Log:
 *		
 */
void	SetScanPageAttribute2(			/* 原稿属性設定 */
	struct ScanPageAtr *Page)			/* 原稿属性へのポインタ */
{

	/*
	** １ページの先頭で縮小率を取り込んでおきます
	** この後は、取り込んだ値を使用します
	** マルチコピーの後のＢ４−＞Ａ４送信不具合
	** 1999/03/04 by T.Soneoka
	*/
	ScanReduction = REDUCTION_NO;

	Page->Code = QueryStoreCode();
	
	switch (SYS_DocBlock.Src.Mode) {	/**	自機の原稿モード */
	case	SYS_GRAY16:					/**	各種ハーフトーン */
	case	SYS_GRAY16_SEP:
	case	SYS_GRAY32:
	case	SYS_GRAY32_SEP:
	case	SYS_GRAY64:
	case	SYS_GRAY64_SEP:
		if (SYS_DocBlock.Dst.Mode == SYS_NORMAL) {		/**	相手機がノーマル */
			/**	読み取りモードに相手機の受信モードをセット */
			/*
			** 交信相手の能力がノーマルのマシンに、スキャナ中間調送信をおこなうと、
			** 読み取りでノーマル読みして、コーデックで１／２に縮小されるため
			** ファイン読みします by H.Hirao 1999/01/28
			*/
#if (0)
			Page->Mode = SYS_NORMAL;
#else
			Page->Mode = SYS_FINE;
#endif
		}
		else {
			/**	読み取りモードに自機の原稿モードをセット */
			Page->Mode = SYS_DocBlock.Src.Mode;
		}
		break;
	default:
/*
** Ｍ−５にスキャナＳＦＩＮＥ送信を行うと、プリントが１／２になってしまう
** 読み取りでＦＩＮＥ読みをして、コーデックで１／２縮小されるため
** 読み取りは常に自機のモードでスキャンして、コーデックで縮小処理を行うようにする
** 1999/01/28 by T.Soneoka
*/
#if (0)
**		/**	読み取りモードに相手機の原稿モードをセット */
**		Page->Mode = SYS_DocBlock.Dst.Mode;
#else
		Page->Mode = SYS_DocBlock.Src.Mode;
#endif
		break;
	}

	Page->Size = SYS_DocumentScanSize;
	Page->Density = SYB_DensitySw;
	Page->HolzReduction = 255;			/* 主走査縮小無し */
#if defined(HINOKI2) || defined(HINOKI3)	/* LC821033仕様対応 Y.Kano 2003/12/01 */
	if (SYB_LC821033_Flg) {					/* LC821033対応フラグ Y.Kano 2003/12/01 */
		Page->VertReduction = IP_SUBM_NON_LC33;	/* 副操作縮小無し */
	}
	else {	/* LC82103仕様 */
		Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
	}
#else	/* HINOKI2旧ﾊﾞｰｼﾞｮﾝ */
	Page->VertReduction = IP_SUBM_NON;	/* 副操作縮小無し */
#endif	/* End of defined(HINOKI2) */
	
#if (0) /* 1999/02/22 by T.Soneoka */
**	if ((Ds2ToScanSteps + CHK_QueryScanTopAdjust()) < 0) {
**		Page->Ds2ToScanSteps = (UWORD)Ds2ToScanSteps;
**	} else {
**		Page->Ds2ToScanSteps = (UWORD)(Ds2ToScanSteps + CHK_QueryScanTopAdjust());
**	}
#else
	if (CHK_QueryScanTopAdjust() & 0x80) {
		Page->Ds2ToScanSteps = (UWORD)(Ds2ToScanSteps + (CHK_QueryScanTopAdjust() & 0x7f));
	} else {
		if ((Ds2ToScanSteps - (CHK_QueryScanTopAdjust() & 0x7f)) < 0) {
#if (0) /* 1999/02/24 by T.Soneoka */
**			Page->Ds2ToScanSteps = (UWORD)Ds2ToScanSteps;
#else
			Page->Ds2ToScanSteps = (UWORD)0;
#endif
		} else {
			Page->Ds2ToScanSteps = (UWORD)(Ds2ToScanSteps - (CHK_QueryScanTopAdjust() & 0x7f));
		}
	}
#endif

#if (0) /* 1999/02/22 by T.Soneoka */
**	if ((Ds2ToScanEndSteps + CHK_QueryScanEndAdjust()) < 0) {
**		Page->Ds2ToScanEndSteps = (UWORD)Ds2ToScanEndSteps;
**	} else {
**		Page->Ds2ToScanEndSteps = (UWORD)(Ds2ToScanEndSteps + CHK_QueryScanEndAdjust());
**	}
#else
	if (CHK_QueryScanEndAdjust() & 0x80) {
		Page->Ds2ToScanEndSteps = (UWORD)(Ds2ToScanEndSteps + (CHK_QueryScanEndAdjust() & 0x7f));
	} else {
		if ((Ds2ToScanEndSteps - (CHK_QueryScanEndAdjust() & 0x7f)) < 0) {
#if (0) /* 1999/02/24 by T.Soneoka */
**			Page->Ds2ToScanEndSteps = (UWORD)Ds2ToScanEndSteps;
#else
			Page->Ds2ToScanEndSteps = (UWORD)0;
#endif
		} else {
			Page->Ds2ToScanEndSteps = (UWORD)(Ds2ToScanEndSteps - (CHK_QueryScanEndAdjust() & 0x7f));
		}
	}
#endif

	switch (Page->Mode) {
	case SYS_NORMAL:					/* 普通	   200dpi:8 dot/m  100dpi:3.85本/l */
		if (CHK_UNI_NormFineScan()) {
			Page->VerticalMode = TX_MOTOR_FINE1_2_SCAN;
#if defined(HINOKI2) || defined(HINOKI3)	/* LC821033仕様対応 Y.Kano 2003/12/01 */
			if (SYB_LC821033_Flg) {					/* LC821033対応フラグ Y.Kano 2003/12/01 */
				Page->VertReduction = IP_SUBM_1_2_LC33; /* 副操作1/2縮小 */
			}
			else {	/* LC82103仕様 */
				Page->VertReduction = IP_SUBM_1_2; /* 副操作1/2縮小 */
			}
#else	/* HINOKI2旧ﾊﾞｰｼﾞｮﾝ */
			Page->VertReduction = IP_SUBM_1_2; /* 副操作1/2縮小 */
#endif	/* End of defined(HINOKI2) */
		} else {
			Page->VerticalMode = TX_MOTOR_NORMAL_SCAN;
		}
		break;
	case SYS_FINE:						/* 高画質   200dpi:8 dot/m  200dpi:7.7 本/l */
	case SYS_GRAY16:					/* 16階調   200dpi:8 dot/m  200dpi:7.7 本/l */
	case SYS_GRAY32:					/* 32階調   200dpi:8 dot/m  200dpi:7.7 本/l */
	case SYS_GRAY64:					/* 64階調   200dpi:8 dot/m  200dpi:7.7 本/l */
		Page->VerticalMode = TX_MOTOR_FINE_SCAN;
		break;
	case SYS_SFINE:						/* 超高画質 200dpi:8 dot/m  400dpi:15.5本/l */
	case SYS_HFINE:						/* 超高画質 400dpi:16dot/m  400dpi:15.5本/l */
		Page->VerticalMode = TX_MOTOR_SFINE_SCAN;
		break;
	default:
		/* not reached */
		break;
	}
}


/*
 *	Name:	Update Document Postion Status
 *	Create:	Mon Feb  9 16:26:46 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		void	UpdateDocPostion(void);
 *	Description:
 *      割り込みからコールされます
 *		原稿送り量カウントアップ 原稿位置ステータス更新
 *		送信モーター動作後コールすること。
 *	Return Value:
 *		void
 *	Change Log:
 *		
 */
void	UpdateDocPosition(void)
{

	BYTE	FeederMode;

	switch (CurrentPage->Position) {
	case DOC_POS_MOVE_TO_DS2:			/* DS2 に移動中 */
		CurrentPage->StepsFromDs1On += TxMotorSpeedPtr->MoveLines;

		if (Ds2Raw()) {
			CurrentPage->Position = DOC_POS_MOVE_TO_READY;
		}
		break;
	case DOC_POS_MOVE_TO_READY:			/* 待機位置に移動中 */
		CurrentPage->StepsFromDs1On += TxMotorSpeedPtr->MoveLines;
		CurrentPage->StepsFromDs2On += TxMotorSpeedPtr->MoveLines; 

		if (CurrentPage->StepsFromDs2On > Ds2ToReadySteps) {
			CurrentPage->Position = DOC_POS_MOVE_TO_SCAN;
			if (ScannerMode == SCANNER_DOC_IN_MODE) {
				CluchOff();
			}
		}
		break;
	case DOC_POS_MOVE_TO_SCAN:			/* 読取り位置に移動中 */
		CurrentPage->StepsFromDs1On += TxMotorSpeedPtr->MoveLines;
		CurrentPage->StepsFromDs2On += TxMotorSpeedPtr->MoveLines; 

		if (CurrentPage->StepsFromDs2On > CurrentPage->Ds2ToScanSteps) {
			CurrentPage->Position = DOC_POS_SCANNING;
/*
** Ｇ３送信時にフィルが出過ぎて、受信側が回線断する不具合（Laser Faxで発生）
** この処理をしていないと、ＳＦＩＮＥで、原稿間４秒強のＦＩＬＬが出ていた
** 1999/02/25 by T.Soneoka
*/
#if (0)
**			if (Debug_MoveToScan200pps) {
**				switch (CurrentPage->VerticalMode) {
**				case TX_MOTOR_NORMAL_SCAN:
**					FeederMode = FEEDER_NORMAL_SCAN;
**					break;
**				case TX_MOTOR_FINE_SCAN:
**					FeederMode = FEEDER_FINE_SCAN;
**					break;
**				case TX_MOTOR_SFINE_SCAN:
**					FeederMode = FEEDER_SFINE_SCAN;
**					break;
**				case TX_MOTOR_FINE1_2_SCAN:
**					FeederMode = FEEDER_FINE1_2_SCAN;
**					break;
**				case TX_MOTOR_SFINE1_2_SCAN:
**					FeederMode = FEEDER_SFINE1_2_SCAN;
**					break;
**				default:
**					/* not reached */
**					break;
**				}
**				SetupTxMotor(FeederMode);
**			}
#else
			/*
			** 原稿排出のＴＸモータの送り速度が、前のコピーのモードになってしまう不具合
			** if文追加 1999/02/26 by T.Soneoka
			*/
			if ((ScannerMode == SCANNER_DOC_SCAN_MODE)
			||  (ScannerMode == SCANNER_COPY_MODE)) {
				switch (CurrentPage->VerticalMode) {
				case TX_MOTOR_NORMAL_SCAN:
					FeederMode = FEEDER_NORMAL_SCAN;
					break;
				case TX_MOTOR_FINE_SCAN:
					FeederMode = FEEDER_FINE_SCAN;
					break;
				case TX_MOTOR_SFINE_SCAN:
					FeederMode = FEEDER_SFINE_SCAN;
					break;
				case TX_MOTOR_FINE1_2_SCAN:
					FeederMode = FEEDER_FINE1_2_SCAN;
					break;
				case TX_MOTOR_SFINE1_2_SCAN:
					FeederMode = FEEDER_SFINE1_2_SCAN;
					break;
				default:
					/* not reached */
					break;
				}
				SetupTxMotor(FeederMode);
			}
#endif
		}
		break;
	case DOC_POS_SCANNING:				/* 読み取り可能 */
		CurrentPage->StepsFromDs1On += TxMotorSpeedPtr->MoveLines;
		CurrentPage->StepsFromDs2On += TxMotorSpeedPtr->MoveLines; 

		if (!QueryDs2On()) {
			CurrentPage->Position = DOC_POS_SCAN_FEEDOUT;

			/* 仕様変更
			** 読み取り中において、ＤＳ２がＯＦＦした時点でＤＳ１もＯＦＦしていれば、今読んだ原稿が
			** 最終原稿であるという風に変更
			** by O.kimoto 1999/03/08
			*/
			if (!QueryDs1On()) {
				NoNextDocument = TRUE;
			}

		}
		break;
	case DOC_POS_SCAN_FEEDOUT:			/* 読取りながら排出 */
		CurrentPage->StepsFromDs1On += TxMotorSpeedPtr->MoveLines;
		CurrentPage->StepsFromDs2On += TxMotorSpeedPtr->MoveLines; 
		CurrentPage->StepsFromDs2Off += TxMotorSpeedPtr->MoveLines;

		if (CurrentPage->StepsFromDs2Off > CurrentPage->Ds2ToScanEndSteps) {

#if (PRO_STAMP == ENABLE)
			CurrentPage->Position = DOC_POS_MOVE_TO_PUSH_STAMP;
#else
			CurrentPage->Position = DOC_POS_FEED_OUT;
#endif
		}
		UpdateNextDocPosition();		/* 次の原稿位置を更新 */
		break;
#if (PRO_STAMP == ENABLE)
	case DOC_POS_MOVE_TO_PUSH_STAMP:	/* スタンプ押下位置へ移動中 */
		CurrentPage->StepsFromDs1On += TxMotorSpeedPtr->MoveLines;
		CurrentPage->StepsFromDs2On += TxMotorSpeedPtr->MoveLines; 
		CurrentPage->StepsFromDs2Off += TxMotorSpeedPtr->MoveLines;

		if (CurrentPage->StepsFromDs2Off > Ds2ToPushStampSteps) {
			CurrentPage->Position = DOC_POS_FEED_OUT;
			/*
			** 次原稿の登録する前にモータを一旦停止します 
			** ページ間で受信側からの会話予約成立時、次の原稿まで繰り込んでしまいます
			** Added next 1 line 1999/1/11 by T.Soneoka
			*/
			SCN_DocumentChanged = TRUE;

/*
** 割り込みの中で次原稿の登録をやめ上位で行なうようにします(次原稿あり時)
** 割り込みの中で次原稿登録した場合、
** 次原稿登録したが、現在の原稿読み取り終了時に、次原稿読み取りしない場合（原稿枚数指定）、
** SCN_Close()で排出処理をコールすると、次原稿まで排出されてしまう為
** ここでしないほうがすっきりする
** 1999/02/10 by T.Soneoka
*/
#if (0)
**			/*
**			** 原稿が切り替わったときに、次原稿の登録をしないと、
**			** 現在の原稿の設定で、次原稿が動作してしまう
**			** 1999/01/30 by T.Soneoka
**			*/
**			if ((NextPage != NULL) &&
**				(ScannerMode != SCANNER_DOC_OUT_MODE)) { /* 原稿排出モードは次原稿をみません */
**				DeleteDocObj(&CurrentPage);
**				CurrentPage = NextPage;
**				NextPage = NULL;
**			}
#endif
		}
		UpdateNextDocPosition();		/* 次の原稿位置を更新 */
		break;
#endif
	case DOC_POS_FEED_OUT:				/* 排出中 */
		CurrentPage->StepsFromDs1On += TxMotorSpeedPtr->MoveLines;
		CurrentPage->StepsFromDs2On += TxMotorSpeedPtr->MoveLines; 
		CurrentPage->StepsFromDs2Off += TxMotorSpeedPtr->MoveLines; 

		if (CurrentPage->StepsFromDs2Off > Ds2ToExitSteps) {
			CurrentPage->Position = DOC_POS_NO_DOCUMENT;
		}
		UpdateNextDocPosition();		/* 次の原稿位置を更新 */

/*
** 次原稿の登録する前にモータを一旦停止します 
** ページ間で受信側からの会話予約成立時、次の原稿まで繰り込んでしまいます
** 上記DOC_POS_MOVE_TO_PUSH_STAMPフェーズにて行います
** Deleted Next 1 line 1999/1/11 by T.Soneoka
*/
#if (0) 
**		/* 1998/11/10 排出フェーズで一旦モータを停止させるように変更 by T.Soneoka */
**		SCN_DocumentChanged = TRUE;
#endif



/*
** 割り込みの中で次原稿の登録をやめ上位で行なうようにします(次原稿あり時)
** 割り込みの中で次原稿登録した場合、
** 次原稿登録したが、現在の原稿読み取り終了時に、次原稿読み取りしない場合（原稿枚数指定）、
** SCN_Close()で排出処理をコールすると、次原稿まで排出されてしまう為
** ここでしないほうがすっきりする
** 1999/02/10 by T.Soneoka
*/
#if (0)
**/*
**** ここで次原稿を登録すると遅い、
**** 上記フェーズDOC_POS_MOVE_TO_PUSH_STAMPのSCN_DocumentChanged = TRUEで下記処理を行わないます
**** 1999/01/30 by T.Soneoka
***/
**		/* 次の原稿を現在の原稿とする */
**#if (0) /* 1998/11/18 by T.Soneoka */
****		if (NextPage != NULL) {
**#else
**		if ((NextPage != NULL) &&
**			(ScannerMode != SCANNER_DOC_OUT_MODE)) { /* 原稿排出モードは次原稿をみません */
**#endif
**			DeleteDocObj(&CurrentPage);
**			CurrentPage = NextPage;
**			NextPage = NULL;
**#if (0) /* 1998/12/21 by T.Soneoka */
****			CluchOn();
**#endif
**		}
#endif


		break;
	case DOC_POS_NO_DOCUMENT:			/* 原稿無し */
	default:
		/* not Reached */
		break;
	}

	/* クラッチＯＦＦ制御 */
#if (0) /* 1998/12/21 by T.Soneoka */
**	if ((CurrentPage->StepsFromDs1On >= CluchOffCounter) && (CluchSetting())) {
**		CluchOff();
**	}
#else
	if (!((CurrentPage->Position == DOC_POS_MOVE_TO_DS2) || (CurrentPage->Position == DOC_POS_MOVE_TO_READY))) {
		if ((CurrentPage->StepsFromDs2On >= CluchOffCounter) && (CluchSetting())) {
			CluchOff();
		}
	}
#endif
}

/*
 *	Name:	Update Next Document Postion Status
 *	Create:	Wed Feb 18 16:41:34 1998	by	ishiyama
 *	Synopsis:
 *		#include	"feeder.h"
 *		void	UpdateNextDocPostion(void);
 *	Description:
 *      割り込みからコールされます
 *		次の原稿のオブジェクト作成
 *		送り量カウントアップ 原稿位置ステータス更新
 *	Return Value:
 *		void
 *	Change Log:
 *		
 */
void	UpdateNextDocPosition(void)
{
	if (QueryDs1On()) {
		/* 次の原稿があるとき */
		if (NextPage == NULL) {
			NextPage = CreateDocObj();
		} else {
			switch (NextPage->Position) {
			case DOC_POS_MOVE_TO_DS2:
				NextPage->StepsFromDs1On += TxMotorSpeedPtr->MoveLines;
				if (QueryDs2On()) {
					NextPage->Position = DOC_POS_MOVE_TO_READY;
				}
				break;
			case DOC_POS_MOVE_TO_READY:			/* 待機位置に移動中 */
				NextPage->StepsFromDs1On += TxMotorSpeedPtr->MoveLines;
				NextPage->StepsFromDs2On += TxMotorSpeedPtr->MoveLines; 
				if (NextPage->StepsFromDs2On > Ds2ToReadySteps) {
					NextPage->Position = DOC_POS_MOVE_TO_SCAN;
				}
				break;
			case DOC_POS_MOVE_TO_SCAN:			/* 読取り位置に移動中 */
				NextPage->StepsFromDs1On += TxMotorSpeedPtr->MoveLines;
				NextPage->StepsFromDs2On += TxMotorSpeedPtr->MoveLines; 
				if (NextPage->StepsFromDs2On > NextPage->Ds2ToScanSteps) {
					NextPage->Position = DOC_POS_SCANNING;
				}
				break;
			default:
				/* not reached */
				break;
			}
		}
	} else {
		/* 次の原稿を引抜いた場合 */
		if (NextPage != NULL) {
			DeleteDocObj(&NextPage);
		}
	}
}

/*
 *	Name:	Wait Document Changed
 *	Create:	 1998/09/01 by T.Soneoka
 *	Synopsis:
 *		void	WaitDocChanged(void);
 *	Description:
 *		原稿が切り替わるまで待ち合わせします
 *	Return Value:
 *		void
 *	Change Log:
 *		
 */
void	WaitDocChanged(void)
{
	while (!QueryDocumentChanged()) {
		wai_tsk(1);
	}
	SCN_DocumentChanged = FALSE;
}


#if (0) /* 未使用 1998/12/21 by T.Soneoka */
**void	WaitNextDoc(void)
**{
**	/* スキャン原稿間でストップされた時の対策です 1998/09/11 by T.Soneoka */
**	if (QueryDs1On()
**	&& (CurrentPage != NULL)
**	&& (CurrentPage->Position < DOC_POS_MOVE_TO_SCAN)) {
**		CluchOn();
**		StartTxMotor();
**		while (CurrentPage->Position < DOC_POS_MOVE_TO_SCAN) {
**			wai_tsk(1);
**		}
**	}
**}
#endif


UBYTE QueryReduction(void)
{
/*
** メモリコピー、Ｂ４−＞Ａ４蓄積処理追加
** 1999/02/17 by T.Soneoka
*/
#if (0)
**	if (ScannerMode == SCANNER_COPY_MODE) {
**		if ((SYS_DocumentScanSize == SYS_DOCUMENT_B4_SIZE)
**		&& (!PB4())) {
**			return (REDUCTION_B4_A4);
**		}
**	}
**	return (REDUCTION_NO);
#else
#if (0)
**	if (ScannerMode == SCANNER_COPY_MODE) {
**		if ((SYS_DocumentScanSize == SYS_DOCUMENT_B4_SIZE)
**		&& (!PB4())) {
**			return (REDUCTION_B4_A4);
**		}
**	} else {
**		if ((!CHK_UNI_ReductionPrint())
**		&& (SYS_DocumentStoreItem == SYS_MEM_MULTI_COPY_FILE)) {
**			if ((SYS_DocumentScanSize == SYS_DOCUMENT_B4_SIZE)
**			&& (!PB4())) {
**				return (REDUCTION_B4_A4);
**			}
**		}
**	}
**	return (REDUCTION_NO);
#else
	/*
	** マルチコピーの後のＢ４−＞Ａ４送信不具合
	** 1999/03/04 by T.Soneoka
	*/
	return (ScanReduction);
#endif
#endif
}

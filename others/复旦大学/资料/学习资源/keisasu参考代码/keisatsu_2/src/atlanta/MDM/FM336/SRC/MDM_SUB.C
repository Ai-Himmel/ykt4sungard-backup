/*---------------------------------------------------------------------------------------*/
/*  プロジェクト : POPLAR_F                                                              */
/*  ファイル名   : mdm_sub.c                                                             */
/*  作成者       :                                                                       */
/*  日  付       : 1999/10/06                                                            */
/*  概  要       : モデムセットアップ処理                                                */
/*  修正履歴     :                                                                       */
/*	keyword			:[MDM]                                                               */
/*	machine			:[SH7043,V53]                                                        */
/*	language		:[MS-C(Ver.6.0)]                                                     */
/*---------------------------------------------------------------------------------------*/
/********
** define
********/
#include "\src\atlanta\define\product.h"
#include "\src\atlanta\mdm\fm336\define\mdm_def.h"
#include "\src\atlanta\define\std.h"
#include "\src\atlanta\define\fcm_def.h"
#include "\src\atlanta\define\sysdoc.h"
#include "\src\atlanta\define\dma_def.h"
#include "\src\atlanta\sh7043\define\def_evtn.h" /* added by H.Kubo 1998/01/29 */

#include "\src\atlanta\mdm\fm336\define\mdm_pro.h"
#include "\src\atlanta\define\mon_pro.h"
#include "\src\atlanta\define\cmn_pro.h"		/* 1996/12/10 Y.M */
#include "\src\atlanta\define\dma_pro.h"
#include "\src\atlanta\define\scn_pro.h"		/* 追加 S.Fukui Jun.1,1999 */

/*******
** ext_v
*******/
#include "\src\atlanta\mdm\fm336\ext_v\mdm_data.h"
#include "\src\atlanta\mdm\fm336\ext_v\mdm_tbl.h"
#include "\src\atlanta\sh7043\ext_v\extv_sem.h"
#include "\src\atlanta\ext_v\fcm_data.h"
#include "\src\atlanta\ext_v\sys_data.h"
#include "\src\atlanta\ext_v\scn_data.h" /* Added by H.Kubo 1997/0708 */
#include "\src\atlanta\ext_v\cdc_data.h"
#include "\src\atlanta\ext_v\dma_data.h" /* added by H.Kubo 1998/01/29 */

/*************************************************************************
	module		:[モデムワーク領域初期化]
	function	:[
	]
	return		:[]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/02/17]
	author		:[曽根岡拓]
*************************************************************************/
void 	InitializeModemWork(void)
{
	SetClear((UBYTE *)&ModemControl, sizeof(struct mdmcntl_t), 0x00);		/**	モデムコントロールエリア初期化	*/
	SetClear((UBYTE *)MDM_RxSize, (sizeof(UWORD) * MODEM_BUFFER_MAX), 0x00);
	ModemWaitStatus = 0;
}


/*************************************************************************
	module		:[モデムバッファ資源獲得]
	function	:[
		1.指定されたモデムバッファの資源（０〜７）を獲得します。
	]
	return		:[]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/02/17]
	author		:[曽根岡拓]
*************************************************************************/
void			ModemBufferWaiSem(UBYTE	buf_num)
{
	wai_sem(semno.ModemBuffer[buf_num]);
}


/*************************************************************************
	module		:[モデムバッファ資源解放]
	function	:[
		1.指定されたモデムバッファの資源（０〜７）を解放します。
	]
	return		:[]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/02/17]
	author		:[曽根岡拓]
*************************************************************************/
void			ModemBufferSigSem(UBYTE	buf_num)
{
/* 原因はわかっていませんが、ＰＯＰＬＡＲ＿ＢでもSIG_SEMでリセットに飛ぶという不具合でており、
** この対策が施されていますのでＰＯＰＬＡＲ＿Ｈでもいれます
** 1998/03/27 by T.Soneoka */
	if (chk_semvl(semno.ModemBuffer[buf_num]) == 0) {
		sig_sem(semno.ModemBuffer[buf_num]);
	}
}

/*************************************************************************
	module		:[モデムバッファセマフォ設定]
	function	:[
		1.指定されたモデムバッファ資源（０〜７）をセマフォ設定します。
	]
	return		:[]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[V53]
	language	:[MS-C(Ver.6.0)]
	keyword		:[MDM]
	date		:[1994/02/17]
	author		:[曽根岡拓]
*************************************************************************/
void	CreateModemBufferSem(void)
{
	UBYTE	i;

	for (i=0; i<MODEM_BUFFER_MAX; i++) {
		cre_sem(&semno.ModemBuffer[i]);
	}
}

/*************************************************************************
	module		:[モデムバッファリセット]
	function	:[
		1.指定されたモデムバッファ資源（０〜７）を獲得し、開放します
	]
	return		:[]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/02/17]
	author		:[曽根岡拓]
*************************************************************************/
void			ResetModemBufferSem(void)
{
	UBYTE	i;

	for (i=0; i<MODEM_BUFFER_MAX; i++) {
		chk_sem(semno.ModemBuffer[i]);
		sig_sem(semno.ModemBuffer[i]);
	}
}

/*************************************************************************
	module		:[]
	function	:[
		1.ソースデータ数から指定データ数を取れるか
		2.指定データを獲得できた時は、指定データ数を戻り値として設定
		3.獲得できなかった時は、ソースデータ数を戻り値として設定
	]
	return		:[]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1993/12/08]
	author		:[曽根岡拓]
*************************************************************************/
UWORD 	GetCount(UDWORD src_cnt,UWORD cnt)
{
	if (src_cnt >= (UDWORD)cnt) {
		return (cnt);
	}
	else {
		return ((UWORD)src_cnt);
	}
}


/*************************************************************************
	module		:[クリア]
	function	:[
		1.ターゲットエリアをクリアします
	]
	return		:[]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1993/12/08]
	author		:[曽根岡拓]
*************************************************************************/
void SetClear(register UBYTE *buf,UWORD	cnt,UBYTE set_num)
{
	while (cnt--) {
		*buf++ = set_num;
	}
}


/*************************************************************************
	module		:[送出バイト数設定]
	function	:[
		1.　送信速度に応じて、送出バイト数を設定する
	]
	return		:[]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1993/12/08]
	author		:[曽根岡拓]
*************************************************************************/
UWORD 	SetTransmitCount(
UWORD time)		/**	送出時間(単位ｍｓ）	*/
{
	UWORD	cnt;
	/*--------------------------------------------------------------*/
	/* 送出ﾊﾞｲﾄ数　１.5秒間											*/
	/* rate: 2400bps, 4800bps, 7200bps, 9600bps, 12000bps, 14400bps */
	/* byte:     450,     900,    1350,    1800,     2250,     2700 */
	/*--------------------------------------------------------------*/
	/* 2400bps = 2400/8(byte/s) = 300(byte/s) */
	/*----------------------------------------*/

	cnt = ( 3*time )/10;

	switch ( ModemBlock.Speed ) {
	case SPEED_33600:
		cnt = cnt*14;
		break;
	case SPEED_31200:
		cnt = cnt*13;
		break;
	case SPEED_28800:
		cnt = cnt*12;
		break;
	case SPEED_26400:
		cnt = cnt*11;
		break;
	case SPEED_24000:
		cnt = cnt*10;
		break;
	case SPEED_21600:
		cnt = cnt*9;
		break;
	case SPEED_19200:
		cnt = cnt*8;
		break;
	case SPEED_16800:
		cnt = cnt*7;
		break;
	case SPEED_14400:
		cnt = cnt*6;
		break;
	case SPEED_12000:
		cnt = cnt*5;
		break;
	case SPEED_9600:
		cnt = cnt*4;
		break;
	case SPEED_7200:
		cnt = cnt*3;
		break;
	case SPEED_4800:
		cnt = cnt*2;
		break;
	case SPEED_2400:
		break;
	case SPEED_300:
		cnt = cnt/8;	/*	小数点以下切り捨て	*/
		break;
	}

	if ( ModemBlock.Mode == MODE_RX_TCF ) {
		switch ( ModemBlock.Speed ) {
		case SPEED_14400:
			if ( cnt < MDM_TCF_MIN_14400BPS ) {
				cnt = MDM_TCF_MIN_14400BPS;
			}
			else if ( cnt > MDM_TCF_MAX_14400BPS ) {
				cnt = MDM_TCF_MAX_14400BPS;
			}
			break;
		case SPEED_12000:
			if ( cnt < MDM_TCF_MIN_12000BPS ) {
				cnt = MDM_TCF_MIN_12000BPS;
			}
			else if ( cnt > MDM_TCF_MAX_12000BPS ) {
				cnt = MDM_TCF_MAX_12000BPS;
			}
			break;
		case SPEED_9600:
			if ( cnt < MDM_TCF_MIN_9600BPS ) {
				cnt = MDM_TCF_MIN_9600BPS;
			}
			else if ( cnt > MDM_TCF_MAX_9600BPS ) {
				cnt = MDM_TCF_MAX_9600BPS;
			}
			break;
		case SPEED_7200:
			if ( cnt < MDM_TCF_MIN_7200BPS ) {
				cnt = MDM_TCF_MIN_7200BPS;
			}
			else if ( cnt > MDM_TCF_MAX_7200BPS ) {
				cnt = MDM_TCF_MAX_7200BPS;
			}
			break;
		case SPEED_4800:
			if ( cnt < MDM_TCF_MIN_4800BPS ) {
				cnt = MDM_TCF_MIN_4800BPS;
			}
			else if ( cnt > MDM_TCF_MAX_4800BPS ) {
				cnt = MDM_TCF_MAX_4800BPS;
			}
			break;
		case SPEED_2400:
			if ( cnt < MDM_TCF_MIN_2400BPS ) {
				cnt = MDM_TCF_MIN_2400BPS;
			}
			else if ( cnt > MDM_TCF_MAX_2400BPS ) {
				cnt = MDM_TCF_MAX_2400BPS;
			}
			break;
		default:
			break;
		}
	}
	return ( cnt );
}


/*************************************************************************
	module		:[モデムバッファ書き込み位置更新処理]
	function	:[
		1.
	]
	return		:[]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/01/26]
	author		:[曽根岡拓]
*************************************************************************/
void NextMdmBufWritePointSetExtRom(void)
{
	UBYTE debug;	/* debug */

	ModemControl.WritePoint++;									/**	モデムバッファ書き込み位置更新	*/
	if (ModemControl.WritePoint == MODEM_BUFFER_MAX) {			/**	モデムバッファ書き込み位置がＦＵＬＬ時	*/
#if (PRO_CLASS1 == ENABLE) /* added by H.Kubo 1998/03/04 */
		ModemControl.WritePoint = MDM_ModemBufferFirstPoint;
#else
		ModemControl.WritePoint = 0;							/**	モデムバッファ書き込み位置を先頭に設定	*/
#endif
	}

/* debug 1997/03/22 Y.M */
	if (ModemControl.WritePoint == ModemControl.ReadPoint) {
		debug++;
	}
}


/*************************************************************************
	module		:[モデムバッファ読み出し位置更新処理]
	function	:[
		1.
	]
	return		:[]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/01/26]
	author		:[曽根岡拓]
*************************************************************************/
void NextMdmBufReadPointSetExtRom(void)
{
	ModemControl.ReadPoint++;									/**	モデムバッファ読み出し位置更新	*/
	if (ModemControl.ReadPoint == MODEM_BUFFER_MAX) {			/**	モデムバッファ読み出し位置がＦＵＬＬ時	*/
#if (PRO_CLASS1 == ENABLE) /* added by H.Kubo 1998/03/04 */
		ModemControl.ReadPoint = MDM_ModemBufferFirstPoint;
#else
		ModemControl.ReadPoint = 0;								/**	モデムバッファ読み出し位置を先頭に設定	*/
#endif
	}
}


/*************************************************************************
	module		:[プログラム転送ルーチン]
	function	:[
		1.転送元のアドレスと転送先のアドレス及び転送バイト数を入力
		2.転送バイト数分、各アドレスをインクリメントしながら、コピーする
	]
	return		:[なし]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/01/13]
	author		:[曽根岡拓]
*************************************************************************/
void MemoryMove(
register UBYTE	*tgt_adr,
register UBYTE	*src_adr,
UWORD	cnt)
{
	while (cnt--) {
		*tgt_adr++ = *src_adr++;
	}
}

/*
** この関数は使用されていないので、削除します。使用することがあれば復活してください
** フラッシュプログラム搭載において、プログラム領域節約のため
** 1998/04/10
*/
#if (0)
///*************************************************************************
//	module		:[プログラム転送ルーチンバイトスワップ]
//	function	:[
//		1.転送元のアドレスと転送先のアドレス及び転送バイト数を入力
//		2.転送バイト数分、各アドレスをインクリメントし、バイトで交換しながらコピーする
//	]
//	return		:[なし]
//	common		:[]
//	condition	:[]
//	comment		:[]
//	date		:[1997/03/07]
//	author		:[曽根岡拓]
//*************************************************************************/
//void MemoryMoveSwap(
//register UBYTE	*tgt_adr,
//register UBYTE	*src_adr,
//WORD	cnt)
//{
//	while (cnt > 0) {
//		*tgt_adr = *(src_adr+1);
//		*(tgt_adr+1) = *src_adr;
//		tgt_adr += 2;
//		src_adr += 2;
//		cnt -= 2;
//	}
//}
#endif
/*************************************************************************
	module		:[ＥＣＭフレームステータスチェック]
	function	:[
		1.フレーム番号０〜２５５まで入力
		2.該当配列の該当ビットが有効かどうかを見る（有効：０，無効：１）
	]
	return		:[
		0:	ＥＣＭステータス有効（再送不必要）
		1:	ＥＣＭステータス無効（再送必要）
	]
	common		:[]
	condition	:[]
	comment		:[
		入力は０〜２５５まで
	]
	date		:[1994/01/13]
	author		:[曽根岡拓]
*************************************************************************/
UBYTE	CheckEcmStatusExtRom(UWORD	frm_num)	/*	フレーム番号（０〜２５５）	*/
{
	UBYTE	quo;		/**	フレーム番号０〜３１	*/
	UBYTE	rem;		/**	該当シフト数	*/
	UBYTE	chk_bit;	/**	該当ビット	*/

	quo = 0;
	rem = 0;

	if (frm_num != 0) {
		quo = (UBYTE)(frm_num/8);			/**	フレーム番号設定	*/
		rem = (UBYTE)(frm_num%8);			/**	シフト数設定	*/
	}
	chk_bit = (UBYTE)(1<<rem);				/**	該当ビット設定	*/

	if (MDM_EcmStatus[quo] & chk_bit) {		/**	ＥＣＭフレームステータスチェック	*/
		return (1);
	}
	else {
		return (0);
	}
}


/*************************************************************************
	module		:[ＥＣＭフレームステータス有効セットルーチン]
	function	:[
		1.該当フレーム番号を入力０〜２５５
	]
	return		:[なし]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/01/14]
	author		:[曽根岡拓]
*************************************************************************/
void 	EnableEcmStatus(UBYTE	num)
{
	MDM_EcmStatus[((UBYTE)(num)>>3)] &= ~(0x01 << ((num) & 0x07));
}

/*************************************************************************
	module		:[ＨＤＬＣ受信フレームサイズ獲得]
	function	:[
		1.
	]
	return		:[
		なし
	]
	common		:[]
	condition	:[割り込みからのコールに使用します]
	comment		:[
		ＦＳＫ受信時
		｜アドレス｜コントロール｜ＦＣＦ｜ＦＩＦ・・・｜ＦＣＳ｜ＦＣＳ｜
		｜＜−−−−−−−−−−−−−−−−−−−−＞｜
		ＥＣＭ受信時
		｜アドレス｜コントロール｜ＦＣＦ（ＦＣＤ／ＲＣＰ）｜ＦＩＦ（フレームナンバー／データ）｜ＦＣＳ｜ＦＣＳ｜
		｜＜−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−＞｜
	]
	date		:[1994/01/26]
	author		:[曽根岡拓]
*************************************************************************/
void GetRxSize(UBYTE	pnt)
{
	UWORD	cnt;		/**	ＤＭＡ転送回数	*/

	cnt = DMA_CheckDMA_Counter(DMA_CH_RX); /* Modified by H. Kubo for POPLAR_H	1997/06/17 */
	/*------------------*/
	/**	ＦＳＫ受信時	*/
	/*------------------*/
	if (ModemBlock.Mode == MODE_RX_FSK) {
		cnt = RX_FSK_HDLC_LENGTH - cnt;

		/*
		** R288F VERSION 24P以降の場合
		** added by H.Kubo 1998/10/07
		** Changed by H.Kubo 1998/10/07
		*/
		if (MDM_ModemBuffer[ModemControl.WritePoint][cnt-1] != 0x7E) { /* 受信データの最後がフラグでなかったら、*/
			if (cnt >= 2) {
				cnt-=2; /* ＦＣＳ分2バイト引く。 */
			}
		}
		else {
			if (cnt >= 3) {
				cnt -= 3;	/**	フラグとＦＣＳ分3バイト引く	*/
			}
		}

	}
	/*------------------*/
	/**	ＥＣＭ受信時	*/
	/*------------------*/
	else if (ModemBlock.Mode == MODE_RX_ECM) {	/**	ＥＣＭ受信の時	*/
		cnt = (FcomEcmSize + MODEM_FRAMING_CODE_LENGTH + 1) - cnt;
	}
	MDM_RxSize[ModemControl.WritePoint] = cnt;
}


/*************************************************************************
	module		:[受信モデムバッファＨＤＬＣ補正]
	function	:[
		1.
	]
	return		:[
		OK:	モデムバッファ再セットＯＫ
		NG:	アドレスフィールドなし
	]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/01/13]
	author		:[曽根岡拓]
*************************************************************************/
UBYTE 	ModemBufferFormatControl(UBYTE point)
{
	UWORD	i;
	UBYTE	rtn;

	rtn = OK;
	for (i = 0;	i < MODEM_BUFFER_LENGTH; i++) {
		if ((MDM_ModemBuffer[point][i] == 0xff) &&
		    (MDM_ModemBuffer[point][i+1] == 0x13 || MDM_ModemBuffer[point][i+1] == 0x03)) {
			break;
		}
	}
	if (i >= MODEM_BUFFER_LENGTH) {
		MDM_RxSize[point] = 0;
		return (NG);
	}
	if (i > 0) {
		if (((MDM_RxSize[point]-i) <= (FcomEcmSize+MODEM_FRAMING_CODE_LENGTH+1)) &&	/**  By O.K Jan.23,1996 **/
	 		((MDM_RxSize[point]-i) > 0)) {
			MemoryMove(&MDM_ModemBuffer[point][0],
				&MDM_ModemBuffer[point][i],
					(MDM_RxSize[point]-i));
			MDM_RxSize[point]-=i;
		}
	}
	return (OK);
}


/*
** この関数は使用されていないので、削除します。使用することがあれば復活してください
** フラッシュプログラム搭載において、プログラム領域節約のため
** 1998/04/10
*/
#if (0)
///*************************************************************************
//	module		:[最小伝送時間設定]
//	function	:[
//		1.
//	]
//	return		:[]
//	common		:[]
//	condition	:[]
//	comment		:[]
//	date		:[1994/02/14]
//	author		:[曽根岡拓]
//*************************************************************************/
//UBYTE		SetMinimumScanningTime(
//UBYTE time_num)
//{
//	UBYTE	rtn;
//
//	switch (time_num) {
//	case SCAN_MINIMUM_TIME20   :
//	case SCAN_MINIMUM_TIME20_2 :
//		rtn = 20;
//		break;
//	case SCAN_MINIMUM_TIME40   :
//	case SCAN_MINIMUM_TIME40_2 :
//		rtn = 40;
//		break;
//	case SCAN_MINIMUM_TIME10   :
//	case SCAN_MINIMUM_TIME10_2 :
//		rtn = 10;
//		break;
//	case SCAN_MINIMUM_TIME5    :
//		rtn = 5;
//		break;
//	case SCAN_MINIMUM_TIME0    :
//	default:
//		rtn = 0;
//		break;
//	}
//	return (rtn);
//}
#endif

/*************************************************************************
	module		:[送信画データ縮小変換率設定]
	function	:[
		1.蓄積原稿サイズ／モードと送信原稿サイズ／モード／インチミリ系を
		　判断し、ＭＮ８６０６３の縮小率パラメータ（任意縮小・細線保持モード）を決定する。
	]
	return		:[なし]
	common		:[
		SYS_DocBlock.Src.Mode
		SYS_DocBlock.Src.Size
		SYS_DocBlock.Dst.Mode
		SYS_DocBlock.Dst.Size
		SYS_DocBlock.ModeMethod
		Pix_H_Reduction
		Pix_V_Reduction
		TxReductionInchA4_DocTable[][]
		TxReductionMetricA4_DocTable[][]
		TxReductionInchB4_DocTable[][]
		TxReductionMetricB4_DocTable[][]
		TxReductionInchA3_DocTable[][]
		TxReductionMetricA3_DocTable[][]
	]
	condition	:[]
	comment		:[
		設定値は、モデムの送信画データ縮小率変換の設計仕様書を参照してください
	]
	machine		:[V53]
	language	:[MS-C(Ver.6.0)]
	keyword		:[MDM]
	date		:[1994/03/11]
	author		:[曽根岡拓]
*************************************************************************/
#define	TX_NORM_POSI		0
#define	TX_FINE_POSI		2
#define TX_SFINE_POSI		4
#define	TX_HFINE_POSI		6
#define TX_UFINE_INCH_POSI	8 /* 600dpi×600dpi対応 1999/05/26 by K.Okada */

/******************************************
** 600dpi×600dpi対応 1999/05/26 by K.Okada
******************************************/
#define MEM_A4_POSI			0
#define	MEM_B4_POSI			5
#define MEM_A3_POSI			10

#define	MEM_NORM_POSI		0
#define	MEM_FINE_POSI		1
#define	MEM_SFINE_POSI		2
#define	MEM_HFINE_POSI		3
#define MEM_UFINE_INCH_POSI	4 /* 600dpi×600dpi対応 1999/05/26 by K.Okada */

UBYTE	TxPixReductionSet(
UBYTE	src_size,
UBYTE	src_mode,
UBYTE	dst_size,
UBYTE	dst_mode,
UBYTE	mode_method)
{

	UWORD	table_locate_x;
	UWORD	table_locate_y;

	Pix_H_Reduction = 0;
	Pix_V_Reduction = 0;

	/*----------------------------------*/
	/*	縮小率選択テーブルＸ軸設定処理	*/
	/*----------------------------------*/
	switch (dst_mode) {		/**	送信原稿モード	*/
	case	SYS_NORMAL:	/**	送信原稿モードがＮｏｒｍの時	*/
		table_locate_x = TX_NORM_POSI;
		break;
	case	SYS_FINE:	/**	送信原稿モードがＦｉｎｅの時	*/
	case	SYS_GRAY16:
	case	SYS_GRAY16_SEP:
	case	SYS_GRAY32:
	case	SYS_GRAY32_SEP:
	case	SYS_GRAY64:
	case	SYS_GRAY64_SEP:
	case	SYS_GRAY128:
	case	SYS_GRAY128_SEP:
		table_locate_x = TX_FINE_POSI;
		break;
	case	SYS_SFINE:	/**	送信原稿モードがＳｆｉｎｅの時	*/
		table_locate_x = TX_SFINE_POSI;
		break;
	case	SYS_HFINE:	/**	送信原稿モードがＨｆｉｎｅの時	*/
		table_locate_x = TX_HFINE_POSI;
		break;
	case	SYS_UFINE: /* 600dpi×600dpi対応 1999/05/26 by K.Okada */
		table_locate_x = TX_UFINE_INCH_POSI;
		break;
	}
	/*----------------------------------*/
	/*	縮小率選択テーブルＹ軸設定処理	*/
	/*----------------------------------*/
	switch (src_size) {		/**	蓄積原稿サイズ	*/
	case	SYS_DOCUMENT_A4_SIZE:	/**	蓄積原稿サイズがＡ４の時	*/
		/** スキャナの解像度毎に定義し直した 1997/10/28 By T.Yamaguchi */
		EncInpStatus = INPUT_A4_SIZE;
		table_locate_y = MEM_A4_POSI;
		break;
	case	SYS_DOCUMENT_B4_SIZE:	/**	蓄積原稿サイズがＢ４の時	*/
		EncInpStatus = INPUT_B4_SIZE;
		table_locate_y = MEM_B4_POSI;
		break;
	case	SYS_DOCUMENT_A3_SIZE:	/**	蓄積原稿サイズがＡ３の時	*/
		EncInpStatus = INPUT_A3_SIZE;
		table_locate_y = MEM_A3_POSI;
		break;
	}

	switch (src_mode) {
	case	SYS_NORMAL:	/**	Tx原稿モードがＮｏｒｍの時	*/
		table_locate_y += MEM_NORM_POSI;
		break;
	case	SYS_FINE:	/**	Tx原稿モードがＦｉｎｅの時	*/
		table_locate_y += MEM_FINE_POSI;
		break;
	case	SYS_GRAY16:
	case	SYS_GRAY16_SEP:
	case	SYS_GRAY32:
	case	SYS_GRAY32_SEP:
	case	SYS_GRAY64:
	case	SYS_GRAY64_SEP:
	case	SYS_GRAY128:
	case	SYS_GRAY128_SEP:
		if ((CommunicateType == TX_G3_SCAN) ||
			(CommunicateType == TX_ECM_SCAN)) {
			if (GrayScannerTX_ReductionSet() == OK) {	/* スキャナ中間調送信の縮小率をセットする */
				return(OK);								/* セット完了 */
			}
			else {	/* SYS_A3_400_TO_A3_400:SYS_B4_400_TO_B4_400:SYS_A4_400_TO_A4_400:のとき */
#if (PRO_CCD == DPI400)
				table_locate_y += MEM_HFINE_POSI;
#endif
#if (PRO_CCD == DPI300)
				table_locate_y += MEM_EFINE_POSI;
#endif
#if (PRO_CCD == DPI200)
				table_locate_y += MEM_FINE_POSI;
#endif
			}
		}
		else {	/* メモリ送信の場合 */
			table_locate_y += MEM_FINE_POSI;
		}
		break;
	case	SYS_SFINE:
		table_locate_y += MEM_SFINE_POSI;
		break;
	case	SYS_HFINE:
		table_locate_y += MEM_HFINE_POSI;
		break;
	case	SYS_UFINE: /* 600dpi×600dpi対応 1999/05/26 by K.Okada */
		table_locate_y += MEM_UFINE_INCH_POSI;
		break;
	}

	/* TxReductionInch??_DocTable には、原稿サイズ分の変換率が入っています。
	** TxRedutcionMetric??_DocTable には、原稿サイズ分とインチー＞ミリ変換の変換率が入っています。
	** これは、銀杏の名残です。
	** 1997/12/27
	** 文責久保
	*/

	switch (dst_size) {		/**	送信原稿サイズ	*/
	case	SYS_DOCUMENT_A4_SIZE:	/**	送信原稿サイズがＡ４の時	*/
		Pix_H_Reduction = TxReductionInchA4_DocTable[table_locate_y][table_locate_x];
		Pix_V_Reduction = TxReductionInchA4_DocTable[table_locate_y][table_locate_x+1];
		/*--------------------------*/
		/*	スキャナ送信時のみ有効	*/
		/*--------------------------*/
		if ((CommunicateType == TX_G3_SCAN) ||
			(CommunicateType == TX_ECM_SCAN)) {

#if (PRO_CCD == DPI400)
			EncOtpStatus = 216;
			if (dst_mode != SYS_HFINE) {
				EncOtpStatus /= 2;
				if (src_mode != SYS_HFINE) {
					Pix_H_Reduction /= 2;
				}
			}
#endif
#if (PRO_CCD == DPI300)
			/* EncInpStatus = 2592 / 16; 関数の頭で初期化する 97/10/28 T.Yamaguchi */
			if (dst_mode == SYS_EFINE || dst_mode == SYS_E_HFINE) {
				EncOtpStatus = 2592 / 16;	/*162 Word*/
			}
			else {
				EncOtpStatus = 1728 / 16;	/*108 Word*/
				/* for ANZU_L 300*400 by T.Soneoka 1997/11/14 */
				if((src_mode != SYS_E_HFINE) && (src_mode != SYS_EFINE)){
					Pix_H_Reduction = ((Pix_H_Reduction * 2 )/ 3);	/* 1997/09/25 By M.Kotani */
				}
			}
#endif
#if (PRO_CCD == DPI200)
			EncOtpStatus = 108;
#endif
		}
		break;
	case	SYS_DOCUMENT_B4_SIZE:	/**	送信原稿サイズがＢ４の時	*/
		Pix_H_Reduction = TxReductionInchB4_DocTable[table_locate_y][table_locate_x];
		Pix_V_Reduction = TxReductionInchB4_DocTable[table_locate_y][table_locate_x+1];
		/*--------------------------*/
		/*	スキャナ送信時のみ有効	*/
		/*--------------------------*/
		if ((CommunicateType == TX_G3_SCAN) ||
			(CommunicateType == TX_ECM_SCAN)) {
#if (PRO_CCD == DPI400)
			EncOtpStatus = 256;
			if (dst_mode != SYS_HFINE) {
				EncOtpStatus /= 2;
				if (src_mode != SYS_HFINE) {
					Pix_H_Reduction /= 2;
				}
			}
#endif
#if (PRO_CCD == DPI300)
			if (dst_mode == SYS_EFINE || dst_mode == SYS_E_HFINE) {
				EncOtpStatus = 3072 / 16;	/*192 Word*/
			}
			else {
				EncOtpStatus = 2048 / 16;	/*128 Word*/
				if((src_mode != SYS_E_HFINE) && (src_mode != SYS_EFINE)){
					Pix_H_Reduction = ((Pix_H_Reduction * 2 )/ 3);	/* 1997/09/25 By M.Kotani */
				}
			}
#endif
#if (PRO_CCD == DPI200)
			EncOtpStatus = 128;
#endif
		}
		break;
	case	SYS_DOCUMENT_A3_SIZE:	/**	送信原稿サイズがＡ３の時	*/
		Pix_H_Reduction = TxReductionInchA3_DocTable[table_locate_y][table_locate_x];
		Pix_V_Reduction = TxReductionInchA3_DocTable[table_locate_y][table_locate_x+1];
		/*--------------------------*/
		/*	スキャナ送信時のみ有効	*/
		/*--------------------------*/
		if ((CommunicateType == TX_G3_SCAN) ||
			(CommunicateType == TX_ECM_SCAN)) {
#if (PRO_CCD == DPI400)
			EncOtpStatus = 304;
			if (dst_mode != SYS_HFINE) {
				EncOtpStatus /= 2;
				if (src_mode != SYS_HFINE) {
					Pix_H_Reduction /= 2;
				}
			}
#endif
#if (PRO_CCD == DPI300)
			if (dst_mode == SYS_EFINE || dst_mode == SYS_E_HFINE) {
				EncOtpStatus = 3648 / 16;	/*228 Word*/
			}
			else {
				EncOtpStatus = 2432 / 16;	/*152 Word*/
				if((src_mode != SYS_E_HFINE) && (src_mode != SYS_EFINE)){
					Pix_H_Reduction = ((Pix_H_Reduction * 2 )/ 3);	/* 1997/09/25 By M.Kotani */
				}
			}
#endif
#if (PRO_CCD == DPI200)
			EncOtpStatus = 152;
#endif
		}
		break;
	}
	return (OK);
}

/*************************************************************************
	module		:[符号化ページ幅設定]
	function	:[
		1.相手の符号化サイズにより、ＭＮ８６０６３の符合化ページ幅を設定する
	]
	return		:[
		符号化ページ幅
	]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/03/26]
	author		:[曽根岡拓]
*************************************************************************/
UWORD		GetCodecSize(UBYTE size, UBYTE mode)
{
	UWORD	codec_size;
	codec_size = 0;

	switch (mode) {
	case	SYS_NORMAL:					/**	普通	*/
	case	SYS_FINE:					/**	高画質	*/
	case	SYS_GRAY16:					/**	16階調	*/
	case	SYS_GRAY16_SEP:				/**	16階調像域分離	*/
	case	SYS_GRAY32:					/**	32階調	*/
	case	SYS_GRAY32_SEP:				/**	32階調像域分離	*/
	case	SYS_GRAY64:					/**	64階調	*/
	case	SYS_GRAY64_SEP:				/**	64階調像域分離	*/
	case	SYS_GRAY128:
	case	SYS_GRAY128_SEP:
	case	SYS_SFINE:						/**	超高画質	*/
		switch (size) {						/**	送信原稿サイズ	*/
		case	SYS_DOCUMENT_A3_SIZE:		/**	Ａ３サイズの時	*/
			codec_size = 152;				/**	Ａ３幅有効画素数 4862bit=304word	*/
			break;
		case	SYS_DOCUMENT_B4_SIZE:		/**	Ｂ４サイズの時	*/
			codec_size = 128;				/**	Ｂ４幅有効画素数 4096bit=256word	*/
			break;
		case	SYS_DOCUMENT_A4_SIZE:		/**	Ａ４サイズの時	*/
		default:
			codec_size = 108;				/**	Ａ４幅有効画素数 3456bit=216word	*/
			break;
		}
		break;
#if 1		/* スキャナ主走査３００ＤＰＩのとき */ /* 復活させる。犯人は久保 1997/12/16 */
	case	SYS_EFINE:						/**	超上画質(300×300ミリ系)  1996/06/19 By N.Sakamoto	*/
	case	SYS_E_HFINE:					/**	超高画質(300×400ミリ系)  '96.03.08 By T.Y */
		switch (size) {						/**	送信原稿サイズ	*/
		case	SYS_DOCUMENT_A3_SIZE:		/**	Ａ３サイズの時	*/
			codec_size = 228;				/**	Ａ３幅有効画素数 4862bit=304word * 3/4 = 228	*/
			break;
		case	SYS_DOCUMENT_B4_SIZE:		/**	Ｂ４サイズの時	*/
			codec_size = 192;				/**	Ｂ４幅有効画素数 4096bit=256word * 3/4 = 192	*/
			break;
		case	SYS_DOCUMENT_A4_SIZE:		/**	Ａ４サイズの時	*/
		default:
			codec_size = 162;				/**	Ａ４幅有効画素数 3456bit=216word * 3/4 = 162	*/
			break;
		}
		break;
#endif

	/**************************************
	** 600dpi×600dpi 1999/05/24 by K.Okada
	**************************************/
	case	SYS_UFINE:
		switch (size) {						/**	送信原稿サイズ	*/
		case	SYS_DOCUMENT_A3_SIZE:		/**	Ａ３サイズの時	*/
			codec_size = 456;				/**	Ａ３幅有効画素数 4862bit=304word	*/
			break;
		case	SYS_DOCUMENT_B4_SIZE:		/**	Ｂ４サイズの時	*/
			codec_size = 384;				/**	Ｂ４幅有効画素数 4096bit=256word	*/
			break;
		case	SYS_DOCUMENT_A4_SIZE:		/**	Ａ４サイズの時	*/
		default:
			codec_size = 324;				/**	Ａ４幅有効画素数 3456bit=216word	*/
			break;
		}
		break;

	case	SYS_HFINE:						/**	超高画質(400×400ミリ系)  */
	default:
		switch (size) {						/**	送信原稿サイズ	*/
		case	SYS_DOCUMENT_A3_SIZE:		/**	Ａ３サイズの時	*/
			codec_size = 304;				/**	Ａ３幅有効画素数 4862bit=304word	*/
			break;
		case	SYS_DOCUMENT_B4_SIZE:		/**	Ｂ４サイズの時	*/
			codec_size = 256;				/**	Ｂ４幅有効画素数 4096bit=256word	*/
			break;
		case	SYS_DOCUMENT_A4_SIZE:		/**	Ａ４サイズの時	*/
		default:
			codec_size = 216;				/**	Ａ４幅有効画素数 3456bit=216word	*/
			break;
		}
		break;
	}
	return (codec_size);
}


/*************************************************************************
	module		:[符合化Ｋパラメータ設定]
	function	:[
		1.相手のモードに応じて、ＭＮ８６０６３の符合化Ｋパラメータを設定する
	]
	return		:[
		符合化Ｋパラメータ
	]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/03/26]
	author		:[曽根岡拓]
*************************************************************************/
UBYTE		GetK_Parameter(
UBYTE	mode)
{
	UBYTE	encode_kpara;
	/*--------------------------*/
	/*	符号化Ｋパラメータ設定	*/
	/*--------------------------*/
	switch (mode) {			/**	符号化方式	*/
	case SYS_NORMAL:					/**	普通	*/
		encode_kpara = 2;
		break;
	case SYS_FINE:						/**	高画質	*/
	case SYS_GRAY16:					/**	16階調	*/
	case SYS_GRAY16_SEP:				/**	16階調像域分離	*/
	case SYS_GRAY32:					/**	32階調	*/
	case SYS_GRAY32_SEP:				/**	32階調像域分離	*/
	case SYS_GRAY64:					/**	64階調	*/
	case SYS_GRAY64_SEP:				/**	64階調像域分離	*/
		encode_kpara = 4;
		break;
	case SYS_SFINE:						/**	超高画質	*/
	case SYS_E_HFINE:					/**	超高画質	*/
	case SYS_HFINE:						/**	超高画質	*/
		encode_kpara = 8;
		break;
	
	/**************************************
	** 600dpi×600dpi 1999/05/24 by K.Okada
	**************************************/
	case SYS_UFINE:						/** 600×600（インチ系） */
		encode_kpara = 12;
		break;

	default:
		encode_kpara = 0;
	}
	return (encode_kpara);
}


/*************************************************************************
	module		:[復号化最大ライン数設定]
	function	:[
		1.相手のモードに応じて復号化最大ライン数を設定する
	]
	return		:[
		復号化ライン数
	]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/03/26]
	author		:[曽根岡拓]
*************************************************************************/
UWORD		GetMaxTxLine(
UWORD	length)
{
	UWORD	max_decode_line;

	max_decode_line = length;				/**	ＦＣＭの最大ライン数設定	*/
	if (max_decode_line != 0xffff) {
		switch (SYS_DocBlock.Src.Mode) {	/**	蓄積モード	*/
		case SYS_NORMAL:					/**	普通	*/
			break;
		case SYS_FINE:						/**	高画質	*/
		case SYS_GRAY16:					/**	16階調	*/
		case SYS_GRAY16_SEP:				/**	16階調像域分離	*/
		case SYS_GRAY32:					/**	32階調	*/
		case SYS_GRAY32_SEP:				/**	32階調像域分離	*/
		case SYS_GRAY64:					/**	64階調	*/
		case SYS_GRAY64_SEP:				/**	64階調像域分離	*/
			max_decode_line *= 2;			/**	最大復号かライン数２倍	*/
			break;
		case SYS_SFINE:						/**	超高画質	*/
		case SYS_HFINE:						/**	超高画質	*/
			max_decode_line *= 4;			/**	最大復号化ライン数４倍	*/
			break;

		/**************************************
		** 600dpi×600dpi 1999/05/24 by K.Okada
		**************************************/
		case SYS_UFINE:						/**	600×600(インチ系）*/
			max_decode_line *= 6;			/**	最大復号化ライン数６倍	*/
			break;

		}
	}
	return (max_decode_line);
}

/*************************************************************************
	module		:[残りのエンコードデータ設定]
	function	:[
		1.
	]
	return		:[エンコードデータ]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/03/26]
	author		:[曽根岡拓]
*************************************************************************/
UDWORD			EncodeDataCountSet(void)
{
	UWORD counter;
	UDWORD address;
	UBYTE debug;

#if (PRO_SCN_CODEC_TYPE == SOFTWARE) /* 1998/10/13 By H.Hirao */ /* ported for HINOKI2 2001/12/26 T.Takagi */
	/* スキャナ送信は通信コーデックを使用 */
	EncodeDataCount = DMA_CheckDMA_Address(DMA_CH_ENC, DMA_IO_TO_MEMORY) - (UDWORD) ECM_BUFFER_AREA_START_ADDRESS;
#else

	switch (CommunicateType) {
	case	TX_G3_SCAN:
	case	TX_ECM_SCAN:
		EncodeDataCount = DMA_CheckDMA_Address(DMA_SCNCDC_DRAM_CH,DMA_IO_TO_MEMORY) - (UDWORD)ECM_BUFFER_AREA_START_ADDRESS;
		break;
	case	TX_G3_MEM:
	case	TX_ECM_MEM:
		EncodeDataCount = DMA_CheckDMA_Address(DMA_CH_ENC, DMA_IO_TO_MEMORY) - (UDWORD) ECM_BUFFER_AREA_START_ADDRESS;
		break;
	default:
		break;
	}
#endif
	return(EncodeDataCount);
}

/*************************************************************************
	module		:[Pix送出時間設定]
	function	:[
	]
	return		:[
		送出時間*10(ms)
	]
	common		:[]
	condition	:[]
	comment		:[]
	date		:[1994/02/17]
	author		:[曽根岡拓]
*************************************************************************/
UWORD		Set64K_PixTime(void)
{
	UWORD	time;

	switch (PixRxSpeed) {
	case SPEED_33600:
		time = 3360; /* 36408ms */
		break;
	case SPEED_31200:
		time = 1681; /* 36408ms */
		break;
	case SPEED_28800:
		time = 1821; /* 36408ms */
		break;
	case SPEED_26400:
		time = 1986; /* 36408ms */
		break;
	case SPEED_24000:
		time = 2185; /* 36408ms */
		break;
	case SPEED_21600:
		time = 2428; /* 36408ms */
		break;
	case SPEED_19200:
		time = 2731; /* 36408ms */
		break;
	case SPEED_16800:
		time = 3121; /* 36408ms */
		break;
	case SPEED_14400:
		time = 3641; /* 36408ms */
		break;
	case SPEED_12000:
		time = 4370; /* 43691ms */
		break;
	case SPEED_9600:
		time = 5462; /* 54613ms */
		break;
	case SPEED_7200:
		time = 7282; /* 72818ms */
		break;
	case SPEED_4800:
		time = 10923; /* 109227ms */
		break;
	case SPEED_2400:
		time = 21846; /* 218453ms */
		break;
	default:
		break;
	}
	return (time);
}


/*************************************************************************
	module		:[スキャナ送信画データ縮小変換率設定]
	function	:[
		1.中間調（ＩＤＰ）の変換を加えた、縮小率をセット
	]
	return		:[OK:縮小率セット完了
				  NO:縮小率テーブルからセットする（縮小しない)
				 ]
	common		:[
		Pix_H_Reduction
		Pix_V_Reduction
		EncInpStatus
		EncOtpStatus
	]
	condition	:[]
	comment		:[
		設定値は、モデムの送信画データ縮小率変換の設計仕様書を参照してください
	]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[MDM]
	date		:[1996/12/09]
	author		:[山口]
*************************************************************************/
UBYTE GrayScannerTX_ReductionSet(void)
{
#if (PRO_CCD == DPI200)  /* POPLAR_L */
	switch (SCN_ScannerTxReductionPattern) {
	case	SYS_A3_400_TO_B4_400:
		/*	必要とされる縮小率 ８４．３７５％（２７／３２）
		**	ＩＤＰ主走査縮小　８４．５３９％
		**	８４．３７５／８４．５３９＝０．９９８
		**	ＣＯＤＥＣ主走査縮小
		**	１０２４×０．９９８＝１０２２（０ｘ０３ＦＥ）
		**  ＣＯＤＥＣ副走査縮小
		**	１６３８４−（０．９９８×１６３８４）＝ ３３（０ｘ００２１）
		*/
		Pix_H_Reduction = 0x03FE;
		Pix_V_Reduction = 0x0021;
		EncInpStatus = 128;/* 2056 / 16 = 128.5 */
		EncOtpStatus = 128;/* 128 * 0.998 */
		return (OK);
	case	SYS_A3_400_TO_A4_400:
		/*	必要とされる縮小率 ６８．７５％（２２／３２）
		**	ＩＤＰ主走査縮小　６８．７５％
		**	６８．７５／６８．７５＝１．０００
		**	ＣＯＤＥＣ主走査等倍
		**	１０２４×１．０００＝１０２４（０ｘ０４００）
		**  ＣＯＤＥＣ副走査等倍
		**	１６３８４−（１．０００×１６３８４）＝ ０
		*/
		Pix_H_Reduction = 0x0400;
		Pix_V_Reduction = 0x0000;
		EncInpStatus = 108;	/* 1672/16=108.5    */
		EncOtpStatus = 108; /* 108*1.00=108     */
		return (OK);
	case	SYS_B4_400_TO_A4_400:
		/*	必要とされる縮小率 ８１．２５％（２６／３２）
		**	ＩＤＰ主走査縮小　８１．２５％
		**	８１．２５／８１．２５＝１．０
		**	ＣＯＤＥＣ主走査等倍
		**	１０２４×１．０００＝１０２４（０ｘ０４００）
		**	ＣＯＤＥＣ副走査等倍
		**	１６３８４−（１．０００×１６３８４）＝ ０
		*/
		Pix_H_Reduction = 0x0400;
		Pix_V_Reduction = 0x0000;
		EncInpStatus = 103;	/* 1664/16=104     */
		EncOtpStatus = 108; /* 104*1.00 = 104  */
		return (OK);
	case	SYS_A3_400_TO_A3_400:
	case	SYS_B4_400_TO_B4_400:
	case	SYS_A4_400_TO_A4_400:
	default:
		return(NO);	/* 変換しないとき */
	}
#elif (PRO_CCD == DPI400)
/* Ported from ORANGE\SRC\MDM_SUB.C by H.Kubo 1997/07/08 */
/* POPLAR_H 用です。  POPLAR_B と同じになるようにしています。 */
/*#if (PRO_CCD == DPI400)	@* POPLAR_H */
/*************************************************************************
	module		:[スキャナ送信画データ縮小変換率設定]
	function	:[
		1.中間調（ＩＤＰ）の変換を加えた、縮小率をセット
	]
	return		:[OK:縮小率セット完了
				  NO:縮小率テーブルからセットする（縮小しない)
				 ]
	common		:[
		Pix_H_Reduction
		Pix_V_Reduction
		EncInpStatus
		EncOtpStatus
	]
	condition	:[]
	comment		:[
		設定値は、モデムの送信画データ縮小率変換の設計仕様書を参照してください
	]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[MDM]
	date		:[1996/12/09]
	author		:[山口]
*************************************************************************/
/*UBYTE GrayScannerTX_ReductionSet(void)
{*/
	switch (SCN_ScannerTxReductionPattern) {
	case	SYS_A3_400_TO_A3_200:
		/*	ＩＤＰ主走査縮小　４９．８％
		**	０．５／０．４９８＝１．００４	ＣＯＤＥＣ主副走査拡大
		**	１０２４×１．００４＝１０２８（０ｘ４０４）
		**	１．００４×６５５３６−６５５３６＝２６２（０ｘ１０６）
		*/
		Pix_H_Reduction = 0x8404;
		Pix_V_Reduction = 0x0106;
		EncInpStatus = 152;	/*	2432/16=152 */
		EncOtpStatus = 304/2;
		return (OK);
	case	SYS_A3_400_TO_A3_203:
		/*	ＩＤＰ主走査縮小　５１．５％
		**	０．５０８／０．５１５＝０．９８６	ＣＯＤＥＣ主副走査縮小
		**	１０２４×０．９８６＝１０１０（０ｘ３ｆ２）
		**	６５５３６−（０．９８６×６５５３６）＝９１８（０ｘ３９６）
		*/
		Pix_H_Reduction = 0x03f2;
		Pix_V_Reduction = 0x0396;
		EncInpStatus = 156;	/* 2506/16=156.63 */
		EncOtpStatus = 304/2;
		return (OK);
	case	SYS_A3_400_TO_B4_200:
		/*	ＩＤＰ主走査縮小　４２．５％
		**	０．４２２／０．４２５＝０．９９３	ＣＯＤＥＣ主副走査縮小
		**	１０２４×０．９９３＝１０１７（０ｘ３ｆ９）
		**	６５５３６−（０．９９３×６５５３６）＝４５９（０ｘ１ｃｂ）
		**	ICHOU修正  1996/11/12 s.takeuchi
		**	IDP主走査縮小率が 42.1% としてCODECを設定するとまともな画が出る
		**		↑日立からの回答FAXでは 42.11% になる  1996/12/12 s.takeuchi
		**	0.422 / 0.421 = 1.002  :  CODEC主走査縮小率
		**	主走査縮小設定値 : 1024 * 1.002 = 1026 (402h)
		**	副走査縮小設定値 : (1.002 * 65536) - 65536 = 131 (83h)
		**	主走査入力画素	 : 128 WORD
		*/
	/*	Pix_H_Reduction = 0x0402;	ICHOUに合わせた1997/05/27  By T.Yamaguchi */
		Pix_H_Reduction = 0x8402;	/* 0x03f9 */
		Pix_V_Reduction = 0x0083;	/* 0x01cb */
		EncInpStatus = 128;	/* 2068/16=129.25 */
		EncOtpStatus = 256/2;
		return (OK);
	case	SYS_A3_400_TO_B4_203:
		/*	ＩＤＰ主走査縮小　４３．２％
		**	０．４２９／０．４３２＝０．９９３	ＣＯＤＥＣ主副走査縮小
		**	１０２４×０．９９３＝１０１７（０ｘ３ｆ９）
		**	６５５３６−（０．９９３×６５５３６）＝４５９（０ｘ１ｃｂ）
		*/
		Pix_H_Reduction = 0x03f2;	/* '94.10.25 0x3f9->0x3f2 98.7% */
		Pix_V_Reduction = 0x0a3d;	/* '94.10.25 0x1cb->0xa3d 96%	*/
		/* EncInpStatus = 129;	@* 2103/16=131.44 */
		EncInpStatus = 131;	/* 2103/16=131.44 */	/* ICHOU修正  1996/11/12 s.takeuchi */
		EncOtpStatus = 256/2;
		return (OK);
	case	SYS_A3_400_TO_A4_200:
		/*	ＩＤＰ主走査縮小　３４．５％
		**	０．３４４／０．３４５＝０．９９７	ＣＯＤＥＣ主副走査縮小
		**	１０２４×０．９９７＝１０２１（０ｘ３ｆｄ）
		**	６５５３６−（０．９９７×６５５３６）＝１９７（０ｘｃ５）
		*/
		Pix_H_Reduction = 0x03fd;
		Pix_V_Reduction = 0x00c5;
		EncInpStatus = 104;	/* 1677/16=104.81 */
		EncOtpStatus = 216/2;
		return (OK);
	case	SYS_A3_400_TO_A4_203:
		/*	ＩＤＰ主走査縮小　３５％
		**	０．３５／０．３５＝１．０	ＣＯＤＥＣ副走査等倍
		*/
		Pix_H_Reduction = 0x03f9;	/* '94.10.25 0x400->0x3f9 99.4%	*/
		Pix_V_Reduction = 0x08f5;	/* '94.10.25 0x00 ->0x8f5 96.5%	*/
		EncInpStatus = 106;	/* 1702/16=106.38 */
		EncOtpStatus = 216/2;
		return (OK);
	case	SYS_B4_400_TO_B4_200:
		/*	ＩＤＰ主走査縮小　４９．８％
		**	０．５／０．４９８＝１．００４	ＣＯＤＥＣ主副走査拡大
		**	１０２４×１．００４＝１０２８（０ｘ４０４）
		**	１．００４×６５５３６−６５５３６＝２６２（０ｘ１０６）
		*/
		Pix_H_Reduction = 0x8404;
		Pix_V_Reduction = 0x0106;
		EncInpStatus = 128;	/* 2048/16=128 */
		EncOtpStatus = 256/2;
		return (OK);
	case	SYS_B4_400_TO_B4_203:
		/*	ＩＤＰ主走査縮小　５１．４％
		**	０．５０８／０．５１４＝０．９８８	ＣＯＤＥＣ主副走査縮小
		**	１０２４×０．９８８＝１０１２（０ｘ３ｆ４）
		**	６５５３６−（０．９８８×６５５３６）＝７８６（０ｘ３１２）
		**	Pix_H_Reduction = 0x03f4;
		**	Pix_V_Reduction = 0x0312;
		** '94.10.25 H_Reduction = 0.985 V_Reduction = 0.955
		*/
		Pix_H_Reduction = 0x03f0;
		Pix_V_Reduction = 0x0b85;	/*	副走査縮小０．４０７％	*/
		EncInpStatus = 131;	/* 2110/16=131.88 */
		EncOtpStatus = 256/2;
		return (OK);
	case	SYS_B4_400_TO_A4_200:
		/*	ＩＤＰ主走査縮小　４０．７％
		**	０．４０７／０．４０７＝１．０	ＣＯＤＥＣ副走査等倍
		*/
		Pix_H_Reduction = 0x0400;
		Pix_V_Reduction = 0x0000;
		/* EncInpStatus = 105;	@* 1688/16=105.5 */
		EncInpStatus = 104;	/* 1668/16=104.25 */	/* ICHOU修正  1996/11/12 s.takeuchi */
		EncOtpStatus = 216/2;
		return (OK);
	case	SYS_B4_400_TO_A4_203:
		/*	ＩＤＰ主走査縮小　４１．４％
		**	０．４１３／０．４１４＝０．９９８	ＣＯＤＥＣ主副走査縮小
		**	１０２４×０．９９８＝１０２２（０ｘ３ｆｅ）
		**	６５５３６−（０．９９８×６５５３６）＝１３１（０ｘ８３）
		*/
		Pix_H_Reduction = 0x03fa;	/*	0x3fe->0x3fa 0.995%	*/
		Pix_V_Reduction = 0x08f5;	/*	0x83->0x8f5	0.965%	*/
		EncInpStatus = 105; /* 1694/16=105.88 */
		EncOtpStatus = 216/2;
		return (OK);
	case	SYS_A4_400_TO_A4_200:
		/*	ＩＤＰ主走査縮小　４９．８％
		**	０．５／０．４９８＝１．００４	ＣＯＤＥＣ主副走査拡大
		**	１０２４×１．００４＝１０２８（０ｘ４０４）
		**	１．００４×６５５３６−６５５３６＝２６２（０ｘ１０６）
		*/
		Pix_H_Reduction = 0x8404;
		Pix_V_Reduction = 0x0106;
		EncInpStatus = 108; /* 1728/16=108 */
		EncOtpStatus = 216/2;
		return (OK);
	case	SYS_A4_400_TO_A4_203:
		/*	ＩＤＰ主走査縮小　５１．２％
		**	０．５０８／０．５１２＝０．９９２	ＣＯＤＥＣ主副走査縮小
		**	１０２４×０．９９２＝１０１６（０ｘ３ｆ８）
		**	６５５３６−（０．９９２×６５５３６）＝５２４（０ｘ２０ｃ）
		**	Pix_H_Reduction = 0x03f8;
		**	Pix_V_Reduction = 0x020c;		副走査縮小０．４０７％
		** '94.10.25 H_Reduction = 0.985 V_Reduction = 0.955
		*/
		Pix_H_Reduction = 0x03f0;
		Pix_V_Reduction = 0x0b85;	/*	副走査縮小０．４０７％	*/
		EncInpStatus = 111; /* 1780/16=111.25 */
		EncOtpStatus = 216/2;
		return (OK);
	case	SYS_A3_400_TO_B4_400:
		/*	ＩＤＰ主走査縮小　８４．５％
		**	０．８４４／０．８４５＝０．９９９	ＣＯＤＥＣ主副走査縮小
		**	１０２４×０．９９９＝１０２３（０ｘ３ｆｆ）
		**	６５５３６−（０．９９９×６５５３６）＝６６（０ｘ４２）
		*/
		Pix_H_Reduction = 0x03ff;
		Pix_V_Reduction = 0x0042;
		EncInpStatus = 256;/* 4109/16=256.81 */
		EncOtpStatus = 256;
		return (OK);
	case	SYS_A3_400_TO_A4_400:
		/*	ＩＤＰ主走査縮小　６９．２％
		**	０．６８８／０．６９２＝０．９９４	ＣＯＤＥＣ主副走査縮小
		**	１０２４×０．９９４＝１０１８（０ｘ３ｆａ）
		**	６５５３６−（０．９９４×６５５３６）＝３９３（０ｘ１８９）
		*/
		Pix_H_Reduction = 0x03fa;
		Pix_V_Reduction = 0x0189;
		EncInpStatus = 210;	/*	3367/16=210.44	*/
		EncOtpStatus = 216;
		return (OK);
	case	SYS_B4_400_TO_A4_400:
		/*	ＩＤＰ主走査縮小　８１．３％
		**	０．８１３／０．８１３＝１．０	ＣＯＤＥＣ副走査等倍
		*/
		Pix_H_Reduction = 0x0400;
		Pix_V_Reduction = 0x0000;
		EncInpStatus = 208;	/* 3331/16=208.19 */
		EncOtpStatus = 216;
		return (OK);
	case	SYS_A3_400_TO_A3_400:
	case	SYS_B4_400_TO_B4_400:
	case	SYS_A4_400_TO_A4_400:
	default:
		return(NO);	/* 変換しないとき */
	}
#endif /* (PRO_CCD == DPI400) */
}

/*************************************************************************
	module		:[
		T.85(JBIG)によるＢＩＨを読み込み
	]
	function	:[
		1.受信したＢＩＨを大域変数にセットする
	]
	return		:[なし]
	common		:[
		BIH
	]
	condition	:[]
	comment		:[元は\src\atlanta\scd\src\jbg_bih.cからとってきました]
	machine		:[]
	language	:[]
	keyword		:[JBG]
	date		:[1997/12/17]
	author		:[曽根岡拓]
*************************************************************************/
void MDM_JBG_ReadBIH(void)
{
	UBYTE loop;
	UBYTE *dst;
	UBYTE *src;

	dst = (UBYTE *)&CDC_JBG_BIH;
	src = (UBYTE *)&EcmBuffer;
	for (loop = 0; loop < 20; loop++) {
		*dst = *src;
		src++;
		dst++;
	}
}


/*************************************************************************
	module		:[通信強制停止か否か]
	function	:[
		1.
	]
	return		:[]
	common		:[]
	condition	:[]
	comment		:[PRO_QUICK_TX]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[MDM]
	date		:[1998/12/11]
	author		:[村田]
*************************************************************************/
UBYTE MDM_TxForceStop(void)
{
	if (CHK_TxForceStop()) {
		return(1);
	}
#if 0
**	if (SYS_QuickTxStopSwitch(0)) {
**		return(1);
**	}
#endif
	return(0);
}

/* 全機種に反映させます。  by H.Kubo 1999/01/26 */
/*
** ModemControl.UsedCountが、ＦＣＭタスクと割り込みのなかで、同時にライトされています
** ＦＣＭタスクのなかで、ライトするとき、割り込み禁止状態で行うために、以下の関数と置き換えます。
** 問題ないとは思いますが、とりあえずHINOKIだけ
** by H.Hirao 1998/12/10
*/
/*
** モデムバッファ使用本数を１プラスする
*/
void IncModemControlUsedCount(void)
{
	UBYTE is_int_enable; /* BOOL => UBYTE by H.Kubo 1999/01/26 */
	
	if(is_int_enable = CheckInterruptEnable()) {
		CMN_DisableInterrupt();
	}
	ModemControl.UsedCount++;
	
	if (is_int_enable) {
		CMN_EnableInterrupt();
	}
}

/*
** モデムバッファ使用本数を１マイナスする
*/
void DecModemControlUsedCount(void)
{
	UBYTE is_int_enable; /* BOOL => UBYTE by H.Kubo 1999/01/26 */
	
	if(is_int_enable = CheckInterruptEnable()) {
		CMN_DisableInterrupt();
	}
	ModemControl.UsedCount--;
	
	if (is_int_enable) {
		CMN_EnableInterrupt();
	}
}

/*
** Ecm Tx のフレーム間フラグ送出時の待ち時間生成用
** by H.Kubo 1999/01/25
*/
void MDM_EcmTxFillFlags(void)
{
	CMN_ModemWait100microSec(MDM_EcmTxFillFlagsTable[ModemBlock.Speed]); /* フラグ二つ分の時間が経つまで待つ */
	return;
}


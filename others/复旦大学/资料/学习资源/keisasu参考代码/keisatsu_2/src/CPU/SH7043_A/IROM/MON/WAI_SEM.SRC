;/*--------------------------------------------------------------------------*/
;/*  プロジェクト : POPLAR/ANZU_L                                            */
;/*  ファイル名   : wai_sem.src                                              */
;/*  作成者       : 野瀬                                                     */
;/*  日  付       : 1996/10/14                                               */
;/*  概  要       : セマフォ管理                                             */
;/*  修正履歴     :                                                          */
;/*--------------------------------------------------------------------------*/

	.INCLUDE	"\src\cpu\sh7043_a\irom\define\def_mon.hdr"
	.INCLUDE	"\src\cpu\sh7043_a\irom\define\mon_mac.hdr"
	.INCLUDE	"\src\cpu\sh7043_a\irom\ext_v\extv_mon.hdr"

	.IMPORT		_del_ready_link_vec
	.IMPORT		_rescheduler_vec
	.IMPORT		_monitor_error_vec

	.EXPORT		_wai_sem_irom
	.EXPORT		_wai_sem_erom

;/*****************************************************************************
;	module		:[資源を獲得します]
;	function	:[
;		1. セマフォ番号で示されるSCBのセマフォ値の値から、1を減算します。
;		2. 減じた結果、セマフォ値が0以上であれば、このコールを行ったタスクは
;		   セマフォを獲得し、Readyのままでいます。
;		3. 負になる場合は、減じることはせず、このタスクはWaitになり、
;		   セマフォ番号に対応するウェイトタスク・リスト(SCB)に登録されます。
;	]
;	return		:[なし]
;	common		:[_real_run_tid, _tcb, _scb]
;	comment		:[
;
;		wai_sem(sem_no)    Get Semapho
;		unsigned int sem_no;
;
;		引き数レジスタ
;			R4:sem_no
;		内部使用レジスタ
;			R0 R1 R2 R3 R5 R6 R7 R8 R9 R10
;	]
;	machine		:[SH7043]
;	language	:[ASMSH]
;	keyword		:[MON]
;	date		:[1995/11/01]
;	author		:[野瀬敏弘]
;*****************************************************************************/
;/**************************/
;/* ＳＨ７０４３内蔵ＲＯＭ */
;/**************************/
	.SECTION	MON,CODE,ALIGN=4
_wai_sem_irom:
	ADD		#-8,R15
;--------------------------------------------------------------
	STCTX_REG					;ﾏｸﾛ ﾚｼﾞｽﾀの保存
;--------------------------------------------------------------
	MOV.L	R15,R0
	ADD		#STACK_PC_POSITION,R0
	STS		PR,R1
	MOV.L	R1,@R0				;PR(=PC)をスタックへセーブ

	ADD		#4,R0				;INC.L	R0
	STC		SR,R1
	MOV.L	I_BIT_OFF_wai_sem_i,R2		;R2 = 0x0000000F
	AND		R2,R1				;割込許可
	MOV.L	R1,@R0				;SRをスタックへセーブ

;--------------------------------------------------------------
	STSP_REG_P					;ﾏｸﾛ スタックポインタの保存
;--------------------------------------------------------------
;--------------------------------------------------------------
	STACK_CHECK_P	err_wai_sem_i		;ﾏｸﾛ ﾀｽｸﾁｪｯｸ
;--------------------------------------------------------------

;入力 R1:資源を待つTID
;     R2:資源を待つタスクのTCBのオフセットアドレス
;     R4:セマフォ番号
	MOV.L	MON_MAX_SCB_waisem_i,R3
	MOV.B	@R3,R3
	CMP/HI	R4,R3
	BT		wai_sem00_i	; SEMNO_MAX > sem_no -> wai_sem00
err_wai_sem_i:
	MOV.L	monitor_error_wai_sem_i,R1
	MOV.L	@R1,R1
	JMP		@R1
	NOP

wai_sem00_i:
	MOV		R4,R3
	SHLL	R3
	MOV.L	scbp_waisem_i,R5
	MOV.L	@R5,R5
	ADD		R5,R3
	MOV.B	@(SCB_STAT,R3),R0	; R0 = scb[sem_no].stat
	CMP/EQ	#H'FF,R0
	BT		err_wai_sem_i			; scb[sem_no].stat == 0xFF（セマフォがクリエイトされていない）-> err_wai_sem
	MOV.B	@(SCB_TID,R3),R0	; R0 = scb[sem_no].tid
	CMP/EQ	#H'FF,R0
	BF		sem_val0_i			; scb[sem_no].tid != 0xFF（セマフォ値０）->sem_val0

get_sem_i:
; セマフォ獲得
;入力 R1:real_run_tid
;     R3:scb[sem_no]のアドレス
	MOV		#SCB_INIT,R0
	MOV.B	R0,@(SCB_STAT,R3)	; scb[sem_no].stat = SCB_INIT(0x7F)
	MOV		R1,R0
	MOV.B	R0,@(SCB_TID,R3)	; scb[sem_no].tid = real_run_tid

;--------------------------------------------------------------
	RSTR_REG					;ﾏｸﾛ ﾚｼﾞｽﾀﾎﾟｯﾌﾟ
;--------------------------------------------------------------
	RTE
	NOP

sem_val0_i:						; セマフォ解放待ち (00:セマフォ使用中の時)
;入力 R2:real_run_tidのオフセットアドレス
;     R4:sem_no
	MOV		#WAIT_SEM,R3
	MOV.L	tcbp_waisem_i,R0
	MOV.L	@R0,R0
	MOV.B	R3,@(R0,R2)			; tcb[real_run_tid].tsk_stat = WAIT_SEM
	ADD		#TCB_WAIT_PARA1,R0
	MOV.W	R4,@(R0,R2)			; tcb[real_run_tid].wait_param.semno = sem_no
	MOV.L	del_ready_link_wai_sem_i,R3
	MOV.L	@R3,R3
	JSR		@R3
	NOP
	MOV		R4,R5
	SHLL	R5
	MOV.L	scbp_waisem_i,R0
	MOV.L	@R0,R0
	ADD		R0,R5
	MOV.B	@(SCB_STAT,R5),R0	; R0 = scb[sem_no].stat
	CMP/EQ	#SCB_INIT,R0
	BT		wai_sem01_i			; scb[sem_no].stat == SCB_INIT(0x7F) -> wai_sem01

	MOV		#TCB_TBL_SIZE,R8
	MULU	R0,R8
	MOV		R0,R6		; scb[sem_no].statをR6にセーブ
	STS		MACL,R7
	MOV.L	tcbp_waisem_i,R0
	MOV.L	@R0,R0
	ADD		#TCB_PRIORITY,R0
	MOV.B	@(R0,R7),R9			; R9 = tcb[scb[sem_no].stat].priority
	MOV.B	@(R0,R2),R10		; R10 = tcb[real_run_tid].priority
	CMP/HI	R10,R9
	BT		wai_sem02_i			; scb wait priority > run priority -> wai_sem02

	MOV		R7,R5
wai_sem05_i:
	MOV.L	tcbp_waisem_i,R0
	MOV.L	@R0,R0
	ADD		#TCB_LINK,R0
	MOV.B	@(R0,R5),R6
	MOV		#NIL,R8
	CMP/EQ	R8,R6
	BT		wai_sem03_i

	MOV		#TCB_TBL_SIZE,R8
	MULU	R6,R8
	STS		MACL,R7
	MOV.L	tcbp_waisem_i,R0
	MOV.L	@R0,R0
	ADD		#TCB_PRIORITY,R0
	MOV.B	@(R0,R7),R9
	MOV.B	@(R0,R2),R10
	CMP/HI	R10,R9				; scb wait priority > run priority
	BT		wai_sem04_i
	BRA		wai_sem05_i
	MOV		R7,R5

wai_sem04_i:					; scbの中間に接続
	MOV.L	tcbp_waisem_i,R0
	MOV.L	@R0,R0
	ADD		#TCB_LINK,R0
	MOV.B	@(R0,R5),R6
	MOV.B	R1,@(R0,R5)
	BRA		wai_sem_ok_i
	MOV.B	R6,@(R0,R2)

wai_sem03_i:					; scbの最後に接続
	MOV.L	tcbp_waisem_i,R0
	MOV.L	@R0,R0
	ADD		#TCB_LINK,R0
	MOV.B	R1,@(R0,R5)
	BRA		wai_sem_ok_i
	MOV.B	R6,@(R0,R2)

wai_sem02_i:
; scbの先頭に接続
;入力 R1:real_run_tid
;     R5:scb[sem_no]のアドレス
;     R6:scb[sem_no].stat セマフォ待ちタスクのＩＤ
	MOV		R1,R0
	MOV.B	R0,@(SCB_STAT,R5)	; scb[sem_no].stat = real_run_tid
	MOV.L	tcbp_waisem_i,R0
	MOV.L	@R0,R0
	ADD		#TCB_LINK,R0
	BRA		wai_sem_ok_i
	MOV.B	R6,@(R0,R2)			; tcb[real_run_tid].tsk_link = R6

wai_sem01_i						; 待ちタスク無し
;入力 R1:real_run_tid
;     R5:scb[sem_no]のアドレス
	MOV		R1,R0
	MOV.B	R0,@(SCB_STAT,R5)	; scb[sem_no].stat = real_run_tid
	MOV		#NIL,R6
	MOV.L	tcbp_waisem_i,R0
	MOV.L	@R0,R0
	ADD		#TCB_LINK,R0
	MOV.B	R6,@(R0,R2)			; tcb[real_run_tid].tsk_link = 0xFF

wai_sem_ok_i:
	MOV.L	rescheduler_wai_sem_i,R0
	MOV.L	@R0,R0
	JMP		@R0
	NOP

	.ALIGN 4
I_BIT_OFF_wai_sem_i:
	.DATA.L	I_BIT_OFF
monitor_error_wai_sem_i:
	.DATA.L	_monitor_error_vec
del_ready_link_wai_sem_i:
	.DATA.L	_del_ready_link_vec
rescheduler_wai_sem_i:
	.DATA.L	_rescheduler_vec
scbp_waisem_i:
	.DATA.L	_scb_p
tcbp_waisem_i:
	.DATA.L	_tcb_p
MON_MAX_SCB_waisem_i:
	.DATA.L	_MON_MAX_SCB

;/****************/
;/* 外付けＲＯＭ */
;/****************/
	.SECTION	P,CODE,ALIGN=4
_wai_sem_erom:
	ADD		#-8,R15
;--------------------------------------------------------------
	STCTX_REG					;ﾏｸﾛ ﾚｼﾞｽﾀの保存
;--------------------------------------------------------------
	MOV.L	R15,R0
	ADD		#STACK_PC_POSITION,R0
	STS		PR,R1
	MOV.L	R1,@R0				;PR(=PC)をスタックへセーブ

	ADD		#4,R0				;INC.L	R0
	STC		SR,R1
	MOV.L	I_BIT_OFF_wai_sem_e,R2		;R2 = 0x0000000F
	AND		R2,R1				;割込許可
	MOV.L	R1,@R0				;SRをスタックへセーブ

;--------------------------------------------------------------
	STSP_REG_P					;ﾏｸﾛ スタックポインタの保存
;--------------------------------------------------------------
;--------------------------------------------------------------
	STACK_CHECK_P	err_wai_sem_e		;ﾏｸﾛ ﾀｽｸﾁｪｯｸ
;--------------------------------------------------------------

;入力 R1:資源を待つTID
;     R2:資源を待つタスクのTCBのオフセットアドレス
;     R4:セマフォ番号
;	MOV		#SEMNO_MAX,R3
;FOR POINTER ACCESS
	MOV.L	MON_MAX_SCB_waisem_e,R3
	MOV.B	@R3,R3

	CMP/HI	R4,R3
	BT		wai_sem00_e	; SEMNO_MAX > sem_no -> wai_sem00
err_wai_sem_e:
	MOV.L	monitor_error_wai_sem_e,R1
	MOV.L	@R1,R1
	JMP		@R1
	NOP

wai_sem00_e:
	MOV		R4,R3
	SHLL	R3

;	MOV.L	scb_wai_sem_e,R5
;FOR POINTER ACCESS
	MOV.L	scbp_waisem_e,R5
	MOV.L	@R5,R5

	ADD		R5,R3
	MOV.B	@(SCB_STAT,R3),R0	; R0 = scb[sem_no].stat
	CMP/EQ	#H'FF,R0
	BT		err_wai_sem_e			; scb[sem_no].stat == 0xFF（セマフォがクリエイトされていない）-> err_wai_sem
	MOV.B	@(SCB_TID,R3),R0	; R0 = scb[sem_no].tid
	CMP/EQ	#H'FF,R0
	BF		sem_val0_e			; scb[sem_no].tid != 0xFF（セマフォ値０）->sem_val0

get_sem_e:
; セマフォ獲得
;入力 R1:real_run_tid
;     R3:scb[sem_no]のアドレス
	MOV		#SCB_INIT,R0
	MOV.B	R0,@(SCB_STAT,R3)	; scb[sem_no].stat = SCB_INIT(0x7F)
	MOV		R1,R0
	MOV.B	R0,@(SCB_TID,R3)	; scb[sem_no].tid = real_run_tid

;--------------------------------------------------------------
	RSTR_REG					;ﾏｸﾛ ﾚｼﾞｽﾀﾎﾟｯﾌﾟ
;--------------------------------------------------------------
	RTE
	NOP

sem_val0_e:						; セマフォ解放待ち (00:セマフォ使用中の時)
;入力 R2:real_run_tidのオフセットアドレス
;     R4:sem_no
	MOV		#WAIT_SEM,R3

;	MOV.L	tcb_wai_sem_e,R0
;FOR POINTER ACCESS
	MOV.L	tcbp_waisem_e,R0
	MOV.L	@R0,R0

	MOV.B	R3,@(R0,R2)			; tcb[real_run_tid].tsk_stat = WAIT_SEM
	ADD		#TCB_WAIT_PARA1,R0
	MOV.W	R4,@(R0,R2)			; tcb[real_run_tid].wait_param.semno = sem_no
	MOV.L	del_ready_link_wai_sem_e,R3
	MOV.L	@R3,R3
	JSR		@R3
	NOP
	MOV		R4,R5
	SHLL	R5

;	MOV.L	scb_wai_sem_e,R0
;FOR POINTER ACCESS
	MOV.L	scbp_waisem_e,R0
	MOV.L	@R0,R0

	ADD		R0,R5
	MOV.B	@(SCB_STAT,R5),R0	; R0 = scb[sem_no].stat
	CMP/EQ	#SCB_INIT,R0
	BT		wai_sem01_e			; scb[sem_no].stat == SCB_INIT(0x7F) -> wai_sem01

	MOV		#TCB_TBL_SIZE,R8
	MULU	R0,R8
	MOV		R0,R6		; scb[sem_no].statをR6にセーブ
	STS		MACL,R7

;	MOV.L	tcb_priority_wai_sem_e,R0
;FOR POINTER ACCESS
	MOV.L	tcbp_waisem_e,R0
	MOV.L	@R0,R0
	ADD		#TCB_PRIORITY,R0

	MOV.B	@(R0,R7),R9			; R9 = tcb[scb[sem_no].stat].priority
	MOV.B	@(R0,R2),R10		; R10 = tcb[real_run_tid].priority
	CMP/HI	R10,R9
	BT		wai_sem02_e			; scb wait priority > run priority -> wai_sem02

	MOV		R7,R5
wai_sem05_e:
;	MOV.L	tcb_link_wai_sem_e,R0
;FOR POINTER ACCESS
	MOV.L	tcbp_waisem_e,R0
	MOV.L	@R0,R0
	ADD		#TCB_LINK,R0

	MOV.B	@(R0,R5),R6
	MOV		#NIL,R8
	CMP/EQ	R8,R6
	BT		wai_sem03_e

	MOV		#TCB_TBL_SIZE,R8
	MULU	R6,R8
	STS		MACL,R7

;	MOV.L	tcb_priority_wai_sem_e,R0
;FOR POINTER ACCESS
	MOV.L	tcbp_waisem_e,R0
	MOV.L	@R0,R0
	ADD		#TCB_PRIORITY,R0

	MOV.B	@(R0,R7),R9
	MOV.B	@(R0,R2),R10
	CMP/HI	R10,R9				; scb wait priority > run priority
	BT		wai_sem04_e
	BRA		wai_sem05_e
	MOV		R7,R5

wai_sem04_e:					; scbの中間に接続
;	MOV.L	tcb_link_wai_sem_e,R0
;FOR POINTER ACCESS
	MOV.L	tcbp_waisem_e,R0
	MOV.L	@R0,R0
	ADD		#TCB_LINK,R0

	MOV.B	@(R0,R5),R6
	MOV.B	R1,@(R0,R5)
	BRA		wai_sem_ok_e
	MOV.B	R6,@(R0,R2)

wai_sem03_e:					; scbの最後に接続
;	MOV.L	tcb_link_wai_sem_e,R0
;FOR POINTER ACCESS
	MOV.L	tcbp_waisem_e,R0
	MOV.L	@R0,R0
	ADD		#TCB_LINK,R0

	MOV.B	R1,@(R0,R5)
	BRA		wai_sem_ok_e
	MOV.B	R6,@(R0,R2)

wai_sem02_e:
; scbの先頭に接続
;入力 R1:real_run_tid
;     R5:scb[sem_no]のアドレス
;     R6:scb[sem_no].stat セマフォ待ちタスクのＩＤ
	MOV		R1,R0
	MOV.B	R0,@(SCB_STAT,R5)	; scb[sem_no].stat = real_run_tid

;	MOV.L	tcb_link_wai_sem_e,R0
;FOR POINTER ACCESS
	MOV.L	tcbp_waisem_e,R0
	MOV.L	@R0,R0
	ADD		#TCB_LINK,R0

	BRA		wai_sem_ok_e
	MOV.B	R6,@(R0,R2)			; tcb[real_run_tid].tsk_link = R6

wai_sem01_e						; 待ちタスク無し
;入力 R1:real_run_tid
;     R5:scb[sem_no]のアドレス
	MOV		R1,R0
	MOV.B	R0,@(SCB_STAT,R5)	; scb[sem_no].stat = real_run_tid
	MOV		#NIL,R6

;	MOV.L	tcb_link_wai_sem_e,R0
;FOR POINTER ACCESS
	MOV.L	tcbp_waisem_e,R0
	MOV.L	@R0,R0
	ADD		#TCB_LINK,R0

	MOV.B	R6,@(R0,R2)			; tcb[real_run_tid].tsk_link = 0xFF

wai_sem_ok_e:
	MOV.L	rescheduler_wai_sem_e,R0
	MOV.L	@R0,R0
	JMP		@R0
	NOP

	.ALIGN 4
I_BIT_OFF_wai_sem_e:
	.DATA.L	I_BIT_OFF
monitor_error_wai_sem_e:
	.DATA.L	_monitor_error_vec
;scb_wai_sem_e:
;	.DATA.L	_scb
;tcb_wai_sem_e:
;	.DATA.L	_tcb
del_ready_link_wai_sem_e:
	.DATA.L	_del_ready_link_vec
;tcb_priority_wai_sem_e:
;	.DATA.L	_tcb+TCB_PRIORITY
;tcb_link_wai_sem_e:
;	.DATA.L	_tcb+TCB_LINK
rescheduler_wai_sem_e:
	.DATA.L	_rescheduler_vec
scbp_waisem_e:
	.DATA.L	_scb_p
tcbp_waisem_e:
	.DATA.L	_tcb_p
MON_MAX_SCB_waisem_e:
	.DATA.L	_MON_MAX_SCB

	.END

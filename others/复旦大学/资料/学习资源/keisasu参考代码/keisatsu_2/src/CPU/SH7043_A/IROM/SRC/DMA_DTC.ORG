/*--------------------------------------------------------------------------*/
/*  プロジェクト : POPLAR/ANZU_L                                            */
/*  ファイル名   : dma_dtc.c                                                */
/*  作成者       : 野瀬                                                     */
/*  日  付       : 1996/12/17                                               */
/*  概  要       : SH7043内蔵DTCの各種設定を行う為の関数群                  */
/*  修正履歴     :                                                          */
/*--------------------------------------------------------------------------*/
#include "\src\atlanta\define\product.h"
#include "\src\atlanta\define\dma_pro.h"
#include "\src\atlanta\define\dma_blk.h"
#include "\src\atlanta\define\dma_def.h"
#include "\src\atlanta\ext_v\dma_data.h"
#include "\src\atlanta\sh7043\define\sh_sys.h"


/* debug */
#include "\src\atlanta\mdm\orange\define\mdm_def.h"
#include "\src\atlanta\mdm\orange\ext_v\mdm_data.h"


void SaveReturnAddressAndJumpBegin(void);
void MDM_ModemDMA_TC_Interrupt(void);

/*************************************************************************
	module		:[SH7043内蔵DTCのセットアップ]
	function	:[
		1.ブロック転送モードでＤＴＣレジスタ情報をセットアップします
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1996/12/20]
	author		:[野瀬敏弘]
*************************************************************************/
void DMA_SetupDTC(struct DMA_DTC_Data_t *setup)
{
	switch (setup->DTC_Mode) {
	case	DTC_INTERRUPT_CH:
		DMA_SetupIntDTC(setup);	/* 割り込みを起動要因 */
		break;
	case	DTC_BLOCK_MODE:
		DMA_SetupBlockDTC(setup);	/* ソフト起動要因 */
		break;
	case	DTC_NORMAL_MODE:
		DMA_SetupNormalDTC(setup);	/* ソフト起動要因 */
		break;
	case	DTC_REPEAT_MODE:
		DMA_SetupRepeatDTC(setup);	/* ソフト起動要因 */
		break;
	case	DTC_INTERRUPT_CH2:
		DMA_SetupIntDTC2(setup);	/* 割り込みを起動要因 */
		break;
	}
}

/*************************************************************************
	module		:[SH7043内蔵DTCのセットアップ]
	function	:[
		1.モデムＤＲＥＱ割り込みでＤＴＣレジスタ情報をセットアップします
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1996/12/20]
	author		:[山口哲治]
*************************************************************************/
void DMA_SetupIntDTC(struct DMA_DTC_Data_t *setup)
{
	UDWORD address;
	
	/* モードレジスタ情報の設定
	** ソースアドレス増加
	** ノーマル転送モード
	** デスティネーション側ブロック領域
	** １ブロック転送終了で割込み発生
	** インタラプトセレクト
	** データ転送継続
	*/
#if (PRO_MODEM == ORANGE3) /* #if is added by H.Kubo 1997/10/09 */
	if (setup->SrcAddress == MDM_ADDRESS) {
		/** ソースアドレス固定,デスティネーションアドレス増加 */
		DTC_INT_NORMAL.DTMR_Status = (0 | DTMR_DM_INC );
	}
	else if (setup->DstAddress == MDM_ADDRESS) {
		/** ソースアドレス増加,デスティネーションアドレス固定 */
		DTC_INT_NORMAL.DTMR_Status = (0 | DTMR_SM_INC );
	}
#endif /* (PRO_MODEM == ORANGE3) */

	switch (setup->Unit) {
	case DMA_BYTE_TRANSFER: /* バイト転送 */
		/* 初期設定値なので何もしない */
		break;
	case DMA_WORD_TRANSFER: /* ワード転送 */
		DTC_INT_NORMAL.DTMR_Status |= DTMR_SZ_WORD;
		break;
	case DMA_DWORD_TRANSFER: /* ロング転送 */
		DTC_INT_NORMAL.DTMR_Status |= DTMR_SZ_DWORD;
		break;
	default:
		SaveReturnAddressAndJumpBegin();
	}

	/* カウントレジスタ情報の設定 */
	DTC_INT_NORMAL.DTCRA_Status = setup->Counter;

	/* ブロック長レジスタ情報の設定 ﾉｰﾏﾙﾓｰﾄﾞはない */
	/* DTC_INT_NORMAL.DTCRB_Status = setup->Length; */

	/* 転送元アドレスレジスタ情報の設定 */
	DTC_INT_NORMAL.DTSAR_Status = setup->SrcAddress;

	/* 転送先アドレスレジスタ情報の設定 */
	DTC_INT_NORMAL.DTDAR_Status = setup->DstAddress;

	/* ＤＴＣ情報ベースレジスタの設定 */
	address = (UDWORD)(&DTC_INT_NORMAL);
	SH__DTBR = (UWORD)(address >> 16);
}

/*************************************************************************
	module		:[SH7043内蔵DTCのセットアップ]
	function	:[
		1.ブロック転送モードでＤＴＣレジスタ情報をセットアップします
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1996/12/20]
	author		:[野瀬敏弘]
*************************************************************************/
void DMA_SetupBlockDTC(struct DMA_DTC_Data_t *setup)
{
	UDWORD address;

	/* モードレジスタ情報の設定
	** ソースアドレス増加
	** デスティネーションアドレス増加
	** ブロック転送モード
	** デスティネーション側ブロック領域
	** １ブロック転送終了で割込み発生
	*/
	DTC_BLOCK.DTMR_Status = (0 | DTMR_SM_INC | DTMR_DM_INC | DTMR_MD_BLOCK | DTMR_DISEL_SET);
	switch (setup->Unit) {
	case DMA_BYTE_TRANSFER: /* バイト転送 */
		/* 初期設定値なので何もしない */
		break;
	case DMA_WORD_TRANSFER: /* ワード転送 */
		DTC_BLOCK.DTMR_Status |= DTMR_SZ_WORD;
		break;
	case DMA_DWORD_TRANSFER: /* ロング転送 */
		DTC_BLOCK.DTMR_Status |= DTMR_SZ_DWORD;
		break;
	default:
		SaveReturnAddressAndJumpBegin();
	}

	/* カウントレジスタ情報の設定 */
	DTC_BLOCK.DTCRA_Status = setup->Counter;

	/* ブロック長レジスタ情報の設定 */
	DTC_BLOCK.DTCRB_Status = setup->Length;

	/* 転送元アドレスレジスタ情報の設定 */
	DTC_BLOCK.DTSAR_Status = setup->SrcAddress;

	/* 転送先アドレスレジスタ情報の設定 */
	DTC_BLOCK.DTDAR_Status = setup->DstAddress;

	/* ＤＴＣ情報ベースレジスタの設定 */
	address = (UDWORD)(&DTC_BLOCK);
	SH__DTBR = (UWORD)(address >> 16);

}

/*************************************************************************
	module		:[SH7043内蔵DTCのセットアップ]
	function	:[
		1.ノーマル転送モードでＤＴＣレジスタ情報をセットアップします
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1996/12/20]
	author		:[山口哲治]
*************************************************************************/
void DMA_SetupNormalDTC(struct DMA_DTC_Data_t *setup)
{
	UDWORD address;

	/* モードレジスタ情報の設定
	** ソースアドレス増加
	** デスティネーションアドレス増加
	** ノーマル転送モード
	** 転送終了で割込み発生
	** インタラプトセレクト
	*/
	DTC_BLOCK.DTMR_Status = (0 | DTMR_SM_INC | DTMR_DM_INC | DTMR_DISEL_SET);
	switch (setup->Unit) {
	case DMA_BYTE_TRANSFER: /* バイト転送 */
		/* 初期設定値なので何もしない */
		break;
	case DMA_WORD_TRANSFER: /* ワード転送 */
		DTC_NORMAL.DTMR_Status |= DTMR_SZ_WORD;
		break;
	case DMA_DWORD_TRANSFER: /* ロング転送 */
		DTC_NORMAL.DTMR_Status |= DTMR_SZ_DWORD;
		break;
	default:
		SaveReturnAddressAndJumpBegin();
	}

	/* カウントレジスタ情報の設定 */
	DTC_NORMAL.DTCRA_Status = setup->Counter;

	/* ブロック長レジスタ情報の設定 */
	/* DTC_NORMAL.DTCRB_Status = setup->Length; */

	/* 転送元アドレスレジスタ情報の設定 */
	DTC_NORMAL.DTSAR_Status = setup->SrcAddress;

	/* 転送先アドレスレジスタ情報の設定 */
	DTC_NORMAL.DTDAR_Status = setup->DstAddress;

	/* ＤＴＣ情報ベースレジスタの設定 */
	address = (UDWORD)(&DTC_NORMAL);
	SH__DTBR = (UWORD)(address >> 16);

}

/*************************************************************************
	module		:[SH7043内蔵DTCのセットアップ]
	function	:[
		1.リピート転送モードでＤＴＣレジスタ情報をセットアップします
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1996/12/20]
	author		:[山口哲治]
*************************************************************************/
void DMA_SetupRepeatDTC(struct DMA_DTC_Data_t *setup)
{
	UDWORD address;

	/* モードレジスタ情報の設定
	** ソースアドレス増加
	** デスティネーションアドレス増加
	** リピート転送モード
	** 転送終了で割込み発生
	*/
	DTC_REPEAT.DTMR_Status = (0 | DTMR_SM_INC | DTMR_DM_INC | DTMR_MD_REPEAT | DTMR_DISEL_SET);
	switch (setup->Unit) {
	case DMA_BYTE_TRANSFER: /* バイト転送 */
		/* 初期設定値なので何もしない */
		break;
	case DMA_WORD_TRANSFER: /* ワード転送 */
		DTC_REPEAT.DTMR_Status |= DTMR_SZ_WORD;
		break;
	case DMA_DWORD_TRANSFER: /* ロング転送 */
		DTC_REPEAT.DTMR_Status |= DTMR_SZ_DWORD;
		break;
	default:
		SaveReturnAddressAndJumpBegin();
	}

	/* カウントレジスタ情報の設定 */
	DTC_REPEAT.DTCRA_Status = setup->Counter;

	/* 初期アドレスレジスタ情報の設定 */
	DTC_REPEAT.DTIAR_Status = setup->SrcAddress;

	/* 転送元アドレスレジスタ情報の設定 */
	DTC_REPEAT.DTSAR_Status = setup->SrcAddress;

	/* 転送先アドレスレジスタ情報の設定 */
	DTC_REPEAT.DTDAR_Status = setup->DstAddress;

	/* ＤＴＣ情報ベースレジスタの設定 */
	address = (UDWORD)(&DTC_REPEAT);
	SH__DTBR = (UWORD)(address >> 16);

}

/*************************************************************************
	module		:[SH7043内蔵DTCのセットアップ]
	function	:[
		1.ＭＰＳＣのＤＲＥＱ起動でノーマル転送モードでＤＴＣレジスタ情報をセットアップします
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1996/12/20]
	author		:[山口哲治]
*************************************************************************/
void DMA_SetupIntDTC2(struct DMA_DTC_Data_t *setup)
{
	UDWORD address;
		
	/* モードレジスタ情報の設定
	** ノーマル転送モード
	** 転送終了で割込み発生
	** インタラプトセレクト
	*/
	if (setup->SrcAddress == RS_ADDRESS) {
		/** ソースアドレス固定,デスティネーションアドレス増加 */
		DTC_INT_NORMAL2.DTMR_Status = (0 | DTMR_DM_INC );
	}
	else if (setup->DstAddress == RS_ADDRESS) {
		/** ソースアドレス増加,デスティネーションアドレス固定 */
		DTC_INT_NORMAL2.DTMR_Status = (0 | DTMR_SM_INC );
	}
	switch (setup->Unit) {
	case DMA_BYTE_TRANSFER: /* バイト転送 */
		/* 初期設定値なので何もしない */
		break;
	case DMA_WORD_TRANSFER: /* ワード転送 */
		DTC_INT_NORMAL2.DTMR_Status |= DTMR_SZ_WORD;
		break;
	case DMA_DWORD_TRANSFER: /* ロング転送 */
		DTC_INT_NORMAL2.DTMR_Status |= DTMR_SZ_DWORD;
		break;
	default:
		SaveReturnAddressAndJumpBegin();
	}

	/* カウントレジスタ情報の設定 */
	DTC_INT_NORMAL2.DTCRA_Status = setup->Counter;

	/* ブロック長レジスタ情報の設定 ﾉｰﾏﾙﾓｰﾄﾞはない */
	/* DTC_INT_NORMAL2.DTCRB_Status = setup->Length; */

	/* 転送元アドレスレジスタ情報の設定 */
	DTC_INT_NORMAL2.DTSAR_Status = setup->SrcAddress;

	/* 転送先アドレスレジスタ情報の設定 */
	DTC_INT_NORMAL2.DTDAR_Status = setup->DstAddress;

	/* ＤＴＣ情報ベースレジスタの設定 */
	address = (UDWORD)(&DTC_INT_NORMAL2);
	SH__DTBR = (UWORD)(address >> 16);

}

/*************************************************************************
	module		:[SH7043内蔵DTCの転送スタート]
	function	:[
		1.
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[
		１ブロックの転送が終了するまでＰＣは停止します。
	]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1996/12/20]
	author		:[野瀬敏弘]
*************************************************************************/
static UBYTE DMA_DTC_DummyVer[2] = {0};	/* B Section By O.Kimoto 1998/08/28 */
void DMA_DTC_TransferStart(UBYTE mode)
{
	switch (mode) {
	case DTC_BLOCK_MODE:
		while (DTC_BLOCK.DTCRA_Status) {
			/* 転送開始
			** ベクタアドレスは H'442
			*/
			SH__DTCSR &= ~DTCSR_SWDTE;
			SH__DTCSR = 0x0042;			/* ベクタオフセット加算 */
			SH__DTCSR |= DTCSR_SWDTE;	/* スタート */
			/* DTCSR のソフトウェア起動ビットをＯＮして DTCSRをリードするまでの間に
			** アセンブラレベルで少なくとも２命令を置かないと実際に転送終了した後の
			** DTCSRをリードできないのでダミーのライトを入れます。
			** T.Nose 1997/09/30
			*/
			DMA_DTC_DummyVer[0] = 0;
			DMA_DTC_DummyVer[1] = 0;
		}
		break;
	case DTC_NORMAL_MODE:
		while (DTC_NORMAL.DTCRA_Status) {
			/* 転送開始
			** ベクタアドレスは H'444
			*/
			SH__DTCSR &= ~DTCSR_SWDTE;
			SH__DTCSR = 0x0044;			/* ベクタオフセット加算 */
			SH__DTCSR |= DTCSR_SWDTE;	/* スタート */
			/* DTCSR のソフトウェア起動ビットをＯＮして DTCSRをリードするまでの間に
			** アセンブラレベルで少なくとも２命令を置かないと実際に転送終了した後の
			** DTCSRをリードできないのでダミーのライトを入れます。
			** T.Nose 1997/09/30
			*/
			DMA_DTC_DummyVer[0] = 0;
			DMA_DTC_DummyVer[1] = 0;
		}
		break;
	case DTC_REPEAT_MODE:
		while (DTC_REPEAT.DTCRA_Status) {
			/* 転送開始
			** ベクタアドレスは H'446
			*/
			SH__DTCSR &= ~DTCSR_SWDTE;
			SH__DTCSR = 0x0046;			/* ベクタオフセット加算 */
			SH__DTCSR |= DTCSR_SWDTE;	/* スタート */
			/* DTCSR のソフトウェア起動ビットをＯＮして DTCSRをリードするまでの間に
			** アセンブラレベルで少なくとも２命令を置かないと実際に転送終了した後の
			** DTCSRをリードできないのでダミーのライトを入れます。
			** T.Nose 1997/09/30
			*/
			DMA_DTC_DummyVer[0] = 0;
			DMA_DTC_DummyVer[1] = 0;
		}
		break;
	case DTC_INTERRUPT_CH:
		/* 転送開始
		** ベクタアドレスは H'42E	IRQ5
		*/
		SH__DTEC &= ~IREQ5_ENABLE;
		SH__DTEC |= IREQ5_ENABLE;	/* スタート */
		SH__IPRB |= IRQ5_LEVEL;		/* IRQ5マスク解除 1997/08/05  By T.Yamaguchi */
		break;
	case DTC_INTERRUPT_CH2:
		/* 転送開始
		** ベクタアドレスは H'430	IRQ6
		*/
		SH__DTED &= ~IREQ6_ENABLE;
		SH__DTED |= IREQ6_ENABLE;	/* スタート */
		SH__IPRB |= IRQ6_LEVEL;		/* IRQ5マスク解除 1997/08/05  By T.Yamaguchi */
		break;
	}
}

/*************************************************************************
	module		:[SH7043内蔵DTCの転送回数を読み出す]
	function	:[
		1.
	]
	return		:[アドレス]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1997/07/22]
	author		:[山口哲治]
*************************************************************************/
UWORD DMA_DTC_CheckCounter(UBYTE channel)
{
	UWORD count;

	switch (channel) {
	case DTC_INTERRUPT_CH:
		count = DTC_INT_NORMAL.DTCRA_Status;
		break;
	case DTC_BLOCK_MODE:
		count = DTC_BLOCK.DTCRA_Status;
		break;
	case DTC_NORMAL_MODE:
		count = DTC_BLOCK.DTCRA_Status;
		break;
	case DTC_REPEAT_MODE:
		count = DTC_REPEAT.DTCRA_Status;
		break;
	case DTC_INTERRUPT_CH2:
		count = DTC_INT_NORMAL2.DTCRA_Status;
		break;
	default:
		SaveReturnAddressAndJumpBegin();
	}

	return(count);
}

/*************************************************************************
	module		:[SH7043内蔵DTCの現在の転送アドレスを読み出す]
	function	:[
		1.
	]
	return		:[アドレス]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1997/07/22]
	author		:[山口哲治]
*************************************************************************/
UDWORD DMA_DTC_CheckAddress(UBYTE channel, UBYTE direction)
{
	UDWORD address;

	switch (direction) {
	case DMA_IO_TO_MEMORY:
		address = DMA_DTC_CheckDstAddress(channel);	/* DTCを使用する場合 */
		break;
	case DMA_MEMORY_TO_IO:
		address = DMA_DTC_CheckSrcAddress(channel);	/* DTCを使用する場合 */
		break;
	default:
		SaveReturnAddressAndJumpBegin();
	}

	return(address);
}

/*************************************************************************
	module		:[SH7043内蔵DTCの現在の転送アドレスを読み出す]
	function	:[
		1.
	]
	return		:[アドレス]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1997/07/22]
	author		:[山口哲治]
*************************************************************************/
UDWORD DMA_DTC_CheckDstAddress(UBYTE channel)
{
	UDWORD address;

	switch (channel) {
	case DTC_INTERRUPT_CH:
		address = DTC_INT_NORMAL.DTDAR_Status;
		break;
	case DTC_BLOCK_MODE:
		address = DTC_BLOCK.DTDAR_Status;
		break;
	case DTC_NORMAL_MODE:
		address = DTC_BLOCK.DTDAR_Status;
		break;
	case DTC_REPEAT_MODE:
		address = DTC_REPEAT.DTDAR_Status;
		break;
	case DTC_INTERRUPT_CH2:
		address = DTC_INT_NORMAL2.DTDAR_Status;
		break;
	default:
		SaveReturnAddressAndJumpBegin();
	}

	return(address);
}

/*************************************************************************
	module		:[SH7043内蔵DTCの現在の転送アドレスを読み出す]
	function	:[
		1.
	]
	return		:[アドレス]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1997/07/22]
	author		:[山口哲治]
*************************************************************************/
UDWORD DMA_DTC_CheckSrcAddress(UBYTE channel)
{
	UDWORD address;

	switch (channel) {
	case DTC_INTERRUPT_CH:
		address = DTC_INT_NORMAL.DTSAR_Status;
		break;
	case DTC_BLOCK_MODE:
		address = DTC_BLOCK.DTSAR_Status;
		break;
	case DTC_NORMAL_MODE:
		address = DTC_BLOCK.DTSAR_Status;
		break;
	case DTC_REPEAT_MODE:
		address = DTC_REPEAT.DTSAR_Status;
		break;
	case DTC_INTERRUPT_CH2:
		address = DTC_INT_NORMAL2.DTSAR_Status;
		break;
	default:
		SaveReturnAddressAndJumpBegin();
	}

	return(address);
}



/*************************************************************************
	module		:[SH7043内蔵DTCの転送ブロック長読み出し]
	function	:[
		1.
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1996/12/20]
	author		:[野瀬敏弘]
*************************************************************************/
UWORD DMA_DTC_CheckDTCRB(void)
{
	return(DTC_BLOCK.DTCRB_Status);
}

/*************************************************************************
	module		:[SH7043内蔵DTCの初期アドレス読み出し]
	function	:[
		1.
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1996/12/20]
	author		:[野瀬敏弘]
*************************************************************************/
UDWORD DMA_DTC_CheckDTIAR(void)
{
	return(DTC_REPEAT.DTIAR_Status);
}


/*************************************************************************
	module		:[SH7043内蔵DTCの割り込み処理]
	function	:[
		1.
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1996/12/25]
	author		:[野瀬敏弘]
*************************************************************************/
void DMA_DTC_Interrupt(void)
{
	SH__DTCSR &= ~DTCSR_SWDTE;

	/* デスティネーションアドレス情報を１ブロック分進める。*/
	switch (DTC_BLOCK.DTMR_Status & 0x0300) { /* D9,D8をマスク */
	case 0: /* バイト転送 */
		DTC_BLOCK.DTDAR_Status += (UDWORD)DTC_BLOCK.DTCRB_Status;
		break;
	case DTMR_SZ_WORD: /* ワード転送 */
		DTC_BLOCK.DTDAR_Status += (UDWORD)(DTC_BLOCK.DTCRB_Status * 2);
		break;
	case DTMR_SZ_DWORD: /* ロング転送 */
		DTC_BLOCK.DTDAR_Status += (UDWORD)(DTC_BLOCK.DTCRB_Status * 4);
		break;
	default:
		SaveReturnAddressAndJumpBegin();
	}
}

/*************************************************************************
	module		:[SH7043内蔵DTCの終了割り込み処理]
	function	:[
		1.
	]
	return		:[無し]
	common		:[ＤＴＣの終了割り込みは、ＤＴＣを起動していない状態での
				  起動要因の割り込みで発生する]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1997/08/06]
	author		:[山口哲治]
*************************************************************************/
void DTC_TC_MDM_Interrupt(void)
{
#if (PRO_EXT_DMAC == DISABLE)	/* 1997/12/16 */
	DMA_DTC_RequestReqDisable();
#endif
	 SH__IPRB &= ~IRQ5_LEVEL;	/* IRQ5マスク 1997/08/05  By T.Yamaguchi */

	/* DMA終了割り込みを呼ぶ */
	MDM_ModemDMA_TC_Interrupt();

#if (PRO_EXT_DMAC == DISABLE)	/* 1997/12/16 */
	DMA_DTC_RequestReqEnable();
#endif
}

/*************************************************************************
	module		:[ＤＭＡのｾｯﾄｱｯﾌﾟ時の変数からDTC用の変数に変換して
				SH7043内蔵DTCのセットアップを起動]
	function	:[
		1.ブロック転送モードでＤＴＣレジスタ情報をセットアップします
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1997/07/08]
	author		:[山口 哲治]
*************************************************************************/
void DMAtoDTC_SetupDTC(struct DMA_Data_t *dma_setup_data)
{
	struct DMA_DTC_Data_t dma_setup;
	
	dma_setup.Unit = dma_setup_data->Unit;
	dma_setup.DTC_Mode = dma_setup_data ->Channel;
	dma_setup.Counter = dma_setup_data->Counter;
	dma_setup.Length = 1;	/*	ノーマルモードでは使わない */
#if (PRO_MODEM == ORANGE3) /* #if is added by H.Kubo 1997/10/09 */
	switch (dma_setup_data->Direction) {
	case DMA_IO_TO_MEMORY:
		if (dma_setup_data ->Channel == DTC_INTERRUPT_CH) {
			dma_setup.SrcAddress = MDM_ADDRESS;
		}
		else if (dma_setup_data ->Channel == DTC_INTERRUPT_CH2) {
			dma_setup.SrcAddress = RS_ADDRESS;
		}
		dma_setup.DstAddress = dma_setup_data -> SrcAddress;
		break;
	case DMA_MEMORY_TO_IO:
		dma_setup.SrcAddress = dma_setup_data -> SrcAddress;
		if (dma_setup_data ->Channel == DTC_INTERRUPT_CH) {
			dma_setup.DstAddress = MDM_ADDRESS;
		}
		else if (dma_setup_data ->Channel == DTC_INTERRUPT_CH2) {
			dma_setup.DstAddress = RS_ADDRESS;
		}
		break;
	default:
		SaveReturnAddressAndJumpBegin();
	}
#endif /* (PRO_MODEM == ORANGE3)  */
#if (PRO_MODEM == R288F) /* added by H.Kubo 1997/10/09 */
	/* POPLAR_H では外付 DMAC があるため、モデムのデータ転送に DTC は
	** 使わないが、念のため入れておく。
	*/
	switch (dma_setup_data->Direction) {
	case DMA_IO_TO_MEMORY:
		if (dma_setup_data ->Channel == DTC_INTERRUPT_CH) {
			dma_setup.SrcAddress = MDM_RX_ADDRESS;
		}
		else if (dma_setup_data ->Channel == DTC_INTERRUPT_CH2) {
			dma_setup.SrcAddress = RS_ADDRESS;
		}
		dma_setup.DstAddress = dma_setup_data -> SrcAddress;
		break;
	case DMA_MEMORY_TO_IO:
		dma_setup.SrcAddress = dma_setup_data -> SrcAddress;
		if (dma_setup_data ->Channel == DTC_INTERRUPT_CH) {
			dma_setup.DstAddress = MDM_TX_ADDRESS;
		}
		else if (dma_setup_data ->Channel == DTC_INTERRUPT_CH2) {
			dma_setup.DstAddress = RS_ADDRESS;
		}
		break;
	default:
		SaveReturnAddressAndJumpBegin();
	}
#endif /* (PRO_MODEM == R288F) */
	DMA_SetupDTC(&dma_setup);
	/* DMAtoDTC_RequsetEnable()でセットする */
	/* DMA_DTC_TransferStart(dma_setup.DTC_Mode); */
}

/*************************************************************************
	module		:[ＤＭＡのｾｯﾄｱｯﾌﾟ時の変数からDTC用の変数に変換して
				SH7043内蔵DTCのセットアップを再起動]
	function	:[
		1.ＤＴＣレジスタ情報をセットアップします
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1997/07/08]
	author		:[山口 哲治]
*************************************************************************/
void DMAtoDTC_Restart(UBYTE dtc_mode,		/* DMAチャンネル */
					  UBYTE direction,	/* DMA転送方向 */
					  UWORD count,		/* DMA転送回数 */
					  UDWORD address)	/* DMAアドレス */
{
#if (PRO_MODEM == ORANGE3) /* #if is added by H.Kubo 1997/10/09 */
	switch (dtc_mode) {
	case DTC_INTERRUPT_CH:
		/* カウントレジスタ情報の設定 */
		DTC_INT_NORMAL.DTCRA_Status = count;

		/* 転送元アドレスレジスタ情報の設定 */
		/* 転送先アドレスレジスタ情報の設定 */
		switch (direction) {
		case DMA_IO_TO_MEMORY:
			DTC_INT_NORMAL.DTSAR_Status = MDM_ADDRESS;
			DTC_INT_NORMAL.DTDAR_Status = address;
			break;
		case DMA_MEMORY_TO_IO:
			DTC_INT_NORMAL.DTSAR_Status = address;
			DTC_INT_NORMAL.DTDAR_Status = MDM_ADDRESS;
			break;
		}
		break;
	case DTC_INTERRUPT_CH2:
		/* カウントレジスタ情報の設定 */
		DTC_INT_NORMAL2.DTCRA_Status = count;

		/* 転送元アドレスレジスタ情報の設定 */
		/* 転送先アドレスレジスタ情報の設定 */
		switch (direction) {
		case DMA_IO_TO_MEMORY:
			DTC_INT_NORMAL2.DTSAR_Status = RS_ADDRESS;
			DTC_INT_NORMAL2.DTDAR_Status = address;
			break;
		case DMA_MEMORY_TO_IO:
			DTC_INT_NORMAL2.DTSAR_Status = address;
			DTC_INT_NORMAL2.DTDAR_Status = RS_ADDRESS;
			break;
		}
		break;
	case DTC_NORMAL_MODE:
	case DTC_BLOCK_MODE:
	case DTC_REPEAT_MODE:
	default:
		break;
	}
#endif /* (PRO_MODEM == ORANGE3)  */
#if (PRO_MODEM == R288F) /* added by H.Kubo 1997/10/09 */
	/* POPLAR_H では外付 DMAC があるため、モデムのデータ転送に DTC は
	** 使わないが、念のため入れておく。
	*/
	switch (dtc_mode) {
	case DTC_INTERRUPT_CH:
		/* カウントレジスタ情報の設定 */
		DTC_INT_NORMAL.DTCRA_Status = count;

		/* 転送元アドレスレジスタ情報の設定 */
		/* 転送先アドレスレジスタ情報の設定 */
		switch (direction) {
		case DMA_IO_TO_MEMORY:
			DTC_INT_NORMAL.DTSAR_Status = MDM_RX_ADDRESS;
			DTC_INT_NORMAL.DTDAR_Status = address;
			break;
		case DMA_MEMORY_TO_IO:
			DTC_INT_NORMAL.DTSAR_Status = address;
			DTC_INT_NORMAL.DTDAR_Status = MDM_TX_ADDRESS;
			break;
		}
		break;
	case DTC_INTERRUPT_CH2:
		/* カウントレジスタ情報の設定 */
		DTC_INT_NORMAL2.DTCRA_Status = count;

		/* 転送元アドレスレジスタ情報の設定 */
		/* 転送先アドレスレジスタ情報の設定 */
		switch (direction) {
		case DMA_IO_TO_MEMORY:
			DTC_INT_NORMAL2.DTSAR_Status = RS_ADDRESS;
			DTC_INT_NORMAL2.DTDAR_Status = address;
			break;
		case DMA_MEMORY_TO_IO:
			DTC_INT_NORMAL2.DTSAR_Status = address;
			DTC_INT_NORMAL2.DTDAR_Status = RS_ADDRESS;
			break;
		}
		break;
	case DTC_NORMAL_MODE:
	case DTC_BLOCK_MODE:
	case DTC_REPEAT_MODE:
	default:
		break;
	}
#endif /* (PRO_MODEM == R288F) */
	DMA_DTC_TransferStart(dtc_mode);
}

/*************************************************************************
	module		:[ＤＭＡのリクエストをマスクします]
	function	:[
		1.ＤＴＣの割り込みレベルレジスタ
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1997/07/08]
	author		:[山口 哲治]
*************************************************************************/
void DMAtoDTC_RequestMask(UBYTE dtc_mode)
{
	switch (dtc_mode) {
	case DTC_INTERRUPT_CH:
#if 0	/* 1997/12/14 */
	/* 先にＤＴＣを無効にしてしまうとＤＲＥＱがＴＣになって誤動作するかもしれない */
		SH__DTEC &= ~IREQ5_ENABLE;
		SH__IPRB &= ~IRQ5_LEVEL;		/* IRQ5マスク 1997/08/05  By T.Yamaguchi */
#endif
		SH__IPRB &= ~IRQ5_LEVEL;		/* IRQ5マスク 1997/08/05  By T.Yamaguchi */
		SH__DTEC &= ~IREQ5_ENABLE;
		break;
	case DTC_BLOCK_MODE:
		if (SH__DTCSR == (DTCSR_SWDTE | 0x42)) {
			SH__DTCSR &= ~DTCSR_SWDTE;
		}
		break;
	case DTC_NORMAL_MODE:
		if (SH__DTCSR == (DTCSR_SWDTE | 0x44)) {
			SH__DTCSR &= ~DTCSR_SWDTE;
		}
		break;
	case DTC_REPEAT_MODE:
		if (SH__DTCSR == (DTCSR_SWDTE | 0x46)) {
			SH__DTCSR &= ~DTCSR_SWDTE;
		}
		break;
	case DTC_INTERRUPT_CH2:
#if 0	/* 1997/12/14 Y.M */
		SH__DTED &= ~IREQ6_ENABLE;
		SH__IPRB &= ~IRQ6_LEVEL;		/* IRQ6マスク 1997/08/05  By T.Yamaguchi */
#endif
		SH__IPRB &= ~IRQ6_LEVEL;		/* IRQ6マスク 1997/08/05  By T.Yamaguchi */
		SH__DTED &= ~IREQ6_ENABLE;
		break;
	default:
		break;
	}
}

/*************************************************************************
	module		:[SH7043内蔵DTCの起動を許可する]
	function	:[
		1.ＤＴＣレジスタイネーブルビットを許可します
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1997/07/08]
	author		:[山口 哲治]
*************************************************************************/
void DMAtoDTC_RequestEnable(UBYTE dtc_mode)
{
	switch (dtc_mode) {
	case DTC_INTERRUPT_CH:
		SH__DTEC |= IREQ5_ENABLE;	/* スタート */
		SH__IPRB |= IRQ5_LEVEL;		/* IRQ5マスク解除 1997/08/05  By T.Yamaguchi */
		break;
	case DTC_BLOCK_MODE:
		/* 許可 */
		break;
	case DTC_NORMAL_MODE:
		/* 許可 */
		break;
	case DTC_REPEAT_MODE:
		/* 許可 */
		break;
	case DTC_INTERRUPT_CH2:
		SH__DTED |= IREQ6_ENABLE;	/* スタート */
		SH__IPRB |= IRQ6_LEVEL;		/* IRQ6マスク解除 1997/08/05  By T.Yamaguchi */
		break;
	default:
		break;
	}
}

/*************************************************************************
	module		:[DTC設定のパラメターを初期化する
				]
	function	:[
		1.
	]
	return		:[無し]
	common		:[]
	condition	:[]
	comment		:[]
	machine		:[SH7043]
	language	:[SHC]
	keyword		:[DMA]
	date		:[1997/07/08]
	author		:[山口 哲治]
*************************************************************************/
void DMA_DTC_Initialize(void)
{
	/* DTC転送カウンタの値を０に初期化しておく */
	DTC_INT_NORMAL.DTCRA_Status = 0;
	DTC_BLOCK.DTCRA_Status = 0;
	DTC_NORMAL.DTCRA_Status = 0;
	DTC_REPEAT.DTCRA_Status = 0;
	DTC_INT_NORMAL2.DTCRA_Status = 0;
}

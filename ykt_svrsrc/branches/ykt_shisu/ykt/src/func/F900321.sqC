/* ----------------------------------------------------------
 * 程序名称：F900321.sqc
 * 创建日期：2009-05-13
 * 程序作者：XiaoYang.Lee
 * 版本信息：1.0.0.0
 * 程序功能：重新设计的系统运行情况总表
 			 能动态的添加各种收费选项
 * ----------------------------------------------------------
*/
#define _IN_SQC_                                  
ESQL #include <string.h>                               
ESQL #include <stdio.h>    
ESQL #include "errdef.h"  
ESQL #include "pubdb.h"  
ESQL #include "pubfunc.h"      
ESQL #include "fdsqc.h"              
ESQL #include "dbfunc.h"
ESQL #include "dbfunc_foo.h"

static int create_user_query(char *querylist, char *tempsql);

static int create_user_query(char * querylist, char * tempsql)
{
	char tmp_query_list[255]="";
	char tmpvalues[10]="";
	char *pch;
	int flag=0;
	strcpy(tmp_query_list,querylist);

	pch = strtok(tmp_query_list," ");
	strcat(tempsql,"and t.OPER_CODE in (");
	while(pch != NULL)
	{	
		if(flag) strcat(tempsql,",");
		sprintf(tmpvalues,"'%s'",pch);
		strcat(tempsql,tmpvalues);
		flag=1;
		pch=strtok(NULL," ");
	}
	strcat(tempsql,")");
	return 0;
}


int F900321(TRUSERID *handle,int iRequest,ST_PACK *in_pack,int *pRetCode,char *szMsg)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char out_oper_code[20]="";
	char out_subno[20] = "";
	char out_serieal_type[20]="";
	sqlint32 TradeCount=0;
	double out_DEBIT_AMT = 0;
	double out_CREDIT_AMT=0;
	double out_surplus=0;
	char h_sqlcmd[2048]="";
	sqlint16 indr=0;
	EXEC SQL END DECLARE SECTION;
	char h_tmpsql[1024]="";
	int ret=0;
	int counts=0;		
	ST_CPACK aPack;
	ST_PACK *out_pack= &(aPack.pack);

	ResetNormalCPack(&aPack,0,1);
	SetCol(handle,0);
	SetCol(handle,F_SCUST_AUTH,F_SCUST_LIMIT,F_SCUST_AUTH2,F_DAMT0,F_LVOL1,F_DAMT1,F_DAMT2,0);
	
	sprintf(h_sqlcmd,"select x.oper_name,s.subname,k.trademsg,sum(t.debit_count+credit_count),sum(t.credit_amt),sum(t.debit_amt),sum(t.credit_amt-t.debit_amt) \
						from ykt_cur.t_tif_report_oper_statistics t left join ykt_cur.t_pif_operator x on t.oper_code=x.oper_code \
						left join ykt_cur.t_tif_subject s on t.subno=s.subno left join ykt_cur.t_pif_tradecode k on t.serial_type=k.tradecode where 1=1 and s.subtype=1");

	if(strlen(in_pack->vsmess))
	{
		memset(h_tmpsql,0,sizeof(h_tmpsql));
		create_user_query(in_pack->vsmess,h_tmpsql);
		strcat(h_sqlcmd,h_tmpsql);
	}

	if(strlen(in_pack->sdate0))
	{
		sprintf(h_tmpsql," and BALANCE_DATE >= '%s' ",in_pack->sdate0);
		strcat(h_sqlcmd,h_tmpsql);
	}

	if(strlen(in_pack->sdate1))
	{
		sprintf(h_tmpsql," and BALANCE_DATE<='%s' ",in_pack->sdate1);
		strcat(h_sqlcmd,h_tmpsql);
	}


	writelog(LOG_ERR,"ERROR_SQL=[%s]",h_sqlcmd);
	strcat(h_sqlcmd,"group by x.oper_name,s.subname,k.trademsg order by x.oper_name,s.subname,k.trademsg");
	
	EXEC SQL PREPARE stmt FROM :h_sqlcmd;
	if(SQLCODE)
	{
		db_chk_err(__FILE__,__LINE__,&sqlca);
		*pRetCode=E_DB_SYS_STATISTICS_SQL_ERR;
		 return -1;
	}

	EXEC SQL DECLARE ds CURSOR FOR stmt;
	if(SQLCODE)
	{
		db_chk_err(__FILE__,__LINE__,&sqlca);
		*pRetCode=E_DB_SYS_STATISTICS_SQL_ERR;
		return -1;
	}

	EXEC SQL OPEN ds;
	if(SQLCODE)
	{	
		db_chk_err(__FILE__,__LINE__,&sqlca);
		*pRetCode=E_DB_SYS_STATISTICS_SQL_ERR;
		 return -1;
	}

	while(1)
	{
		memset(out_oper_code,0,sizeof(out_oper_code));
		memset(out_serieal_type,0,sizeof(out_serieal_type));
		memset(out_subno,0,sizeof(out_subno));
		TradeCount=0;
		out_DEBIT_AMT=0;
		out_CREDIT_AMT=0;
		out_surplus=0;

		EXEC SQL FETCH ds INTO
			:out_oper_code:indr,
			:out_subno:indr,
			:out_serieal_type:indr,
			:TradeCount:indr,
			:out_CREDIT_AMT:indr,
			:out_DEBIT_AMT:indr,
			:out_surplus:indr;
		if(SQLCODE)
		{
			ret=SQLCODE;
			db_chk_err(__FILE__,__LINE__,&sqlca);
			EXEC SQL CLOSE ds;
			if(ret==DB_NOTFOUND)
			{
				if(counts)
					break;
				else
					*pRetCode=E_DB_SYS_STATISTICS_NOTFOUND_DATA;
				return E_DB_SYS_STATISTICS_NOTFOUND_DATA;
			}
			*pRetCode=E_DB_SYS_STATISTICS_SQL_ERR;
			return -1;
		}

		strcpy(out_pack->scust_auth,out_oper_code);
		strcpy(out_pack->scust_limit,out_serieal_type);
		strcpy(out_pack->scust_auth2,out_subno);
		out_pack->damt0=out_DEBIT_AMT;
		out_pack->lvol1=TradeCount;
		out_pack->damt1=out_CREDIT_AMT;
		out_pack->damt2=out_surplus;
		PutRow(handle,out_pack,pRetCode,szMsg);
		counts++;
	}
	AnswerData(handle,*pRetCode,szMsg);
	return 0;
}

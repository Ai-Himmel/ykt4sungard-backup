unit KCDataPack;

{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 1999 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      FINAL DELPHI-JEDI COMMANDLINE EDITION                               }
{                                                                          }
{    Generated Date:  2001-6-21                                            }
{    Generated Time: 15:10:47                                              }
{                                                                          }
{**************************************************************************}

{-创建日期： 2001/6/12 }
{-作者： 史光伟 }
{-版本信息： V1.0.2 }
{-功能： }
{-正式的包结构/压包解包 }
{-和1.0.1版本的区别： }
{-1.0.1版本使用的是旧的格式的pack结构， }
{-1.0.2版本用的是讨论过后的新的pack结构 }
{-------------------------------------------------------------------------- }

{-修改日期： 2001/6/12 }
{-修改人： 史光伟 }
{-修改描述： 建立了cpack结构 }

// modified by Huang Yanlai

interface

uses Windows,Dialogs;

{=> CPACK.H <=}

const
  MAXPACKAGESIZE = 32 * 1024;
  PARAMBITS = 256;
  BITSPERBYTE = 8;
  ParamBitsSize = PARAMBITS div BITSPERBYTE;
  // log category
  lcKCPack = 7;
  lcKCPackDetail = 13;
  VarCharMaxLen = 256;

type
  TSTADDR = array[0..5] of Byte;
  TSTParamBits = array[0..ParamBitsSize - 1] of Byte;

  TSTCookie = packed record
    UserID: LongWord; {= 请求者的ID号码 }
    (*
    hostname: LongWord;   {= 主机名 }
    queuename: LongWord;  {= 队列名 }
    *)
    hostname: array[0..33 - 1] of Char; {= 主机名 }
    queuename: array[0..33 - 1] of Char; {= 队列名 }
    queuetype: LongWord; {= 队列类型 }
  end;

  TSTDataHead = packed record
    RequestType: LongWord; // 交易编码，4字节
    FirstFlag: Byte; // 是否第一个请求（首包请求）
    NextFlag: Byte; // 是否后续包请求
    RecCount: LongWord; // 本包的记录数
    RetCode: LongWord; // 返回代码
    Addr: TSTADDR; // 请求着的地址（6个子节）
    Cookie: TSTCookie;
    userdata: LongWord;
    ParamBits: TSTParamBits;
  end;
  PSTDataHead = ^TSTDataHead;

  TSTPack = packed record
    scust_no: array[0..11 - 1] of Char; {=1 客户号 }
    scust_no2: array[0..11 - 1] of Char; {= 第二客户号 }
    sholder_ac_no: array[0..16 - 1] of Char; {= 股东代码 }
    sholder_ac_no2: array[0..16 - 1] of Char; {= 第二股东代码 }
    sholder_type: array[0..3 - 1] of Char; {= 股东代码类别 }
    sholder_type2: array[0..3 - 1] of Char; {= 第二股东代码类别 }
    sname: array[0..21 - 1] of Char; {= 姓名 }
    sname2: array[0..21 - 1] of Char; {= 第二姓名 }

    sall_name: array[0..81 - 1] of Char; {=2 全名 }
    smarket_code: array[0..2 - 1] of Char; {= 市场代码 }
    smarket_code2: array[0..2 - 1] of Char; {= 市场代码2 }
    sdate0: array[0..9 - 1] of Char; {= 日期 委托日期 }
    sdate1: array[0..9 - 1] of Char; {= 日期 成交日期 }
    sdate2: array[0..9 - 1] of Char; {= 日期 报盘日期 }
    sdate3: array[0..9 - 1] of Char; {= 日期 发生日期 }
    stime0: array[0..9 - 1] of Char; {= 时间 委托时间 }

    stime1: array[0..9 - 1] of Char; {=3 时间 成交时间 }
    stime2: array[0..9 - 1] of Char; {= 时间 包盘时间 }
    stime3: array[0..9 - 1] of Char; {= 时间 发生时间 }
    lvol0: LongInt; {= 数量0 委托数量 买量1 }
    lvol1: LongInt; {= 数量1 成交数量 买量2 }
    lvol2: LongInt; {= 数量2 可用数量 买量3 }
    lvol3: LongInt; {= 数量3 手工冻结数量 买量4 }
    lvol4: LongInt; {= 数量4 委托冻结数量 卖量1 }

    lvol5: LongInt; {=4 数量5 买入成交数量 卖量2 }
    lvol6: LongInt; {= 数量6 卖出成交数量 卖量3 }
    lvol7: LongInt; {= 数量7 清算后余额 卖量4 }
    lvol8: LongInt; {= 数量8 手工解冻数量 }
    lvol9: LongInt; {= 数量9 存入数量 }
    lvol10: LongInt; {= 数量10 取出数量 }
    lvol11: LongInt; {= 数量11 买入未过户数量 }
    lvol12: LongInt; {= 数量12 卖出未过户数量 }

    damt0: Double; {=5 金额0 委托价格 }
    damt1: Double; {= 金额1 委托金额 }
    damt2: Double; {= 金额2 成交价格 }
    damt3: Double; {= 金额3 成交金额 }
    damt4: Double; {= 金额4 清算后余额 }
    damt5: Double; {= 金额5 存入金额 }
    damt6: Double; {= 金额6 取出金额 }
    damt7: Double; {= 金额7 现金金额 }

    damt8: Double; {=6 金额8 支汇票金额 }
    damt9: Double; {= 金额9 异常冻结金额 }
    damt10: Double; {= 金额10 买入冻结金额 }
    damt11: Double; {= 金额11 卖出冻结金额 }
    damt12: Double; {= 金额12 买入成交金额 }
    damt13: Double; {= 金额13 卖出成交金额 }
    damt14: Double; {= 金额14 手工冻结金额 }
    damt15: Double; {= 金额15 手工解冻金额 }

    damt16: Double; {=7 金额16 贷款金额 }
    damt17: Double; {= 金额17 发生金额 }
    damt18: Double; {= 金额18 买入未过户金额 }
    damt19: Double; {= 金额19 卖出未过户金额 }
    damt20: Double; {= 金额20 利息积数 }
    damt21: Double; {= 金额21 罚息积数 }
    damt22: Double; {= 金额22 贷款利息9积数 }
    damt23: Double; {= 金额23 信用金额 }

    damt24: Double; {=8 金额24 禁用资金 }
    damt25: Double; {= 金额25 禁取资金 }
    damt26: Double; {= 金额26 利息 }
    damt27: Double; {= 金额27 罚息 }
    damt28: Double; {= 金额28 贷款利息 }
    damt29: Double; {= 金额29 市值 }
    damt30: Double; {= 金额30 虚增保证金 }
    damt31: Double; {= 金额31 手续费 }

    damt32: Double; {=9 金额32 印花税 }
    damt33: Double; {= 金额33 过户费 }
    sstock_code: array[0..9 - 1] of Char; {= 证券代码 }
    sstock_code2: array[0..9 - 1] of Char; {= 证券代码2 }
    scust_type: array[0..3 - 1] of Char; {= 客户类别 }
    scust_type2: array[0..3 - 1] of Char; {= 客户类别2 }
    sstat_type: array[0..3 - 1] of Char; {= 统计类别 }
    sstat_type2: array[0..3 - 1] of Char; {= 统计类别2 }

    sroom_no: array[0..4 - 1] of Char; {=10 客户组号 }
    sroom_no2: array[0..4 - 1] of Char; {= 客户组号2 }
    sopen_emp: array[0..7 - 1] of Char; {= 职工 }
    sclose_emp: array[0..7 - 1] of Char; {= 职工 }
    schange_emp: array[0..7 - 1] of Char; {= 职工 }
    scheck_emp: array[0..7 - 1] of Char; {= 复核职工 }
    semp: array[0..7 - 1] of Char; {= 职工 }
    snation_code: array[0..4 - 1] of Char; {= 国籍代码 }

    lcert_code: LongInt; {=11 证件类别 }
    stx_pwd: array[0..9 - 1] of Char; {= 交易密码 }
    stx_pwd2: array[0..9 - 1] of Char; {= 交易密码2 }
    swithdraw_pwd: array[0..9 - 1] of Char; {= 取款密码 }
    swithdraw_pwd2: array[0..9 - 1] of Char; {= 取款密码2 }
    semp_pwd: array[0..9 - 1] of Char; {= 柜员密码 }
    semp_pwd2: array[0..9 - 1] of Char; {= 柜员密码2 }
    sbank_pwd: array[0..9 - 1] of Char; {= 银行密码 }

    sbank_pwd2: array[0..9 - 1] of Char; {=12 银行密码2 }
    scust_auth: array[0..21 - 1] of Char; {= 客户权限 }
    scust_auth2: array[0..21 - 1] of Char; {= 客户权限2 }
    scust_limit: array[0..33 - 1] of Char; {= 客户限制 }
    scust_limit2: array[0..33 - 1] of Char; {= 客户限制2 }
    lsafe_level: LongInt; {= 安全级别 }
    lsafe_level2: LongInt; {= 安全级别2 }
    spost_code: array[0..7 - 1] of Char; {= 邮政编码 }

    spost_code2: array[0..7 - 1] of Char; {=13 邮政编码2 }
    sphone: array[0..31 - 1] of Char; {= 联系电话 }
    sphone2: array[0..31 - 1] of Char; {= fax }
    sphone3: array[0..31 - 1] of Char; {= 移动电话 }
    spager: array[0..31 - 1] of Char; {= 传呼 }
    semail: array[0..61 - 1] of Char; {= email }
    semail2: array[0..61 - 1] of Char; {= email2 }
    snote: array[0..81 - 1] of Char; {= 备注 }

    snote2: array[0..81 - 1] of Char; {=14 备注2 }
    scert_no: array[0..51 - 1] of Char; {= 身份证号码 }
    scert_no2: array[0..51 - 1] of Char; {= 身份证号码2 }
    scert_addr: array[0..81 - 1] of Char; {= 身份证地址 }
    sstatus0: array[0..2 - 1] of Char; {= 状态，客户状态 }
    sstatus1: array[0..2 - 1] of Char; {= 状态1 }
    sstatus2: array[0..2 - 1] of Char; {= 状态2 }
    sstatus3: array[0..2 - 1] of Char; {= 状态3 }

    sstatus4: array[0..2 - 1] of Char; {=15 状态4 }
    lwithdraw_flag: LongInt; {= 提款方式 }
    saddr: array[0..81 - 1] of Char; {= 联系地址 }
    saddr2: array[0..81 - 1] of Char; {= 联系地址2 }
    sserial0: array[0..13 - 1] of Char; {= 序号0 }
    sserial1: array[0..13 - 1] of Char; {= 序号1 }
    sserial2: array[0..13 - 1] of Char; {= 序号2 }
    sserial3: array[0..13 - 1] of Char; {= 序号3 }

    sserial4: array[0..13 - 1] of Char; {=16 序号4 }
    scurrency_type: array[0..3 - 1] of Char; {= 货币类型 }
    scurrency_type2: array[0..3 - 1] of Char; {= 货币类型2 }
    sbranch_code0: array[0..4 - 1] of Char; {= 开户营业部号码 }
    sbranch_code1: array[0..4 - 1] of Char; {= 发生营业部号码 }
    sbranch_code2: array[0..4 - 1] of Char; {= 营业部号码2 }
    usset0: array[0..100 - 1] of Byte; {= 管理权限集合 }
    usset1: array[0..100 - 1] of Byte; {= 授权权限集合 }

    usset2: array[0..100 - 1] of Byte; {=17 操作权限集合 }
    usset3: array[0..100 - 1] of Byte; {= 菜单权限集合 }
    usset4: array[0..100 - 1] of Byte; {= 岗位集合 }
    usset5: array[0..100 - 1] of Byte; {= 市场集合 }
    usset6: array[0..100 - 1] of Byte; {= 货币集合 }
    sstation0: array[0..17 - 1] of Char; {= 工作站地址 }
    sstation1: array[0..17 - 1] of Char; {= 工作站地址2 }
    sbank_acc: array[0..41 - 1] of Char; {= 银行账号 }

    sbank_acc2: array[0..41 - 1] of Char; {=18 银行账号2 }
    lbank_acc_type: LongInt; {= 银行账号类别 }
    lbank_acc_type2: LongInt; {= 银行账号类别2 }
    smain_flag: array[0..2 - 1] of Char; {= 主副标志 }
    smain_flag2: array[0..2 - 1] of Char; {= 主副标志 }
    sbank_code: array[0..7 - 1] of Char; {= 银行代码 }
    sbank_code2: array[0..7 - 1] of Char; {= 银行代码2 }
    semp_no: array[0..9 - 1] of Char; {= 工号 }

    semp_no2: array[0..9 - 1] of Char; {=19 工号2 }
    drate0: Double; {= 比率 }
    drate1: Double; {= 比率1 }
    lserial0: LongInt; {= 序列号 0 }
    lserial1: LongInt; {= 序列号 1 }
    sbankname: array[0..81 - 1] of Char; {= 银行名称 }
    sbankname2: array[0..81 - 1] of Char; {= 银行名称2 }
    scard0: array[0..51 - 1] of Char; {= 磁卡号码 }

    scard1: array[0..51 - 1] of Char; {=20 磁卡号码 }
    sorder0: array[0..11 - 1] of Char; {= 合同序号 }
    sorder1: array[0..11 - 1] of Char; {= 合同序号 }
    sorder2: array[0..11 - 1] of Char; {= 合同序号 }
    scusttypes: array[0..201 - 1] of Char; {= 客户类别集合 }
    ssectypes: array[0..201 - 1] of Char; {= 证券类别集合 }

    vsmess: array[0..VarCharMaxLen - 1] of Char; {= 23 信息 }
    vsvarstr0: array[0..VarCharMaxLen - 1] of Char; {= 变长的字符串 }
    vsvarstr1: array[0..VarCharMaxLen - 1] of Char; {= 变长的字符串 }
    vsvarstr2: array[0..VarCharMaxLen - 1] of Char; {= 变长的字符串 }
    vsvarstr3: array[0..VarCharMaxLen - 1] of Char; {= 变长的字符串 }
  end;
  PSTPack = ^TSTPack;

  TKCType = (kcEmpty, kcChar, kcInteger, kcFloat, kcVarChar, kcBit);

  // 压缩数据，返回压缩以后的大小byte
function KCPackData(const ParamBits: TSTParamBits; const Data: TSTPack; Buffer:
  PByte): Integer;

// 解压缩数据，返回压缩的大小byte
function KCUnPackData(const ParamBits: TSTParamBits; var Data: TSTPack; Buffer:
  PByte): Integer;

procedure KCCheckDefine;

procedure KCClearParamBits(var ParamBits: TSTParamBits);

procedure KCPutStr(var CharArray; Size: Integer; const S: string);

function KCGetStr(const CharArray; Size: Integer): string;

procedure KCDumpParamBits(const ParamBits: TSTParamBits);

procedure KCDumpPack(const Pack: TSTPack);

function KCFindParam(const Name: string): Integer;

function UnpackBits2Chars(BitsBuffer: PByte; BitsBufferSize: Integer;
  CharsBuffer: PChar; CharsBufferSize: Integer): Integer;

procedure PackChars2Bits(CharsBuffer: PChar; CharsBufferSize: Integer;
  BitsBuffer: PByte; BitsBufferSize: Integer);

const
  KCPackDataSizes: array[0..PARAMBITS - 1] of Word =
  (
    // 0
    11,
    11,
    16,
    16,
    3,
    3,
    21,
    21,

    // 1
    81,
    2,
    2,
    9,
    9,
    9,
    9,
    9,

    // 2
    9,
    9,
    9,
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),

    // 3
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),
    SizeOf(LongInt),

    // 4
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),

    // 5
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),

    // 6
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),

    // 7
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(Double),

    // 8
    SizeOf(Double),
    SizeOf(Double),
    9,
    9,
    3,
    3,
    3,
    3,

    // 9
    4,
    4,
    7,
    7,
    7,
    7,
    7,
    4,

    // 10
    SizeOf(LongInt),
    9,
    9,
    9,
    9,
    9,
    9,
    9,

    // 11
    9,
    21,
    21,
    33,
    33,
    SizeOf(LongInt),
    SizeOf(LongInt),
    7,

    // 12
    7,
    31,
    31,
    31,
    31,
    61,
    61,
    81,

    // 13
    81,
    51,
    51,
    81,
    2,
    2,
    2,
    2,

    // 14
    2,
    SizeOf(LongInt),
    81,
    81,
    13,
    13,
    13,
    13,

    // 15
    13,
    3,
    3,
    4,
    4,
    4,
    100,
    100,

    // 16
    100,
    100,
    100,
    100,
    100,
    17,
    17,
    41,

    // 17
    41,
    SizeOf(LongInt),
    SizeOf(LongInt),
    2,
    2,
    7,
    7,
    9,

    // 18
    9,
    SizeOf(Double),
    SizeOf(Double),
    SizeOf(LongInt),
    SizeOf(LongInt),
    81,
    81,
    51,

    // 19
    51,
    11,
    11,
    11,
    201,
    201,
    0,
    0,

    // 20
    0, 0, 0, 0, 0, 0, 0, 0,

    // 21
    0, 0, 0, 0, 0, 0, 0, 0,

    // 22
    VarCharMaxLen,
    VarCharMaxLen,
    VarCharMaxLen,
    VarCharMaxLen,
    VarCharMaxLen,
    0,
    0,
    0,

    // 23
    0, 0, 0, 0, 0, 0, 0, 0,
    // 24
    0, 0, 0, 0, 0, 0, 0, 0,
    // 25
    0, 0, 0, 0, 0, 0, 0, 0,
    // 26
    0, 0, 0, 0, 0, 0, 0, 0,
    // 27
    0, 0, 0, 0, 0, 0, 0, 0,
    // 28
    0, 0, 0, 0, 0, 0, 0, 0,
    // 29
    0, 0, 0, 0, 0, 0, 0, 0,
    // 30
    0, 0, 0, 0, 0, 0, 0, 0,
    // 31
    0, 0, 0, 0, 0, 0, 0, 0
    );

  KCPackDataTypes: array[0..PARAMBITS - 1] of TKCType =
  (
    // 0
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 1
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 2
    kcChar,
    kcChar,
    kcChar,
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,

    // 3
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,
    kcInteger,

    // 4
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,

    // 5
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,

    // 6
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,

    // 7
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,
    kcFloat,

    // 8
    kcFloat,
    kcFloat,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 9
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 10
    kcInteger,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 11
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcInteger,
    kcInteger,
    kcChar,

    // 12
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 13
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 14
    kcChar,
    kcInteger,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 15
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcBit,
    kcBit,

    // 16
    kcBit,
    kcBit,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 17
    kcChar,
    kcInteger,
    kcInteger,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,

    // 18
    kcChar,
    kcFloat,
    kcFloat,
    kcInteger,
    kcInteger,
    kcChar,
    kcChar,
    kcChar,

    // 19
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcChar,
    kcEmpty,
    kcEmpty,

    // 20
    kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty,
    // 21
    kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty,

    // 22
    kcVarChar,
    kcVarChar,
    kcVarChar,
    kcVarChar,
    kcVarChar,
    kcEmpty,
    kcEmpty,
    kcEmpty,

    // 23
    kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty,
    // 24
    kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty,
    // 25
    kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty,
    // 26
    kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty,
    // 27
    kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty,
    // 28
    kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty,
    // 29
    kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty,
    // 30
    kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty,
    // 31
    kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty, kcEmpty
    );

  KCPackDataNames: array[0..PARAMBITS - 1] of string =
  (
    // 0
    'scust_no',
    'scust_no2',
    'sholder_ac_no',
    'sholder_ac_no2',
    'sholder_type',
    'sholder_type2',
    'sname',
    'sname2',

    // 1
    'sall_name',
    'smarket_code',
    'smarket_code2',
    'sdate0',
    'sdate1',
    'sdate2',
    'sdate3',
    'stime0',

    // 2
    'stime1',
    'stime2',
    'stime3',
    'lvol0',
    'lvol1',
    'lvol2',
    'lvol3',
    'lvol4',

    // 3
    'lvol5',
    'lvol6',
    'lvol7',
    'lvol8',
    'lvol9',
    'lvol10',
    'lvol11',
    'lvol12',

    // 4
    'damt0',
    'damt1',
    'damt2',
    'damt3',
    'damt4',
    'damt5',
    'damt6',
    'damt7',

    // 5
    'damt8',
    'damt9',
    'damt10',
    'damt11',
    'damt12',
    'damt13',
    'damt14',
    'damt15',

    // 6
    'damt16',
    'damt17',
    'damt18',
    'damt19',
    'damt20',
    'damt21',
    'damt22',
    'damt23',

    // 7
    'damt24',
    'damt25',
    'damt26',
    'damt27',
    'damt28',
    'damt29',
    'damt30',
    'damt31',

    // 8
    'damt32',
    'damt33',
    'sstock_code',
    'sstock_code2',
    'scust_type',
    'scust_type2',
    'sstat_type',
    'sstat_type2',

    // 9
    'sroom_no',
    'sroom_no2',
    'sopen_emp',
    'sclose_emp',
    'schange_emp',
    'scheck_emp',
    'semp',
    'snation_code',

    // 10
    'lcert_code',
    'stx_pwd',
    'stx_pwd2',
    'swithdraw_pwd',
    'swithdraw_pwd2',
    'semp_pwd',
    'semp_pwd2',
    'sbank_pwd',

    // 11
    'sbank_pwd2',
    'scust_auth',
    'scust_auth2',
    'scust_limit',
    'scust_limit2',
    'lsafe_level',
    'lsafe_level2',
    'spost_code',

    // 12
    'spost_code2',
    'sphone',
    'sphone2',
    'sphone3',
    'spager',
    'semail',
    'semail2',
    'snote',

    // 13
    'snote2',
    'scert_no',
    'scert_no2',
    'scert_addr',
    'sstatus0',
    'sstatus1',
    'sstatus2',
    'sstatus3',

    // 14
    'sstatus4',
    'lwithdraw_flag',
    'saddr',
    'saddr2',
    'sserial0',
    'sserial1',
    'sserial2',
    'sserial3',

    // 15
    'sserial4',
    'scurrency_type',
    'scurrency_type2',
    'sbranch_code0',
    'sbranch_code1',
    'sbranch_code2',
    'usset0',
    'usset1',

    // 16
    'usset2',
    'usset3',
    'usset4',
    'usset5',
    'usset6',
    'sstation0',
    'sstation1',
    'sbank_acc',

    // 17
    'sbank_acc2',
    'lbank_acc_type',
    'lbank_acc_type2',
    'smain_flag',
    'smain_flag2',
    'sbank_code',
    'sbank_code2',
    'semp_no',

    // 18
    'semp_no2',
    'drate0',
    'drate1',
    'lserial0',
    'lserial1',
    'sbankname',
    'sbankname2',
    'scard0',

    // 19
    'scard1',
    'sorder0',
    'sorder1',
    'sorder2',
    'scusttypes',
    'ssectypes',
    '', '',

    // 20
    '', '', '', '', '', '', '', '',
    // 21
    '', '', '', '', '', '', '', '',

    // 22
    'vsmess',
    'vsvarstr0',
    'vsvarstr1',
    'vsvarstr2',
    'vsvarstr3',
    '', '', '',

    // 23
    '', '', '', '', '', '', '', '',
    // 24
    '', '', '', '', '', '', '', '',
    // 25
    '', '', '', '', '', '', '', '',
    // 26
    '', '', '', '', '', '', '', '',
    // 27
    '', '', '', '', '', '', '', '',
    // 28
    '', '', '', '', '', '', '', '',
    // 29
    '', '', '', '', '', '', '', '',
    // 30
    '', '', '', '', '', '', '', '',
    // 31
    '', '', '', '', '', '', '', ''
    );

implementation

uses SysUtils, LogFile;

// 压缩数据，返回压缩以后的大小byte

function KCPackData(const ParamBits: TSTParamBits; const Data: TSTPack; Buffer:
  PByte): Integer;
var
  I, J: Integer;
  Mask: Byte;
  Count: Integer;
  PData: PByte;
  ASize: Integer;
  DataSizeInBuffer: Smallint;
begin
  PData := PByte(@Data);
  Count := 0;
  Result := 0;
  for I := 0 to ParamBitsSize - 1 do
  begin
    Mask := 1;
    for J := 0 to BITSPERBYTE - 1 do
    begin
      ASize := KCPackDataSizes[Count];
      if (ParamBits[I] and Mask) <> 0 then
      begin
        Assert(KCPackDataTypes[Count] <> kcEmpty);
        if KCPackDataTypes[Count] = kcVarChar then
        begin
          DataSizeInBuffer := StrLen(PChar(PData)); // exclude #0
          Assert(DataSizeInBuffer < ASize); // must #0 end
          // copy the size to buffer
          Inc(DataSizeInBuffer); // include #0
          Move(DataSizeInBuffer, Buffer^, SizeOf(DataSizeInBuffer));
          Inc(Buffer, SizeOf(DataSizeInBuffer));
          Inc(Result, SizeOf(DataSizeInBuffer));
          // copy data
          Move(PData^, Buffer^, DataSizeInBuffer);
        end
        else
        begin
          DataSizeInBuffer := ASize;
          Move(PData^, Buffer^, ASize);
        end;
        Inc(Buffer, DataSizeInBuffer);
        Inc(Result, DataSizeInBuffer);
      end;
      Inc(PData, ASize);
      Inc(Count);
      Mask := Mask shl 1;
    end;
  end;
end;

// 解压缩数据，返回压缩的大小byte

function KCUnPackData(const ParamBits: TSTParamBits; var Data: TSTPack; Buffer:
  PByte): Integer;
var
  I, J: Integer;
  Mask: Byte;
  Count: Integer;
  PData: PByte;
  ASize: Integer;
  DataSizeInBuffer: Smallint;
begin
  PData := PByte(@Data);
  Count := 0;
  Result := 0;
  FillChar(PData^, SizeOf(Data), 0); // 初始化
  for I := 0 to ParamBitsSize - 1 do
  begin
    Mask := 1;
    for J := 0 to BITSPERBYTE - 1 do
    begin
      ASize := KCPackDataSizes[Count];
      if (ParamBits[I] and Mask) <> 0 then
      begin
        Assert(KCPackDataTypes[Count] <> kcEmpty);
        if KCPackDataTypes[Count] = kcVarChar then
        begin
          // get the size from buffer
          Move(Buffer^, DataSizeInBuffer, SizeOf(DataSizeInBuffer));
            // include #0
          Assert((DataSizeInBuffer > 0) and (DataSizeInBuffer <= ASize));
            // must #0 end
          Inc(Buffer, SizeOf(DataSizeInBuffer));
          Inc(Result, SizeOf(DataSizeInBuffer));
          Move(Buffer^, PData^, DataSizeInBuffer);
        end
        else
        begin
          DataSizeInBuffer := ASize;
          Move(Buffer^, PData^, ASize);
        end;
        Inc(Buffer, DataSizeInBuffer);
        Inc(Result, DataSizeInBuffer);
      end;
      Inc(PData, ASize);
      Inc(Count);
      Mask := Mask shl 1;
    end;
  end;
end;

resourcestring
  AssertError = '定义的包结构错误！';

procedure KCCheckDefine;
var
  I: Integer;
  Count: Integer;
begin
  Count := 0;
  for I := 0 to PARAMBITS - 1 do
  begin
    Inc(Count, KCPackDataSizes[I]);
    if KCPackDataTypes[I] <> kcEmpty then
      Assert(KCPackDataNames[I] <> '', AssertError)
    else
      Assert(KCPackDataNames[I] = '', AssertError);
    case KCPackDataTypes[I] of
      kcEmpty: Assert(KCPackDataSizes[I] = 0, AssertError);
      kcChar, kcVarChar: Assert(KCPackDataSizes[I] > 0, AssertError);
      kcInteger: Assert((KCPackDataSizes[I] = Sizeof(LongInt)), AssertError);
      kcFloat: Assert(KCPackDataSizes[I] = SizeOf(Double), AssertError);
      kcBit: Assert(KCPackDataSizes[I] = 100, AssertError);
    else
      Assert(KCPackDataSizes[I] = 0, AssertError);
    end;
  end;
  Assert(Count = SizeOf(TSTPack), AssertError);
end;

procedure KCClearParamBits(var ParamBits: TSTParamBits);
begin
  FillChar(ParamBits, SizeOf(ParamBits), 0);
end;

procedure KCPutStr(var CharArray; Size: Integer; const S: string);
var
  CopySize: Integer;
begin
  Assert(Size > 0);
  FillChar(CharArray, Size, 0);
  if S <> '' then
  begin
    CopySize := Length(S);
    if CopySize > Size - 1 then
      // last char in CharArray is #0 , cannot be overwrite
      CopySize := Size - 1;
    Move(PChar(S)^, CharArray, CopySize);
  end;
end;

function KCGetStr(const CharArray; Size: Integer): string;
begin
  Assert(Size > 0);
  SetLength(Result, Size);
  FillChar(PChar(Result)^, Size + 1, 0);
  Move(CharArray, PChar(Result)^, Size);
  SetLength(Result, StrLen(PChar(Result)));
  { DONE : 恢复断言 }
  //Assert(Length(Result)<Size); // last char in CharArray is #0 , cannot be overwrite
end;

{$IFNDEF debug }

procedure KCDumpParamBits(const ParamBits: TSTParamBits);
begin

end;

procedure KCDumpPack(const Pack: TSTPack);
begin

end;

{$ELSE}

procedure KCDumpParamBits(const ParamBits: TSTParamBits);
var
  I, J: Integer;
  Mask: Byte;
  S: string;
begin
  WriteLog('ParamBits', lcKCPack);
  for I := 0 to ParamBitsSize - 1 do
  begin
    Mask := 1;
    S := '';
    for J := 0 to BITSPERBYTE do
    begin
      if (ParamBits[I] and Mask) <> 0 then
        S := S + '1'
      else
        S := S + '0';
      Mask := Mask shl 1;
    end;
    WriteLog(S, lcKCPack);
  end;
end;

procedure KCDumpPack(const Pack: TSTPack);
var
  I: Integer;
  PData: PByte;
  S: string;
  K: Longint;
  D: Double;
  ASize: Integer;
  pack_fld_name : string;
begin
  tmpPwd := '*********************************************************';
  WriteLog('Pack', lcKCPackDetail);
  PData := PByte(@Pack);
  for I := 0 to PARAMBITS - 1 do
  begin
    ASize := KCPackDataSizes[I];
    case KCPackDataTypes[I] of
      kcChar:
        begin
          pack_fld_name := LowerCase(KCPackDataNames[I]);
          S := KCGetStr(PData^, ASize);
          if( AnsiPos('_pwd',pack_fld_name) <> 0 )then
          begin
            WriteLog(Format('%s=%s', [KCPackDataNames[I], S]), lcKCPackDetail);
          end
          else
          begin
            S := Copy(tmpPwd,0,Length(S));
            WriteLog(Format('%s=%s',[KCPackDataNames[I],S]),lcKCPackDetail);
          end;
        end;
      kcInteger:
        begin
          K := 0;
          Move(PData^, K, ASize);
          WriteLog(Format('%s=%d', [KCPackDataNames[I], K]), lcKCPackDetail);
        end;
      kcFloat:
        begin
          D := 0;
          Move(PData^, D, ASize);
          WriteLog(Format('%s=%f', [KCPackDataNames[I], D]), lcKCPackDetail);
        end;
    end;
    Inc(PData, ASize);
  end;
end;

{$ENDIF}

function KCFindParam(const Name: string): Integer;
var
  I: Integer;
begin
  if Name <> '' then
    for I := 0 to PARAMBITS - 1 do
      if SameText(Name, KCPackDataNames[I]) then
      begin
        Result := I;
        Exit;
      end;
  Result := -1;
end;

procedure PackChars2Bits(CharsBuffer: PChar; CharsBufferSize: Integer;
  BitsBuffer: PByte; BitsBufferSize: Integer);
var
  BitsIndex, CharsIndex, I: Integer;
  Bits: Byte;
  SetBit: Byte;
begin
  FillChar(BitsBuffer^, BitsBufferSize, 0);
  CharsIndex := 0;
  for BitsIndex := 1 to BitsBufferSize do
  begin
    Bits := 0;
    for I := 1 to 8 do
    begin
      SetBit := 0;
      if CharsIndex < CharsBufferSize then
      begin
        if CharsBuffer^ = '1' then
          SetBit := 1;
        Inc(CharsBuffer);
        Inc(CharsIndex);
      end;
      Bits := (Bits shl 1) or SetBit;
    end;
    BitsBuffer^ := Bits;
    Inc(BitsBuffer);
    if CharsIndex >= CharsBufferSize then
      Break;
  end;
end;

function UnpackBits2Chars(BitsBuffer: PByte; BitsBufferSize: Integer;
  CharsBuffer: PChar; CharsBufferSize: Integer): Integer;
var
  BitsIndex, CharsIndex, I: Integer;
  Bits: Byte;
begin
  FillChar(CharsBuffer^, CharsBufferSize, Ord('0'));
  CharsIndex := 0;
  for BitsIndex := 1 to BitsBufferSize do
  begin
    Bits := BitsBuffer^;
    for I := 1 to 8 do
    begin
      if CharsIndex >= CharsBufferSize then
      begin
        Result := CharsIndex;
        Exit;
      end;
      if (Bits and $80) <> 0 then
        CharsBuffer^ := '1'
      else
        CharsBuffer^ := '0';
      Inc(CharsBuffer);
      Inc(CharsIndex);

      Bits := Bits shl 1;
    end;
    Inc(BitsBuffer);
  end;
  Result := CharsIndex;
end;

initialization
  KCCheckDefine;

end.

unit KSHQDLL;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 2003-11-14                                            }
{    Generated Time:  9:57:50                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}

const
//定义一些从配置读取的Name的约定。

  //接受方式，必填：TCP；UDP；UDPREG
  ckRevType='RevType';

  cvRevType_TCP='TCP';
  cvRevType_UDP='UDP';
  cvRevType_UDPREG='UDPREG';

  //TCP接受使用通讯平台的参数，在上面Server部分的IP，Port,以及下面的HQDestNo,HQFunc
  ckHQDestNO='HQDestNO';
  ckHQFunc='HQFunc';

  //UDP广播行情的端口
  ckUDPPort='UDPPort';

  //UDPREG方式必需：行情服务器的IP，Port以及本地接受的端口号
  ckHQIP='HQIP';
  ckHQPort='HQPort';
  //本地接受UDPREG方式行情的端口好，不要和其它应用程序重复。
  ckHqLocalPort='HqLocalPort';

  //TCP和UDPREG方式的定时向服务器注册的时间，必填，推荐15毫秒
  ckRegtimeval='Regtimeval';

  RequestType_HQ=854077;
  HQConst_TimeOut=3000;


{=> d:\期货新版030522\4编码\交易部分\kshqdll\KSHQDLL.H <=}

{+// }
{-* 从行情服务器或行情转发机获取行情的公共调用DLL }
{-* hezhenhua, 20031022, V1.1.0 }
{= }
{$IFNDEF _KSHQDLL_H}
{$DEFINE _KSHQDLL_H}

var
  HQ_Init: function(iHqWay: Integer; 
                    hWnd: THandle; 
                    iMsg: Word; 
                    strOperCode: PChar; 
                    wDestNo: Word; 
                    wMainFunc: Word;
                    strIP: PChar; 
                    wPort: Word; 
                    wLocalPort: Word; 
                    wRegtimeval: Word): BOOL  ;  stdcall;
{+// }
{-参数的取值: }
{-iHqWay：1 }
{-2 }
{-3 }

{-hWnd: }
{-iMsg： }
{-strCustNo: }
{-wDestNo: }
{-wMainFunc: }
{-strIP: }
{-wPort: }
{-wLocalPort: }

{-返回值：true }
{-false }
{-注意:如果iHqWay的值为 1: strOperCode->必填 }
{-wDestNo->行情服务器的结点号(填0即可), 必填 }
{-wMainFunc->行情服务器的主功能号(默认为666), 必填 }
{-strIP->通信平台的IP地址, 必填 }
{-wPort->通信平台的端口, 必填 }
{-wRegtimeval->定时注册的时间间隔, 必填 }
{-如果iHqWay的值为 2: strOperCode->操作员号,必填 }
{-strIP->行情服务器的IP地址, 必填 }
{-wPort->行情服务器的端口, 必填 }
{-wLocalPort->调用DLL的程序的本地端口号必填 }
{-wRegtimeval->定时注册的时间间隔, 必填 }
{-如果iHqWay的值为 3: wLocalPort->接收广播的端口号, 必填 }

{-针对不同的iHqWay的取值,必填的参数是必须确保正确的. }
{-其它不要必填的参数: 如果是数值型的,全部为0;如果是指针或字符串型的,全部为NULL }
{-广播端口号要和行情服务器或行情转发机保持一致.如无特殊变动 }
{-行情服务器和行情转发机的广播端口为27657 }
{-********************************************************************************* }
{= }


var
  HQ_GetRec: function(var buf: Byte; 
                      isize: Integer; 
                      itimeout: Integer): Integer  ;  stdcall;
{+// }
{-* 参数说明： }
{-* buf: }
{-* isize: }
{-* itimeout: }
{-* 如果itimeout = 0,当队列为空时,直接返回 }
{-* 如果itimeout > 10, 当队列为空时,会睡眠itimeout毫秒后再返回 }
{-* 如果itimeout在1~10这间,报错后返回 }
{-* }
{-* 返回值：取出的行情记录的实际的大小 }
{-* 0 行情接收队列为空 }
{-* < 0 出错 }
{-* > 0 正确，实际行情记录的大小 }
{-* }
{-* 说明:如果调用者没有单独开设线程调用本函数做接收, itimeout一定要设为 0 }
{-* 否则,每取一次记录,就会睡眠1000毫秒 }
{-**************************************************************************** }
{= }


var
  HQ_GetnRec: function(var buf: Byte; 
                       isize: Integer; 
                       var ireccount: Integer): Integer  ;  stdcall; 
{+// }
{-* 参数说明： }
{-* buf: }
{-* isize: }
{-* ireccount: }
{-* 返回值：取出的行情记录的实际的大小之和 }
{-* 0 行情接收队列为空 }
{-* < 0 出错 }
{-* > 0 正确，实际行情记录的大小 }
{-************************************************************************** }
{= }

var
  HQ_Uninit: function: BOOL  ;  stdcall; 
{+// }
{-* 资源释放操作, 清空行情接收队列，中断TCP或UDP的连接, 注销 }
{-************************************************************ }
{= }


var
  HQ_GetErrorNo: function: Integer  ;  stdcall; 
{+// }
{-返回值: }
{--1 ->传入的参数非法 }
{--2 ->与通信平台的连接失败 }
{--3 ->与行情服务器注册通信失败 }
{--4 ->接收行情队列为空 }
{--5 ->接收行情队列已满 }
{--6 ->与远程Socket通信失败 }
{--7 ->初始化本地Socket失败 }
{--8 ->存放取出的行情的缓冲区空间不足 }
{--9 ->创建线程失败 }
{--10 ->未初始化 }
{--11 ->已初始化过,再次初始化时报错 }
{-********************************************************** }
{= }


var
  HQ_Start: function: BOOL  ;  stdcall; 
{+// }
{-* 开始从行情服务器取行情, 在HQ_Init()成功执行这后,要调用HQ_Start才会从 }
{-* 行情服务器上取行情. }
{= }


var
  HQ_GetErrorMsg: procedure(msgbuf: PChar;
                           ibufsize: Integer)  ;  stdcall;
{+// }
{-* 获得最近一次错误的错误信息 }
{= }

var
  HQ_Stop: function: BOOL  ;  stdcall;
{+// }
{-* 暂停从行情服务器取行情, 想先暂时停止从行情服务器接收行情时,调用HQ_Stop() }
{-* 如果想结束程序而释放资源时,只要调用HQ_Uninit()就可以了,不用调用HQ_Stop(); }
{= }
{$ENDIF}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('KSHQDLL.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @HQ_Init := GetProcAddress(DLLHandle,'_HQ_Init@40');
  {$IFDEF WIN32}
    Assert(@HQ_Init <> nil);
  {$ENDIF}
    @HQ_GetRec := GetProcAddress(DLLHandle,'_HQ_GetRec@12');
  {$IFDEF WIN32}
    Assert(@HQ_GetRec <> nil);
  {$ENDIF}
    @HQ_GetnRec := GetProcAddress(DLLHandle,'_HQ_GetnRec@16');
  {$IFDEF WIN32}
    Assert(@HQ_GetnRec <> nil);
  {$ENDIF}
    @HQ_Uninit := GetProcAddress(DLLHandle,'_HQ_Uninit@0');
  {$IFDEF WIN32}
    Assert(@HQ_Uninit <> nil);
  {$ENDIF}
    @HQ_Start := GetProcAddress(DLLHandle,'_HQ_Start@0');
  {$IFDEF WIN32}
    Assert(@HQ_Start <> nil);
  {$ENDIF}
    @HQ_GetErrorMsg := GetProcAddress(DLLHandle,'_HQ_GetErrorMsg@8');
  {$IFDEF WIN32}
    Assert(@HQ_GetErrorMsg <> nil);
  {$ENDIF}
    @HQ_GetErrorNo := GetProcAddress(DLLHandle,'_HQ_GetErrorNo@0');
  {$IFDEF WIN32}
    Assert(@HQ_GetErrorNo <> nil);
  {$ENDIF}
    @HQ_Stop := GetProcAddress(DLLHandle,'_HQ_Stop@0');
  {$IFDEF WIN32}
    Assert(@HQ_Stop <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: KSHQDLL.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.

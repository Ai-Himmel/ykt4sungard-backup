unit KSRECVPUSH;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 2003-11-18                                            }
{    Generated Time: 20:24:18                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}

{=> d:\工作文档\newdll&testpushdll\ksrecvpush\KSRECVPUSH.H <=}

{/// The following ifdef block is the standard way of creating macros which make exporting }
{/// from a DLL simpler. All files within this DLL are compiled with the KSRECVPUSH_EXPORTS }
{/// symbol defined on the command line. this symbol should not be defined on any project }
{/// that uses this DLL. This way any other project whose source files include this file see }
{/// KSRECVPUSH_API functions as being imported from a DLL, wheras this DLL sees symbols }
{/// defined with this macro as being exported. }
{$IFNDEF __KSRECVPUSH_H}
{$DEFINE __KSRECVPUSH_H}

{$IFDEF KSRECVPUSH_EXPORTS}
//const
//  KSRECVPUSH_API = __declspec(dllexport);
{$ELSE}
//const
//  KSRECVPUSH_API = __declspec(dllimport);
{$IFDEF _DEBUG}
{ #pragma comment(lib,"../lib/ksRecvPushd.lib") }
{ #pragma message("Automatically Linking ksRecvPushd.dll") }
{$ELSE}
{ #pragma comment(lib,"../lib/ksRecvPush.lib") }
{ #pragma message("Automatically Linking ksRecvPush.dll") }
{$ENDIF}
{$ENDIF}

{$IFNDEF NOTIMSGINFO}
{$DEFINE NOTIMSGINFO}
const
  MAXMSGLEN = 255;
type
  ST_NOTIMSG = record
    nLevel: Integer;
    strMsg: array[0..MAXMSGLEN - 1] of Char;
  end {ST_NOTIMSG};
{$ENDIF}

{$IFDEF __cplusplus}
{$ENDIF}
  {///功能：初始化函数 }
  {///参数说明： }
  {///nBatch:会话批次号 }
  {///hCallerWnd:调用者的句柄 }
  {///nPushMessage:推送数据到达通知消息 }
  {///nNotiMessage:dll内部通知消息 }
  {///nReadPushMethod:推送数据读取方式 1-发送nPushMessage消息，接收者调用RecvPush_GetMultiPushPack获得数据 }
  {/// 2-不发送消息，接收者主动调用RecvPush_RecvPushPack获得数据 }
  {///nReadMsgMethod:内部消息读取方式 1-发送nNotiMessage消息，接收者调用RecvPush_GetMultiMsgPack获得数据 }
  {/// 2-不发送消息，接收者主动调用RecvPush_RecvMsgPack获得数据 }
  {///nMaxPushQueLen:系统内部保留的最大推送数据队列长度 }
  {///nMaxMsgQueLen:系统内部保留的最大内部消息队列长度 }
  {///返回值： }
  {///0 成功 }
  {///-1 失败，可以通过调用RecvPush_GetLastError得到内部失败代码和失败原因 }
var
  RecvPush_Initialize: function(nBatch: Integer;
    hCallerWnd: HWND = 0;
    nPushMessage: Integer = 0;
    nNotiMessage: Integer = 0;
    nReadPushMethod: Integer = 2;
    nReadMsgMethod: Integer = 2;
    nMaxPushQueLen: Integer = 1000;
    nMaxMsgQueLen: Integer = 1000): Integer stdcall;

  {///功能：开始接收函数 }
  {///参数说明: }
  {///strDrtpAddr:通讯平台ip地址 }
  {///nDrtpPort:通讯平台端口号 }
  {///nMainFunc:主功能号 }
  {///返回值： }
  {///0 成功 }
  {///-1 失败，可以通过调用RecvPush_GetLastError得到内部失败代码和失败原因 }
var
  RecvPush_Start: function(strDrtpAddr: PChar;
    nDrtpPort: Integer;
    nMainFunc: Integer): Integer stdcall;

  {///功能：停止接收函数 }
  {///返回值： }
  {///0 成功 }
  {///-1 失败，可以通过调用RecvPush_GetLastError得到内部失败代码和失败原因 }
var
  RecvPush_Stop: function: Integer stdcall;

  {///功能：释放资源函数 }
  {///返回值： }
  {///0 成功 }
  {///-1 失败，可以通过调用RecvPush_GetLastError得到内部失败代码和失败原因 }
var
  RecvPush_Uninitialize: function: Integer stdcall;

  {///功能：读取指定条数的推送数据（用于读取方式1）,数据以cpack方式存放 }
  {///参数说明： }
  {///buf:推送数据缓冲，不得小于cpack长度 }
  {///nBufSize:缓冲区的大小 }
  {///nPackCount:希望读取的数据个数 }
  {///返回值： }
  {///>0，真正获得的推送数据个数 }
  {///=0，当前没有推送数据 }
  {///-1 失败，可以通过调用RecvPush_GetLastError得到内部失败代码和失败原因 }
var
  RecvPush_GetMultiPushPack: function(buf: PChar;
    nBufSize: Integer;
    nPackCount: Integer): Integer stdcall;

  {///功能：读取指定条数的内部消息数据（用于读取方式1）,数据以ST_NOTIMSG方式存放 }
  {///参数说明： }
  {///buf:推送数据缓冲，不得小于ST_NOTIMSG长度 }
  {///nBufSize:缓冲区的大小 }
  {///nPackCount:希望读取的数据个数 }
  {///返回值： }
  {///>0，真正获得的内部消息数据个数 }
  {///=0，当前没有内部消息数据 }
  {///-1 失败，可以通过调用RecvPush_GetLastError得到内部失败代码和失败原因 }
var
  RecvPush_GetMultiMsgPack: function(buf: PChar;
    nBufSize: Integer;
    nPackCount: Integer): Integer stdcall;

  {///功能：读取一条推送数据（用于读取方式2），数据以CPACK方式存放 }
  {///参数说明： }
  {///buf:缓冲区，不得小于cpack长度 }
  {///nBufSize:缓冲区的大小 }
  {///nTimeOut:超时时间，以毫秒为单位，不得小于100ms,如果为0，则阻塞接收 }
  {///返回值： }
  {///0，超时 }
  {///1，读取成功 }
  {///-1 失败，可以通过调用RecvPush_GetLastError得到内部失败代码和失败原因 }
var
  RecvPush_RecvPushPack: function(buf: PChar;
    nBufSize: Integer;
    nTimeOut: Integer): Integer stdcall;

  {///功能：读取一条内部消息数据（用于读取方式2），数据以ST_NOTIMSG方式存放 }
  {///参数说明： }
  {///buf:缓冲区，不得小于ST_NOTIMSG长度 }
  {///nBufSize:缓冲区的大小 }
  {///nTimeOut:超时时间，以毫秒为单位，不得小于100ms,如果为0，则阻塞接收 }
  {///返回值： }
  {///0，超时 }
  {///1，读取成功 }
  {///-1 失败，可以通过调用RecvPush_GetLastError得到内部失败代码和失败原因 }
var
  RecvPush_RecvMsgPack: function(buf: PChar;
    nBufSize: Integer;
    nTimeOut: Integer): Integer stdcall;

  {///功能：查看内部消息队列缓冲区大小 }
  {///返回值： }
  {///>=0，队列缓冲区大小 }
  {///-1 失败，可以通过调用RecvPush_GetLastError得到内部失败代码和失败原因 }
var
  RecvPush_GetMsgQueLen: function: Integer stdcall;

  {///功能：查看推送队列缓冲区大小 }
  {///返回值： }
  {///>=0，队列缓冲区大小 }
  {///-1 失败，可以通过调用RecvPush_GetLastError得到内部失败代码和失败原因 }
var
  RecvPush_GetPushQueLen: function: Integer stdcall;

  {///功能：得到总的丢弃包个数 }
  {///返回值： }
  {///>=0 ,丢弃包个数 }
var
  RecvPush_GetThrowPackCount: function: Integer stdcall;

  {///功能：得到错误代码错误信息 }
  {///参数说明： }
  {///pErrorCode:错误代码 }
  {///strMsg:错误描述 }
var
  RecvPush_GetLastError: procedure(var pErrorCode: Integer;
    strMsg: PChar) stdcall;

{$IFDEF __cplusplus}
{$ENDIF}

{$ENDIF}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
{$IFDEF WIN32} = False;
{$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

procedure NewExit; far;
begin
  ExitProc := SaveExit;
  FreeLibrary(DLLHandle)
end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then
    Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000 {SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('KSRECVPUSH.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @RecvPush_Initialize := GetProcAddress(DLLHandle,
      '_RecvPush_Initialize@32');
{$IFDEF WIN32}
    Assert(@RecvPush_Initialize <> nil);
{$ENDIF}
    @RecvPush_Start := GetProcAddress(DLLHandle, '_RecvPush_Start@12');
{$IFDEF WIN32}
    Assert(@RecvPush_Start <> nil);
{$ENDIF}
    @RecvPush_Stop := GetProcAddress(DLLHandle, '_RecvPush_Stop@0');
{$IFDEF WIN32}
    Assert(@RecvPush_Stop <> nil);
{$ENDIF}
    @RecvPush_Uninitialize := GetProcAddress(DLLHandle,
      '_RecvPush_Uninitialize@0');
{$IFDEF WIN32}
    Assert(@RecvPush_Uninitialize <> nil);
{$ENDIF}
    @RecvPush_GetMultiPushPack := GetProcAddress(DLLHandle,
      '_RecvPush_GetMultiPushPack@12');
{$IFDEF WIN32}
    Assert(@RecvPush_GetMultiPushPack <> nil);
{$ENDIF}
    @RecvPush_GetMultiMsgPack := GetProcAddress(DLLHandle,
      '_RecvPush_GetMultiMsgPack@12');
{$IFDEF WIN32}
    Assert(@RecvPush_GetMultiMsgPack <> nil);
{$ENDIF}
    @RecvPush_RecvPushPack := GetProcAddress(DLLHandle,
      '_RecvPush_RecvPushPack@12');
{$IFDEF WIN32}
    Assert(@RecvPush_RecvPushPack <> nil);
{$ENDIF}
    @RecvPush_RecvMsgPack := GetProcAddress(DLLHandle,
      '_RecvPush_RecvMsgPack@12');
{$IFDEF WIN32}
    Assert(@RecvPush_RecvMsgPack <> nil);
{$ENDIF}
    @RecvPush_GetMsgQueLen := GetProcAddress(DLLHandle,
      '_RecvPush_GetMsgQueLen@0');
{$IFDEF WIN32}
    Assert(@RecvPush_GetMsgQueLen <> nil);
{$ENDIF}
    @RecvPush_GetPushQueLen := GetProcAddress(DLLHandle,
      '_RecvPush_GetPushQueLen@0');
{$IFDEF WIN32}
    Assert(@RecvPush_GetPushQueLen <> nil);
{$ENDIF}
    @RecvPush_GetThrowPackCount := GetProcAddress(DLLHandle,
      '_RecvPush_GetThrowPackCount@0');
{$IFDEF WIN32}
    Assert(@RecvPush_GetThrowPackCount <> nil);
{$ENDIF}
    @RecvPush_GetLastError := GetProcAddress(DLLHandle,
      '_RecvPush_GetLastError@8');
{$IFDEF WIN32}
    Assert(@RecvPush_GetLastError <> nil);
{$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: KSRECVPUSH.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
